<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fqzhanghao.github.io/</id>
    <title>浩浩的博客</title>
    <updated>2020-01-19T10:47:56.077Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fqzhanghao.github.io/"/>
    <link rel="self" href="https://fqzhanghao.github.io/atom.xml"/>
    <subtitle>记录日常生活</subtitle>
    <logo>https://fqzhanghao.github.io/images/avatar.png</logo>
    <icon>https://fqzhanghao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 浩浩的博客</rights>
    <entry>
        <title type="html"><![CDATA[安卓自定义View基础 - 坐标系]]></title>
        <id>https://fqzhanghao.github.io/post/an-zhuo-zi-ding-yi-view-ji-chu-zuo-biao-xi</id>
        <link href="https://fqzhanghao.github.io/post/an-zhuo-zi-ding-yi-view-ji-chu-zuo-biao-xi">
        </link>
        <updated>2020-01-19T10:46:59.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="一屏幕坐标系和数学坐标系的区别">一.屏幕坐标系和数学坐标系的区别</h1>
<p>由于移动设备一般定义屏幕左上角为坐标原点，向右为x轴增大方向，向下为y轴增大方向， 所以在手机屏幕上的坐标系与数学中常见的坐标系是稍微有点差别的，详情如下：</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="一屏幕坐标系和数学坐标系的区别">一.屏幕坐标系和数学坐标系的区别</h1>
<p>由于移动设备一般定义屏幕左上角为坐标原点，向右为x轴增大方向，向下为y轴增大方向， 所以在手机屏幕上的坐标系与数学中常见的坐标系是稍微有点差别的，详情如下：</p>
<!--more-->
<blockquote>
<p>（PS：其中的∠a 是对应的，注意y轴方向！）</p>
</blockquote>
<p><img src="http://ww2.sinaimg.cn/large/005Xtdi2jw1f1qygzfvhoj308c0dwglr.jpg" alt="" loading="lazy"><br>
<img src="http://ww1.sinaimg.cn/large/005Xtdi2jw1f1qyhbqvihj308c0dwjrh.jpg" alt="" loading="lazy"></p>
<h3 id="实际屏幕上的默认坐标系如下">实际屏幕上的默认坐标系如下：</h3>
<blockquote>
<p>PS: 假设其中棕色部分为手机屏幕</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="http://ww3.sinaimg.cn/large/005Xtdi2jw1f1qyhjy7h8j308c0dwq32.jpg" alt="" loading="lazy"></figure>
<h1 id="二view的坐标系">二.View的坐标系</h1>
<h3 id="注意view的坐标系统是相对于父控件而言的">注意：View的坐标系统是相对于父控件而言的.</h3>
<pre><code class="language-java">getTop();       //获取子View左上角距父View顶部的距离
getLeft();      //获取子View左上角距父View左侧的距离
getBottom();    //获取子View右下角距父View顶部的距离
getRight();     //获取子View右下角距父View左侧的距离
</code></pre>
<h3 id="如下图所示">如下图所示：</h3>
<figure data-type="image" tabindex="2"><img src="http://ww2.sinaimg.cn/large/005Xtdi2gw1f1qzqwvkkbj308c0dwgm9.jpg" alt="" loading="lazy"></figure>
<h1 id="三motionevent中-get-和-getraw-的区别">三.MotionEvent中 get 和 getRaw 的区别</h1>
<pre><code class="language-java">event.getX();       //触摸点相对于其所在组件坐标系的坐标
event.getY();

event.getRawX();    //触摸点相对于屏幕默认坐标系的坐标
event.getRawY();
</code></pre>
<h3 id="如下图所示-2">如下图所示：</h3>
<blockquote>
<p>PS:其中相同颜色的内容是对应的，其中为了显示方便，蓝色箭头向左稍微偏移了一点.</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="http://ww1.sinaimg.cn/large/005Xtdi2jw1f1r2bdlqhbj308c0dwwew.jpg" alt="" loading="lazy"></figure>
<h1 id="四核心要点">四.核心要点</h1>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th>要点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>在数学中常见的坐标系与屏幕默认坐标系的差别</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>View的坐标系是相对于父控件而言的</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>MotionEvent中get和getRaw的区别</td>
</tr>
</tbody>
</table>
<h1 id="五参考文章">五.参考文章</h1>
<ul>
<li><a href="http://blog.csdn.net/wangjinyu501/article/details/21827341" title="Android 屏幕（View）坐标系统">Android 屏幕（View）坐标系统</a></li>
</ul>
<p>转自 : <a href="http://www.gcssloop.com/customview/CoordinateSystem/">http://www.gcssloop.com/customview/CoordinateSystem/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给初学者的RxJava2.0教程(二)]]></title>
        <id>https://fqzhanghao.github.io/post/gei-chu-xue-zhe-de-rxjava20-jiao-cheng-er</id>
        <link href="https://fqzhanghao.github.io/post/gei-chu-xue-zhe-de-rxjava20-jiao-cheng-er">
        </link>
        <updated>2020-01-19T10:24:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>上一节教程讲解了最基本的RxJava2的使用, 在本节中, 我们将学习RxJava强大的线程控制.</p>
<h3 id="正题">正题</h3>
<p>还是以之前的例子, 两根水管:</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119182526.png" alt="" loading="lazy"></figure>
<p>正常情况下, 上游和下游是工作在同一个线程中的, 也就是说上游在哪个线程发事件, 下游就在哪个线程接收事件.</p>
<p>怎么去理解呢, 以Android为例, 一个Activity的所有动作默认都是在主线程中运行的, 比如我们在onCreate中打出当前线程的名字:</p>
<pre><code class="language-java">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Log.d(TAG, Thread.currentThread().getName());
    }
</code></pre>
<p>结果便是:</p>
<pre><code class="language-java">    D/TAG: main
</code></pre>
<p>回到RxJava中, 当我们在主线程中去创建一个上游Observable来发送事件, 则这个上游默认就在主线程发送事件.</p>
<p>当我们在主线程去创建一个下游Observer来接收事件, 则这个下游默认就在主线程中接收事件, 来看段代码:</p>
<pre><code class="language-java">    @Override                                                                                      
    protected void onCreate(Bundle savedInstanceState) {                                            
        super.onCreate(savedInstanceState);                                                         
        setContentView(R.layout.activity_main);                                                     
                                                                              
        Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   
            @Override                                                                               
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            
                Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           
                Log.d(TAG, &quot;emit 1&quot;);                                                               
                emitter.onNext(1);                                                                  
            }                                                                                       
        });                                                                                         
                                                                                                    
        Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      
            @Override                                                                               
            public void accept(Integer integer) throws Exception {                                  
                Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              
                Log.d(TAG, &quot;onNext: &quot; + integer);                                                   
            }                                                                                       
        };                                                                                          
                                                                                                    
        observable.subscribe(consumer);                                                             
}
</code></pre>
<p>在主线程中分别创建上游和下游, 然后将他们连接在一起, 同时分别打印出它们所在的线程, 运行结果为:</p>
<pre><code class="language-java">D/TAG: Observable thread is : main
D/TAG: emit 1                     
D/TAG: Observer thread is :main   
D/TAG: onNext: 1            
</code></pre>
<p>这就验证了刚才所说, 上下游默认是在同一个线程工作.</p>
<p>这样肯定是满足不了我们的需求的, 我们更多想要的是这么一种情况, 在子线程中做耗时的操作, 然后回到主线程中来操作UI, 用图片来描述就是下面这个图片:</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119183654.png" alt="" loading="lazy"></figure>
<p>在这个图中, 我们用黄色水管表示子线程, 深蓝色水管表示主线程.</p>
<p>要达到这个目的, 我们需要先改变上游发送事件的线程, 让它去子线程中发送事件, 然后再改变下游的线程, 让它去主线程接收事件. 通过RxJava内置的线程调度器可以很轻松的做到这一点. 接下来看一段代码:</p>
<pre><code class="language-java">@Override                                                                                       
protected void onCreate(Bundle savedInstanceState) {                                            
    super.onCreate(savedInstanceState);                                                         
    setContentView(R.layout.activity_main);                                                     
                                                                                                
    Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   
        @Override                                                                               
        public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            
            Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           
            Log.d(TAG, &quot;emit 1&quot;);                                                               
            emitter.onNext(1);                                                                  
        }                                                                                       
    });                                                                                         
                                                                                                
    Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      
        @Override                                                                               
        public void accept(Integer integer) throws Exception {                                  
            Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              
            Log.d(TAG, &quot;onNext: &quot; + integer);                                                   
        }                                                                                       
    };                                                                                          
                                                                                                
    observable.subscribeOn(Schedulers.newThread())                                              
            .observeOn(AndroidSchedulers.mainThread())                                          
            .subscribe(consumer);                                                               
}
</code></pre>
<p>还是刚才的例子, 只不过我们太添加了一点东西, 先来看看运行结果:</p>
<pre><code class="language-java">D/TAG: Observable thread is : RxNewThreadScheduler-2  
D/TAG: emit 1                                         
D/TAG: Observer thread is :main                       
D/TAG: onNext: 1
</code></pre>
<p>可以看到, 上游发送事件的线程的确改变了, 是在一个叫  RxNewThreadScheduler-2的线程中发送的事件, 而下游仍然在主线程中接收事件, 这说明我们的目的达成了, 接下来看看是如何做到的.</p>
<p>和上一段代码相比,这段代码只不过是增加了两行代码:</p>
<pre><code class="language-java">.subscribeOn(Schedulers.newThread())                                              
.observeOn(AndroidSchedulers.mainThread())   
</code></pre>
<p>作为一个初学者的入门教程, 并不会贴出一大堆源码来分析, 因此只需要让大家记住几个要点, 已达到如何正确的去使用这个目的才是我们的目标.</p>
<p>简单的来说, subscribeOn() 指定的是上游发送事件的线程, observeOn() 指定的是下游接收事件的线程.</p>
<p>多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有第一次的有效, 其余的会被忽略.</p>
<p>多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次.</p>
<p>举个例子:</p>
<pre><code class="language-java">observable.subscribeOn(Schedulers.newThread())     
         .subscribeOn(Schedulers.io())              
         .observeOn(AndroidSchedulers.mainThread()) 
         .observeOn(Schedulers.io())                
         .subscribe(consumer);
</code></pre>
<p>这段代码中指定了两次上游发送事件的线程, 分别是newThread和IO线程, 下游也指定了两次线程,分别是main和IO线程. 运行结果为:</p>
<pre><code class="language-java">D/TAG: Observable thread is : RxNewThreadScheduler-3
D/TAG: emit 1                                       
D/TAG: Observer thread is :RxCachedThreadScheduler-1
D/TAG: onNext: 1
</code></pre>
<p>可以看到, 上游虽然指定了两次线程, 但只有第一次指定的有效, 依然是在RxNewThreadScheduler 线程中, 而下游则跑到了RxCachedThreadScheduler 中, 这个CacheThread其实就是IO线程池中的一个.</p>
<p>为了更清晰的看到下游的线程切换过程, 我们加点log:</p>
<pre><code class="language-java">observable.subscribeOn(Schedulers.newThread())
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnNext(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {
                        Log.d(TAG, &quot;After observeOn(mainThread), current thread is: &quot; + Thread.currentThread().getName());
                    }
                })
                .observeOn(Schedulers.io())
                .doOnNext(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {
                        Log.d(TAG, &quot;After observeOn(io), current thread is : &quot; + Thread.currentThread().getName());
                    }
                })
                .subscribe(consumer);
</code></pre>
<p>我们在下游线程切换之后, 把当前的线程打印出来, 运行结果:</p>
<pre><code class="language-java">D/TAG: Observable thread is : RxNewThreadScheduler-1                                             
D/TAG: emit 1                                                                                    
D/TAG: After observeOn(mainThread), current thread is: main                                      
D/TAG: After observeOn(io), current thread is : RxCachedThreadScheduler-2                        
D/TAG: Observer thread is :RxCachedThreadScheduler-2                                             
D/TAG: onNext: 1
</code></pre>
<p>可以看到, 每调用一次observeOn() 线程便会切换一次, 因此如果我们有类似的需求时, 便可知道如何处理了.</p>
<p>在RxJava中, 已经内置了很多线程选项供我们选择, 例如有</p>
<ul>
<li>Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作</li>
<li>Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作</li>
<li>Schedulers.newThread() 代表一个常规的新线程</li>
<li>AndroidSchedulers.mainThread() 代表Android的主线程</li>
</ul>
<p>这些内置的Scheduler已经足够满足我们开发的需求, 因此我们应该使用内置的这些选项, 在RxJava内部使用的是线程池来维护这些线程, 所有效率也比较高.</p>
<h3 id="实践">实践</h3>
<p>对于我们Android开发人员来说, 经常会将一些耗时的操作放在后台, 比如网络请求或者读写文件,操作数据库等等,等到操作完成之后回到主线程去更新UI, 有了上面的这些基础, 那么现在我们就可以轻松的去做到这样一些操作.</p>
<p>下面来举几个常用的场景.</p>
<h4 id="网络请求">网络请求</h4>
<p>Android中有名的网络请求库就那么几个, Retrofit能够从中脱颖而出很大原因就是因为它支持RxJava的方式来调用, 下面简单讲解一下它的基本用法.</p>
<p>要使用Retrofit,先添加Gradle配置:</p>
<pre><code class="language-java">    //retrofit
    compile 'com.squareup.retrofit2:retrofit:2.1.0'
    //Gson converter
    compile 'com.squareup.retrofit2:converter-gson:2.1.0'
    //RxJava2 Adapter
    compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'
    //okhttp
    compile 'com.squareup.okhttp3:okhttp:3.4.1'
    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'
</code></pre>
<p>随后定义Api接口:</p>
<pre><code class="language-java">public interface Api {
    @GET
    Observable&lt;LoginResponse&gt; login(@Body LoginRequest request);

    @GET
    Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);
}
</code></pre>
<p>接着创建一个Retrofit客户端:</p>
<pre><code class="language-java">private static Retrofit create() {
            OkHttpClient.Builder builder = new OkHttpClient().newBuilder();
            builder.readTimeout(10, TimeUnit.SECONDS);
            builder.connectTimeout(9, TimeUnit.SECONDS);

            if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
                interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
                builder.addInterceptor(interceptor);
            }

            return new Retrofit.Builder().baseUrl(ENDPOINT)
                    .client(builder.build())
                    .addConverterFactory(GsonConverterFactory.create())
                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                    .build();
}
</code></pre>
<p>发起请求就很简单了:</p>
<pre><code class="language-java">Api api = retrofit.create(Api.class);
        api.login(request)
             .subscribeOn(Schedulers.io())               //在IO线程进行网络请求
             .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求结果
            .subscribe(new Observer&lt;LoginResponse&gt;() {
                @Override
                public void onSubscribe(Disposable d) {}

                @Override
                public void onNext(LoginResponse value) {}

                @Override
                public void onError(Throwable e) {
                    Toast.makeText(mContext, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show();
                }

                @Override
                public void onComplete() {
                    Toast.makeText(mContext, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();
                }
            });
</code></pre>
<p>看似很完美, 但我们忽略了一点, 如果在请求的过程中Activity已经退出了, 这个时候如果回到主线程去更新UI, 那么APP肯定就崩溃了, 怎么办呢, 上一节我们说到了Disposable , 说它是个开关, 调用它的dispose()方法时就会切断水管, 使得下游收不到事件, 既然收不到事件, 那么也就不会再去更新UI了. 因此我们可以在Activity中将这个Disposable 保存起来, 当Activity退出时, 切断它即可.</p>
<p>那如果有多个Disposable 该怎么办呢, RxJava中已经内置了一个容器CompositeDisposable, 每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可切断所有的水管.</p>
<h4 id="读写数据库">读写数据库</h4>
<p>上面说了网络请求的例子, 接下来再看看读写数据库, 读写数据库也算一个耗时的操作, 因此我们也最好放在IO线程里去进行, 这个例子就比较简单, 直接上代码:</p>
<pre><code class="language-java">public Observable&lt;List&lt;Record&gt;&gt; readAllRecords() {
        return Observable.create(new ObservableOnSubscribe&lt;List&lt;Record&gt;&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;List&lt;Record&gt;&gt; emitter) throws Exception {
                Cursor cursor = null;
                try {
                    cursor = getReadableDatabase().rawQuery(&quot;select * from &quot; + TABLE_NAME, new String[]{});
                    List&lt;Record&gt; result = new ArrayList&lt;&gt;();
                    while (cursor.moveToNext()) {
                        result.add(Db.Record.read(cursor));
                    }
                    emitter.onNext(result);
                    emitter.onComplete();
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给初学者的RxJava2.0教程(一)]]></title>
        <id>https://fqzhanghao.github.io/post/gei-chu-xue-zhe-de-rxjava20-jiao-cheng-yi</id>
        <link href="https://fqzhanghao.github.io/post/gei-chu-xue-zhe-de-rxjava20-jiao-cheng-yi">
        </link>
        <updated>2020-01-19T10:23:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>上个月RxJava2正式版发布了，但目前国内的资料还比较少，以前使用过RxJava1只需要看看更新文档就知道怎么使用了，但还有一些以前没用过RxJava的朋友可能就不知道怎么办了，不知道该看RxJava1还是直接跳到RxJava2。所以写下这个教程， 帮助那些没有用过RxJava的朋友入门。</p>
<p>我先回答这个问题：学习RxJava2需要先学习RxJava1吗？</p>
<p>这个问题就像论坛经常问学Java前需要先学习C语言吗，这里就不引战了！（PHP是世界上最好的语言！！）</p>
<p>答案明显不是，如果你以前学过RxJava1，那么对于RxJava2只需要看看更新了哪些东西就行了，其最核心的思想并没有变化，如果你没学过RxJava1，没有关系，直接学习RxJava2。所以作为一个RxJava2的教程，本文中所有的名词都属于RxJava2中，并不涉及RxJava1。</p>
<p>要在Android中使用RxJava2, 先添加Gradle配置:</p>
<pre><code class="language-java">    compile 'io.reactivex.rxjava2:rxjava:2.0.1'
    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'
</code></pre>
<h3 id="正题">正题</h3>
<p>在开始学习之前，先来介绍点原理性的东西。</p>
<p>网上也有很多介绍RxJava原理的文章，通常这些文章都从观察者模式开始，先讲观察者，被观察者，订阅关系巴拉巴拉一大堆，说实话，当我第一次看到这些文章的时候已经被这些名词给绕晕了，用了很长的时间才理清楚它们之间的关系。可能是我太蠢了，境界不够，领会不到那么多高大上的名词.</p>
<p>今天我用两根水管代替观察者和被观察者, 试图用通俗易懂的话把它们的关系解释清楚, 在这里我将从事件流这个角度来说明RxJava的基本工作原理。</p>
<p>先假设有两根水管：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184528.png" alt="" loading="lazy"></figure>
<p>上面一根水管为事件产生的水管，叫它上游吧，下面一根水管为事件接收的水管叫它下游吧。</p>
<p>两根水管通过一定的方式连接起来，使得上游每产生一个事件，下游就能收到该事件。注意这里和官网的事件图是反过来的, 这里的事件发送的顺序是先1,后2,后3这样的顺序, 事件接收的顺序也是先1,后2,后3的顺序, 我觉得这样更符合我们普通人的思维, 简单明了.</p>
<p>这里的上游和下游就分别对应着RxJava中的Observable和Observer，它们之间的连接就对应着subscribe()，因此这个关系用RxJava来表示就是：</p>
<pre><code class="language-java">        //创建一个上游 Observable：
        Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onComplete();
            }
        });
        //创建一个下游 Observer
        Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;subscribe&quot;);
            }

            @Override
            public void onNext(Integer value) {
                Log.d(TAG, &quot;&quot; + value);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;error&quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;complete&quot;);
            }
        };
        //建立连接
        observable.subscribe(observer);
</code></pre>
<p>这个运行的结果就是:</p>
<pre><code>12-02 03:37:17.818 4166-4166/zlc.season.rxjava2demo D/TAG: subscribe
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 1
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 2
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 3
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: complete
</code></pre>
<pre><code>注意: 只有当上游和下游建立连接之后, 上游才会开始发送事件. 也就是调用了subscribe() 方法之后才开始发送事件.
</code></pre>
<p>把这段代码连起来写就成了RxJava引以为傲的链式操作：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onComplete();
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;subscribe&quot;);
            }

            @Override
            public void onNext(Integer value) {
                Log.d(TAG, &quot;&quot; + value);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;error&quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;complete&quot;);
            }
        });
</code></pre>
<p>接下来解释一下其中两个陌生的玩意：ObservableEmitter和Disposable.</p>
<p>ObservableEmitter： Emitter是发射器的意思，那就很好猜了，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。</p>
<p>但是，请注意，并不意味着你可以随意乱七八糟发射事件，需要满足一定的规则：</p>
<ul>
<li>
<p>上游可以发送无限个onNext, 下游也可以接收无限个onNext.</p>
</li>
<li>
<p>当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送-, 而下游收到onComplete事件之后将不再继续接收事件.</p>
</li>
<li>
<p>当上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.</p>
</li>
<li>
<p>上游可以不发送onComplete或onError.</p>
</li>
<li>
<p>最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然</p>
<p>注: 关于onComplete和onError唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, **并不一定会导致程序崩溃. ** 比如发送多个onComplete是可以正常运行的, 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError, 则收到第二个onError事件会导致程序会崩溃.</p>
</li>
</ul>
<p>以上几个规则用示意图表示如下:</p>
<p>只发送onNext事件</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184547.png" alt="" loading="lazy"></figure>
<p>发送onComplete事件</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184606.png" alt="" loading="lazy"></figure>
<p>发送onError事件</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184623.png" alt="" loading="lazy"></figure>
<p>介绍了ObservableEmitter, 接下来介绍Disposable, 这个单词的字面意思是一次性用品,用完即可丢弃的. 那么在RxJava中怎么去理解它呢, 对应于上面的水管的例子, 我们可以把它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.</p>
<pre><code>注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件.
</code></pre>
<p>来看个例子, 我们让上游依次发送1,2,3,complete,4,在下游收到第二个事件之后, 切断水管, 看看运行结果:</p>
<pre><code>        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                Log.d(TAG, &quot;emit 1&quot;);
                emitter.onNext(1);
                Log.d(TAG, &quot;emit 2&quot;);
                emitter.onNext(2);
                Log.d(TAG, &quot;emit 3&quot;);
                emitter.onNext(3);
                Log.d(TAG, &quot;emit complete&quot;);
                emitter.onComplete();
                Log.d(TAG, &quot;emit 4&quot;);
                emitter.onNext(4);
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            private Disposable mDisposable;
            private int i;

            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;subscribe&quot;);
                mDisposable = d;
            }

            @Override
            public void onNext(Integer value) {
                Log.d(TAG, &quot;onNext: &quot; + value);
                i++;
                if (i == 2) {
                    Log.d(TAG, &quot;dispose&quot;);
                    mDisposable.dispose();
                    Log.d(TAG, &quot;isDisposed : &quot; + mDisposable.isDisposed());
                }
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;error&quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;complete&quot;);
            }
        });
</code></pre>
<p>运行结果为:</p>
<pre><code>12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: subscribe
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 1
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: onNext: 1
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 2
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: onNext: 2
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: dispose
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: isDisposed : true
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 3
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit complete
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 4
</code></pre>
<p>从运行结果我们看到, 在收到onNext 2这个事件后, 切断了水管, 但是上游仍然发送了3, complete, 4这几个事件, 而且上游并没有因为发送了onComplete而停止. 同时可以看到下游的onSubscribe()方法是最先调用的.</p>
<p>Disposable的用处不止这些, 后面讲解到了线程的调度之后, 我们会发现它的重要性. 随着后续深入的讲解, 我们会在更多的地方发现它的身影.</p>
<p>另外, subscribe()有多个重载的方法:</p>
<pre><code>    public final Disposable subscribe() {}
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) {}
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) {} 
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) {}
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) {}
    public final void subscribe(Observer&lt;? super T&gt; observer) {}
</code></pre>
<p>最后一个带有Observer参数的我们已经使用过了,这里对其他几个方法进行说明.</p>
<ul>
<li>不带任何参数的subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 老子可不管你发什么.</li>
<li>带有一个Consumer参数的方法表示下游只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写:</li>
</ul>
<pre><code>        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                Log.d(TAG, &quot;emit 1&quot;);
                emitter.onNext(1);
                Log.d(TAG, &quot;emit 2&quot;);
                emitter.onNext(2);
                Log.d(TAG, &quot;emit 3&quot;);
                emitter.onNext(3);
                Log.d(TAG, &quot;emit complete&quot;);
                emitter.onComplete();
                Log.d(TAG, &quot;emit 4&quot;);
                emitter.onNext(4);
            }
        }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {
                Log.d(TAG, &quot;onNext: &quot; + integer);
            }
        });
</code></pre>
<ul>
<li>其他几个方法同理, 这里就不一一解释了.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优化Gridea网站加载速度]]></title>
        <id>https://fqzhanghao.github.io/post/you-hua-gridea-wang-zhan-jia-zai-su-du</id>
        <link href="https://fqzhanghao.github.io/post/you-hua-gridea-wang-zhan-jia-zai-su-du">
        </link>
        <updated>2019-10-02T06:15:06.000Z</updated>
        <summary type="html"><![CDATA[<p>我觉得一开始的加载速度实在是太慢了，一直在转圈圈。<br>
打开网站，按F12，查看network选项卡，锁定了几个js脚本比较缓慢，一个sidebar图片比较缓慢。<br>
so,开始替换。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我觉得一开始的加载速度实在是太慢了，一直在转圈圈。<br>
打开网站，按F12，查看network选项卡，锁定了几个js脚本比较缓慢，一个sidebar图片比较缓慢。<br>
so,开始替换。</p>
<!-- more -->
<h2 id="1替换jscss">1.替换js,css</h2>
<p>搜索找到最快的js CDN托管。<a href="https://cdnjs.com/">cdnjs地址</a><br>
找到Gridea的theme文件夹，我使用的SIMPLE，主要修改以下几处<br>
your\path\Gridea\themes\simple\templates_blocks\head.ejs</p>
<pre><code class="language-ejs">\\替换gittalk
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.5.0/gitalk.min.css&quot; /&gt;
\\替换vue，highlight，aos
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.css&quot; /&gt;
</code></pre>
<p>your\path\Gridea\themes\simple\templates_blocks\scripts.ejs</p>
<pre><code class="language-ejs">\\替换aos
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.js&quot;&gt;&lt;/script&gt;
\\替换gittalk
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.5.0/gitalk.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>其实我这边没有开评论，也就无所谓了，如果你开了评论系统的话，最好还是替换以下</p>
<p>##2.替换sidebar图片<br>
从加载上来看，sidebar图片过大，我这边使用了tinypng进行了压缩处理<a href="https://tinypng.com/">tinypng地址</a>。从800K减小到了200K,能小一点是一点。其实最好换成纯色背景，这样会更快。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[兼职计划]]></title>
        <id>https://fqzhanghao.github.io/post/kai-shi-jian-zhi-ji-hua</id>
        <link href="https://fqzhanghao.github.io/post/kai-shi-jian-zhi-ji-hua">
        </link>
        <updated>2019-07-11T04:14:56.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>我计划分以下几步</p>
<p>一、社群</p>
<p>1.创建QQ群：京东优惠券购物群<br>
2.创建微信群：京东优惠券购物群<br>
3.创建公众号：京东优惠券购物</p>
<p>二、小程序</p>
<p>求生之路图鉴，接入广告</p>
<p>三、app</p>
<p>mp3铃声剪辑，接入广告</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[V2Ray WebSocket实现外网访问]]></title>
        <id>https://fqzhanghao.github.io/post/v2ray-websocket-shi-xian-wai-wang-fang-wen</id>
        <link href="https://fqzhanghao.github.io/post/v2ray-websocket-shi-xian-wai-wang-fang-wen">
        </link>
        <updated>2019-06-07T06:41:17.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 V2Ray 的 WebSocket 传输协议 + Cloudflare 可以访问无法ping通的ip.简单说就是使用 V2Ray 的 WebSocket + TLS 传输协议，使用Cloudflare 中转。</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 V2Ray 的 WebSocket 传输协议 + Cloudflare 可以访问无法ping通的ip.简单说就是使用 V2Ray 的 WebSocket + TLS 传输协议，使用Cloudflare 中转。</p>
<!--more-->
<h3 id="准备工作">准备工作</h3>
<p>去<a href="https://my.freenom.com">freenom</a>注册一个免费域名.</p>
<p>去<a href="https://dash.cloudflare.com">cloudflare</a>注册一个账户</p>
<h3 id="开始工作">开始工作</h3>
<ol>
<li>先去cloudflare的DNS配置页配置如下</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607101504.png" alt="" loading="lazy"></figure>
<p>加密选项配置如下</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607101620.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>去免费域名处,将第一步的DNS解析填入</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607101750.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607104552.png" alt="" loading="lazy"></figure>
<p>3.完成以后,就可以去你的IDC服务商后台,使用webshell安装V2ray.配置成websocket+ssl模式.域名填写为准备工作的免费域名.自己搞太麻烦了,我这边用的是一键脚本.</p>
<blockquote>
<p>bash &lt;(curl -s -L https://233v2.com/v2ray.sh)</p>
</blockquote>
<p>这一步会自动配置v2ray参数,并生成ssl证书,如果自己搞的话,还需要在nginx里面配置,自己创建证书.(当然也可以用cloudflare的,免费15年,一劳永逸)</p>
<p>4.再到cloudflare网站去,将dns选项中的灰色云朵,点黄即可.状态为DNS and HTTP proxy(CDN)</p>
<h3 id="备注">备注</h3>
<p>无限域名模式.万一上面的操作完成以后,还是有问题.可以在cloudflare使用如下配置.</p>
<p>WebSocket 协议，80 端口，Cloudflare 的 Crypto 选项卡 SSL 为 Flexible</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务器搭建aira2和webui]]></title>
        <id>https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-aira2-he-webui</id>
        <link href="https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-aira2-he-webui">
        </link>
        <updated>2019-05-23T06:47:31.000Z</updated>
        <summary type="html"><![CDATA[<p>新买的服务器安装下载服务器</p>
]]></summary>
        <content type="html"><![CDATA[<p>新买的服务器安装下载服务器</p>
<!-- more-->
<h3 id="基础软件的安装">基础软件的安装</h3>
<p>在下载Aria2之前先安装一些基础必备的软件：git、screen、nodejs</p>
<blockquote>
<p>sudo apt-get install git screen nodejs</p>
</blockquote>
<p>如果有些软件已经安装过了就不用再安装</p>
<h3 id="在命令行中安装aria2">在命令行中安装aria2</h3>
<p>在Ubuntu 18.04操作系统命令行中运行以下命令：</p>
<blockquote>
<p>sudo apt-get install aria2</p>
</blockquote>
<p>以下是安装aria2后的一些基本常识：</p>
<pre><code>sudo mkdir /etc/aria2　#新建文件夹 

sudo touch /etc/aria2/aria2.session　#新建session文件

sudo chmod 777 /etc/aria2/aria2.session　#设置aria2.session可写 

sudo vi /etc/aria2/aria2.conf　#创建配置文件
</code></pre>
<h3 id="aria2conf文件配置">aria2.conf文件配置</h3>
<pre><code>dir=/home/ye/download

disable-ipv6=true

#打开rpc的目的是为了给web管理端用

enable-rpc=true

rpc-allow-origin-all=true

rpc-listen-all=true

#rpc-listen-port=6800

#断点续传

continue=true

input-file=/etc/aria2/aria2.session

save-session=/etc/aria2/aria2.session

#最大同时下载任务数

max-concurrent-downloads=20

save-session-interval=120

# Http/FTP 相关

connect-timeout=120

#lowest-speed-limit=10K

#同服务器连接数

max-connection-per-server=10

#max-file-not-found=2

#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要

min-split-size=10M

#单文件最大线程数, 路由建议值: 5

split=10

check-certificate=false

#http-no-cache=true
</code></pre>
<h3 id="下载aria2webui">下载Aria2WebUI</h3>
<p>首先切换到用户目录下</p>
<blockquote>
<p>cd /home/ye</p>
</blockquote>
<p>同样也是一行命令：</p>
<blockquote>
<p>git clone https://github.com/ziahamza/webui-aria2.git</p>
</blockquote>
<p>下载完之后会在当前目录下创建一个webui-aria2目录。</p>
<h3 id="设置aria2监听rpc启动webui">设置Aria2监听rpc，启动WebUI</h3>
<blockquote>
<p>screen -S aria2</p>
</blockquote>
<p>新建一个名为aria2的会话</p>
<p><strong>注意那个S是大写！S是大写！S是大写！</strong></p>
<p>在新的会话中输入：</p>
<pre><code class="language-undefined">aria2c --conf-path=/etc/aria2/aria2.conf --enable-rpc --rpc-listen-all --rpc-secret xxxxxxx
</code></pre>
<p>注意：参数–rpc-secret 后面的字符串是自己自定义的token密码，要记住！要记住！要记住！</p>
<p>执行后会显示：</p>
<pre><code class="language-undefined">root@ubuntu:~# aria2c --conf-path=/etc/aria2/aria2.conf --enable-rpc --rpc-listen-all --rpc-secret xxxxxxx

08/01 15:42:28 [NOTICE] IPv4 RPC: listening on TCP port 6800

08/01 15:42:28 [NOTICE] IPv6 RPC: listening on TCP port 6800root@ubuntu:~# aria2c --enable-rpc --rpc-listen-all --rpc-secret asdfghjkl

08/01 15:42:28 [NOTICE] IPv4 RPC: listening on TCP port 6800

08/01 15:42:28 [NOTICE] IPv6 RPC: listening on TCP port 6800
</code></pre>
<p>记住port后面的端口号“6800”</p>
<p>然后依次按下键盘的ctrl、A、D 这三个键，回到前一个会话，输入</p>
<pre><code class="language-undefined">screen -S webui
</code></pre>
<p>新建一个名为webui的会话</p>
<p>在新的会话中，先跳转到上面说的webui-aria2目录中，再输入启动命令</p>
<pre><code>cd /home/ye/webui-aria2
node node-server.js
</code></pre>
<p>显示如下:</p>
<pre><code class="language-undefined">root@ubuntu:~/webui-aria2# node node-server.js
WebUI Aria2 Server is running on http://localhost:8888
</code></pre>
<p>出现<code>WebUI Aria2 Server is running on http://localhost:8888</code>说明WebUI已经启动成功，访问 http://YourIP:8888 即可进入Web界面</p>
<p>还是依次按下键盘的ctrl、A、D 这三个键，回到前一个会话，如果是用ssh客户端（如Putty）登陆的会话，这个时候就可以关闭这个会话了。</p>
<h3 id="进入webui界面通过rpc接口连接aria2">进入WebUI界面，通过rpc接口连接Aria2</h3>
<p>如果你是在有公网ip的vps上搭建的，访问“公网ip:8888/”就行了。</p>
<p>进入WebUI界面后可能会提示</p>
<pre><code class="language-undefined">糟糕！ 连接到 Aria2 RPC 服务器时认证失败，将在10秒后重试。
您可能需要确认您的身份验证信息，请前往 设置 &gt; 连接设置
</code></pre>
<p>这个时候在设置&gt;连接设置里设置一下RPC服务</p>
<p>主机后面填写Aria2服务所在的主机的ip，端口就是第四步中启动Aria2 监听RPC的端口6800，密码令牌就是参数**–rpc-secret 后面的字符串，**第四步中让你记住的那个。这三个填完点最下面的“保存连接配置”即可。只要配置填对了就能连接到Aria2了</p>
<p>教程到此结束了,其余的设置可参考下面的链接,里面有具体的用法和具体含义</p>
<h3 id="参考链接">参考链接:</h3>
<p><a href="https://blog.sunriseydy.top/technology/server-blog/server/zaiubuntushangyongaria2hearia2webuishixianyuanchengduoxianchengxiazai/">ubuntu上安装aria2及webui</a></p>
<p><a href="https://ywnz.com/linuxjc/2686.html">在Ubuntu 18.04系统下安装配置和使用aria2</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务器搭建ftp]]></title>
        <id>https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-ftp</id>
        <link href="https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-ftp">
        </link>
        <updated>2019-05-23T06:47:03.000Z</updated>
        <summary type="html"><![CDATA[<p>新买的服务器安装ftp服务器</p>
]]></summary>
        <content type="html"><![CDATA[<p>新买的服务器安装ftp服务器</p>
<!-- more-->
<p>1、使用命令安装</p>
<blockquote>
<p>sudo apt install vsftpd</p>
</blockquote>
<p>2、为FTP添加用户</p>
<blockquote>
<p>sudo useradd -m ye</p>
</blockquote>
<p>3、为ye用户设置密码</p>
<blockquote>
<p>sudo passwd ye</p>
</blockquote>
<p>4、在/home/ye/目录中创建一个download目录用于作为ftp的根目录</p>
<blockquote>
<p>cd /home/ye</p>
<p>mkdir download</p>
</blockquote>
<p>5、使用 sudo vim /etc/vsftpd.conf编辑配置文件，用于配置目录信息</p>
<pre><code>local_root=/home/sunftp/ftpdir
allow_writeable_chroot=YES
chroot_local_user=YES
</code></pre>
<p>6、其他选择默认，保存退出，然后启动</p>
<blockquote>
<p>sudo service vsftpd start</p>
</blockquote>
<p>备注:</p>
<ol>
<li>
<p><a href="https://blog.csdn.net/liwb94/article/details/80090082">vsftpd参数参考</a></p>
</li>
<li>
<p>第五步中的配置: 如果不进行参数配置也是可以的.用户的根目录为/home/ye.即当前登录用户的根目录.对于我们来说够用了,不用配置太多</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务器搭建http服务]]></title>
        <id>https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-http-fu-wu</id>
        <link href="https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-http-fu-wu">
        </link>
        <updated>2019-05-23T06:46:34.000Z</updated>
        <summary type="html"><![CDATA[<p>新买的服务器安装http服务器</p>
]]></summary>
        <content type="html"><![CDATA[<p>新买的服务器安装http服务器</p>
<!-- more-->
<p>首先安装Apache</p>
<blockquote>
<p>sudo apt-get install apache2</p>
</blockquote>
<p>Apache2的默认访问端口为80，当端口被占用时需要更改其访问端口</p>
<p>进入apache2的安装目录  /etc/apache2/，修改器ports.conf文件</p>
<pre><code># If you just change the port or add more ports here, you will likely also
# have to change the VirtualHost statement in
# /etc/apache2/sites-enabled/000-default.conf

#Listen 80
Listen 8001

&lt;IfModule ssl_module&gt;
        Listen 443
&lt;/IfModule&gt;

&lt;IfModule mod_gnutls.c&gt;
        Listen 443
&lt;/IfModule&gt;

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
</code></pre>
<p>进入 目录 /etc/apache2/sites-available， 修改000-default.conf文件</p>
<pre><code>#&lt;VirtualHost *:80&gt;
&lt;VirtualHost *:8001&gt;
        # The ServerName directive sets the request scheme, hostname and port that
        # the server uses to identify itself. This is used when creating
        # redirection URLs. In the context of virtual hosts, the ServerName
        # specifies what hostname must appear in the request's Host: header to
        # match this virtual host. For the default virtual host (this file) this
        # value is not decisive as it is used as a last resort host regardless.
        # However, you must set it for any further virtual host explicitly.
        #ServerName www.example.com

        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/html

        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
        # error, crit, alert, emerg.
        # It is also possible to configure the loglevel for particular
        # modules, e.g.
        #LogLevel info ssl:warn

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        # For most configuration files from conf-available/, which are
        # enabled or disabled at a global level, it is possible to
        # include a line for only one particular virtual host. For example the
        # following line enables the CGI configuration for this host only
        # after it has been globally disabled with &quot;a2disconf&quot;.
        #Include conf-available/serve-cgi-bin.conf
&lt;/VirtualHost&gt;

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
</code></pre>
<p>然后重启apache服务器</p>
<blockquote>
<p>sudo /etc/init.d/apache2 restart</p>
</blockquote>
<p>apache服务器的默认目录在/var/www/html，如果想利用http服务器下载文件，需要删除其index.html文件，然后把文件放在该目录即可.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务器端搭建ss]]></title>
        <id>https://fqzhanghao.github.io/post/fu-wu-qi-duan-da-jian-ss</id>
        <link href="https://fqzhanghao.github.io/post/fu-wu-qi-duan-da-jian-ss">
        </link>
        <updated>2019-05-23T06:43:53.000Z</updated>
        <summary type="html"><![CDATA[<p>新买的服务器安装ss</p>
]]></summary>
        <content type="html"><![CDATA[<p>新买的服务器安装ss</p>
<!-- more-->
<h2 id="安装ss">安装ss</h2>
<blockquote>
<p>sudo apt install python3-pip</p>
<p>pip3 install shadowsocks</p>
</blockquote>
<h2 id="启动">启动</h2>
<p>2.1直接启动</p>
<blockquote>
<p>ssserver -p 8388 -k password -m rc4-md5 -d start</p>
</blockquote>
<p>2.2配置文件启动</p>
<p>新建/etc/shadowsocks.json文件并写入</p>
<pre><code>{
    &quot;server&quot;:&quot;xxxxxx&quot;,
    &quot;server_port&quot;:xxxx,
    &quot;local_address&quot;:&quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;xxxxx&quot;,
    &quot;timeout&quot;:300,
    &quot;method&quot;:&quot;rc4-md5&quot;
}
</code></pre>
<p>使用命令启动</p>
<blockquote>
<p>ssserver -c /etc/shadowsocks.json -d start</p>
</blockquote>
<h2 id="开机自启动">开机自启动</h2>
<p>新建 /etc/ss.conf并写入：</p>
<pre><code>[program:shadowsocks]
command=ssserver -c /etc/shadowsocks.json
autostart=true
autorestart=true
user=root
log_stderr=true
logfile=/var/log/shadowsocks.log
</code></pre>
<p>打开/etc/rc.local并添加一行：</p>
<blockquote>
<p>service ss start</p>
</blockquote>
<h2 id="备注">备注</h2>
<p>启动ss出现undefined symbol: EVP_CIPHER_CTX_cleanup错误。</p>
<p>修改方法：</p>
<ol>
<li>用vim打开文件：vim /PYTHON_PATH/dist-packages/shadowsocks/crypto/openssl.py (该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)</li>
<li>跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup）</li>
<li>进入编辑模式</li>
<li>将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)<br>
改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)</li>
<li>再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)<br>
改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)</li>
<li>保存并退出</li>
<li>启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录</li>
<li>问题解决</li>
</ol>
]]></content>
    </entry>
</feed>