<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="记录日常生活">
<meta name="theme-color" content="#000">
<title>云台山速通攻略 | 浩浩的博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1604658508692">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="云台山速通攻略" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>浩浩的博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">记录日常生活</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name"></p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">80</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E5%A4%A9">第一天</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E5%A4%A9">第二天</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://fqzhanghao.github.io/post/yun-tai-shan-su-tong-gong-lue/">
      云台山速通攻略
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-01-19 18:58:40">2020-01-19</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>1<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>233<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="第一天">第一天</h2>
<!--more-->
<ol>
<li>
<p>首先到达岸上服务区,购买门票</p>
</li>
<li>
<p>第一站:万寿寺</p>
<pre><code> 10:45--11:00车程
 游览时长:20分钟
</code></pre>
</li>
<li>
<p>第二站:茱萸峰 (子房湖换乘点换乘)</p>
<pre><code> 经过叠彩洞
 11:45--12:15车程
 药王洞--&gt;半山腰
 云台观--&gt;山顶
 12:20--14:45结束
</code></pre>
</li>
<li>
<p>第三站:子房湖</p>
<pre><code> 快艇票  20元
 14:45-15:35结束
</code></pre>
</li>
</ol>
<h2 id="第二天">第二天</h2>
<ol>
<li>
<p>第0站:小寨沟景区(潭瀑峡,泉瀑峡,猕猴谷)</p>
<pre><code> 6:30--6:40车程
</code></pre>
</li>
<li>
<p>第一站:泉瀑峡</p>
<pre><code> 电瓶车(车票自费)
 两个多小时游玩
</code></pre>
</li>
<li>
<p>第二站:潭瀑峡</p>
<pre><code> 渡仙潭--&gt;情人瀑、Y字瀑--&gt;翡翠潭、碧玉潭、龙凤潭
 洗砚池--&gt;清漪池--&gt;水帘洞--&gt;不老泉
 唐王试剑石--&gt;龙眼
 中午11:40结束
</code></pre>
</li>
<li>
<p>第三站:红石峡</p>
<pre><code> 不选择老人的路线
 黄龙瀑--&gt;试心石--&gt;水帘洞--&gt;天然壁画
 12:00--13:30结束
</code></pre>
</li>
</ol>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://fqzhanghao.github.io/post/yun-tai-shan-su-tong-gong-lue/" title="云台山速通攻略">https://fqzhanghao.github.io/post/yun-tai-shan-su-tong-gong-lue/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="莽山公园爬山攻略" href="https://fqzhanghao.github.io/post/mang-shan-gong-yuan-pa-shan-gong-lue/">莽山公园爬山攻略</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="莽山公园爬山攻略" href="https://fqzhanghao.github.io/post/mang-shan-gong-yuan-pa-shan-gong-lue/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="减少Task加快Gradle编译速度" href="https://fqzhanghao.github.io/post/jian-shao-task-jia-kuai-gradle-bian-yi-su-du/">减少Task加快Gradle编译速度</a>
        <a class="nav-mobile-next" title="减少Task加快Gradle编译速度" href="https://fqzhanghao.github.io/post/jian-shao-task-jia-kuai-gradle-bian-yi-su-du/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'aoba'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/zu-jian-hua-ji-cheng/"" data-c="
          &lt;p&gt;上半年的技术需求,是做白牌组件集成,就是将白牌独立出来的组件,集成到合作项目中.&lt;/p&gt;
&lt;p&gt;看起来很简单,就像我们使用okhttp,只要导入一句**compile &#39;com.squareup.okhttp3:okhttp:3.4.1&#39;**即可.&lt;/p&gt;
&lt;p&gt;但是事与愿违.过程充满了艰辛,下面记录一下这次集成中的总结.&lt;/p&gt;
&lt;h2 id=&#34;项目背景&#34;&gt;项目背景&lt;/h2&gt;
&lt;p&gt;首先明确一下项目的背景.&lt;/p&gt;
&lt;p&gt;在合作项目中,小说使用replugin形式集成,表现为一个插件apk.我们称之为壳app,这个app是一个壳,他的实际入口为壳app中依赖的读书aar.&lt;/p&gt;
&lt;p&gt;我们所要做的,就是在这个aar中集成白牌组件.即&lt;strong&gt;插件apk--&amp;gt;读书aar--&amp;gt;白牌组件.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下所有均围绕这个过程准备.在此之前我们需要做一个依赖统一管理,如果不做这个,那么各个版本依赖冲突起来,简直解决到怀疑人生.&lt;/p&gt;
&lt;h2 id=&#34;依赖统一&#34;&gt;依赖统一&lt;/h2&gt;
&lt;p&gt;在项目根目录新建config.gradle文件,配置如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;ext {
    android = [
            minSdkVersion    : 15,
            targetSdkVersion : 25,
            compileSdkVersion: 25,
            buildToolsVersion: &amp;quot;25.0.3&amp;quot;
    ]

    dependencies = [
            &amp;quot;support-v4&amp;quot;          : &#39;com.android.support:support-v4:25.3.1&#39;,
            &amp;quot;appcompat-v7&amp;quot;        : &#39;com.android.support:appcompat-v7:25.3.1&#39;,
            &amp;quot;okhttp3&amp;quot;             : &#39;com.squareup.okhttp3:okhttp:3.4.1&#39;,
            &amp;quot;xlog&amp;quot;                : &#39;com.xxxx.cooperate.xlog:xlog-common:1.0.0&#39;,
            &amp;quot;mmkv&amp;quot;                : &#39;com.tencent:mmkv:1.0.10&#39;,
            &amp;quot;android-gif-drawable&amp;quot;: &#39;pl.droidsonroids.gif:android-gif-drawable:1.2.6&#39;
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在项目根目录的build.gradle中引入,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply from: &amp;quot;config.gradle&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以在任意子moudle中使用了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt; compileSdkVersion       rootProject.ext.android.compileSdkVersion
 buildToolsVersion       rootProject.ext.android.buildToolsVersion
 
 compile rootProject.ext.dependencies[&amp;quot;appcompat-v7&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回到我们具体项目里面,白牌组件目前需要接入的有两个,一个是common模块,一个是core模块.这两个模块也有依赖关系,表现为common依赖core.core模块依赖三方模块.&lt;/p&gt;
&lt;p&gt;那么具体到项目表现为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SDK	    ---&amp;gt;commom,core,三方
common  ---&amp;gt;core,三方
core    ---&amp;gt;三方
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对上面复杂的依赖关系,总结了四种依赖集成方式.&lt;/p&gt;
&lt;h2 id=&#34;使用源码依赖&#34;&gt;使用源码依赖&lt;/h2&gt;
&lt;p&gt;对项目而言,我们集成三方依赖是为了使用它的代码,完成某些任务,那么最简单的集成方式,就是将源码拷贝过来,进行项目集成.&lt;/p&gt;
&lt;p&gt;我们可以做如下方式集成:&lt;/p&gt;
&lt;p&gt;1.将common和core模块下载到本地,并拷贝到三方壳项目中&lt;/p&gt;
&lt;p&gt;2.在setting.gradle中引入项目,&#39;:CooperateCommonModule&#39;,&#39;:CooperateCoreModule&#39;&lt;/p&gt;
&lt;p&gt;3.调整项目依赖.&lt;/p&gt;
&lt;p&gt;core中如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile fileTree(include: [&#39;*.so&#39;, &#39;*.jar&#39;], dir: &#39;libs&#39;)
    compile rootProject.ext.dependencies[&amp;quot;appcompat-v7&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;okhttp3&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;xlog&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;mmkv&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;android-gif-drawable&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;common中如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile  fileTree(dir: &#39;libs/main&#39;, include: [&#39;*.jar&#39;])
    compile  fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    compile  project( &#39;:CooperateCoreModule&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SDK中如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    FileTree tree = fileTree(dir: &#39;libs&#39;, includes: [&#39;*.so&#39;, &#39;*.jar&#39;])
    compile tree
    provided fileTree(include: [&#39;*.jar&#39;], dir: &#39;providedlib&#39;)
    compile  project( &#39;:CooperateCommonModule&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以正常使用白牌组件了.当然这中间还有很多冲突问题需要解决.我会写在最后的备注中.&lt;/p&gt;
&lt;h2 id=&#34;使用aar集成&#34;&gt;使用aar集成&lt;/h2&gt;
&lt;p&gt;有了上一步源码集成成功的前提,我们下一步改造为aar集成.aar集成有三种方式,我们使用第一种,单aar集成.&lt;/p&gt;
&lt;p&gt;因为我们的项目是层层依赖的,那我们先从最底层的core模块处理.&lt;/p&gt;
&lt;p&gt;对core模块进行assembleRelease命令,会在build/output文件夹获得一个aar文件.&lt;/p&gt;
&lt;p&gt;这种build方式打出的aar,只包含模块本身的代码,不包含三方依赖.&lt;/p&gt;
&lt;p&gt;打开&lt;a href=&#34;http://dev.inner.xxxx.local/nexus/&#34;&gt;内网maven&lt;/a&gt;,登陆后使用upload功能,上传此aar.然后配置如下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190527105140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接着我们就可以使用compile &#39;&#39;com.xxxx.cooperate.core:core-thirdpart:1.0.2&amp;quot;使用此aar了.&lt;/p&gt;
&lt;p&gt;我们提一个知识点,就是maven仓库中的某aar的pom.xml文件.这个文件记录了aar的描述,声明,依赖等.&lt;/p&gt;
&lt;p&gt;观察这个aar的pom.xml文件,可以看到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;comxxxx.cooperate.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;core-thirdpart&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.2&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;aar&amp;lt;/packaging&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只有aar自身的描述,没有包含的三方依赖声明.这就和前面的&lt;strong&gt;只包含模块本身的代码,不包含三方依赖&lt;/strong&gt;一致.&lt;/p&gt;
&lt;p&gt;同理,打出common模块的aar,遵循上面的描述,我们需要配置下core模块的引用,及core模块的三方引用.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile  fileTree(dir: &#39;libs/main&#39;, include: [&#39;*.jar&#39;])
    compile  fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    compile &#39;com.xxxx.cooperate.core:core-thirdpart:1.0.2&#39;
    compile rootProject.ext.dependencies[&amp;quot;appcompat-v7&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;okhttp3&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;xlog&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;mmkv&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;android-gif-drawable&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传并得到使用方式compile &#39;com.xxxx.cooperate.common:common-thirdpart:1.0.2&#39;&lt;/p&gt;
&lt;p&gt;同理在SDK中使用common,core的远程依赖.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    FileTree tree = fileTree(dir: &#39;libs&#39;, includes: [&#39;*.so&#39;, &#39;*.jar&#39;])
    compile tree
    provided fileTree(include: [&#39;*.jar&#39;], dir: &#39;providedlib&#39;)
    compile &#39;com.xxxx.cooperate.common:common-thirdpart:1.0.2&#39;
    compile &#39;com.xxxx.cooperate.core:core-thirdpart:1.0.2&#39;
    compile rootProject.ext.dependencies[&amp;quot;appcompat-v7&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;okhttp3&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;xlog&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;mmkv&amp;quot;]
    compile rootProject.ext.dependencies[&amp;quot;android-gif-drawable&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以正常使用白牌组件了.&lt;/p&gt;
&lt;h2 id=&#34;使用fat-aar集成&#34;&gt;使用fat-aar集成&lt;/h2&gt;
&lt;p&gt;从上面的集成方式可以看到这么搞起来好像很复杂啊,有没有简单一点的方式呢.&lt;/p&gt;
&lt;p&gt;我们可以使用fat-aar技术,官网这么解释的.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gradle script that allows you to merge and embed dependencies in generated aar file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是一个gradle脚本,会把各个模块合并到一起,打成一个胖aar.这个aar里面包含了各个模块的所有东西,java文件,res文件等.&lt;/p&gt;
&lt;p&gt;实话讲,这种方式我研究了一阵子,因为涉及到脚本的修改以及各种版本库的冲突,我放弃了这种方案.此处提供一些资料,供有兴趣的同学研究一下.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/57024509b1d6&#34;&gt;fat-aar实践及原理分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/adwiv/android-fat-aar&#34;&gt;android-fat-aar github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这项技术对比下面的maven远程依赖技术有优点与缺点.&lt;/p&gt;
&lt;p&gt;优点:如果使用方无法访问我们的maven库,那可以把所有模块资源打成fat-aar,提供一个aar供依赖方使用.&lt;/p&gt;
&lt;p&gt;缺点:这个库已经不维护了,需要使用特定版本的gradle编译,并需要修改脚本,适应自己的项目.&lt;/p&gt;
&lt;h2 id=&#34;使用maven远程依赖集成&#34;&gt;使用maven远程依赖集成&lt;/h2&gt;
&lt;p&gt;探索到了现在我一直在思考一个问题,github上有很多组件供大家使用,他们是怎么完成这个依赖的问题呢?&lt;/p&gt;
&lt;p&gt;比如我们使用的okhttp,它依赖okio,但是我们使用的时候,只需要compile okhttp就行了.&lt;/p&gt;
&lt;p&gt;以前也在网上搜过相应的文章,但是只是简单的提到,需要把三方库变成maven远程依赖.对于我们项目,方式二已经变成了远程依赖,但是为什么做不到呢?&lt;/p&gt;
&lt;p&gt;其实,很简单,和库的pom.xml有关.我们方式二打包出来的pom.xml,是在网页生成的,并没有这个类的远程依赖描述.我们观察下别人家的库pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.tencent.news&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;xxxx-lib&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.7.20&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;aar&amp;lt;/packaging&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.android.support&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;appcompat-v7&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;25.2.0&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.tencent.news&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;xxxx&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.7.20&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.tencent.news&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;xxxx&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.7.20&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里面有一个节点dependencies描述了当前库的远程依赖.如何生成这个pom.xml文件就和我们的打包方式有关了.&lt;/p&gt;
&lt;p&gt;方式二中我们使用assembleRelease方式打包,这种方式打出来的包,只是简单的压缩了下代码.我们需要引入maven打包方式.&lt;/p&gt;
&lt;p&gt;1.在core模块下新建upload.gradle文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// 指定编码
tasks.withType(JavaCompile) {
    options.encoding = &amp;quot;UTF-8&amp;quot;
}

apply plugin: &#39;maven&#39;

// 对应的仓库地址
def URL_PUCBLIC = &amp;quot;http://dev.inner.xxxx.local/nexus/repository/maven-releases/&amp;quot;
def USERNAME = &amp;quot;xxxx&amp;quot;
def PASSWORD = &amp;quot;xxxx&amp;quot;
def GROUP_ID = &amp;quot;com.xxxx.cooperate.core&amp;quot;
def ARTIFACT_ID = &amp;quot;core-thirdpart&amp;quot;
def VERSION = &amp;quot;1.0.5&amp;quot;
// 上传到公共仓库
task uploadToPublic(type: Upload) {
    group = &#39;upload&#39;
    configuration = configurations.archives
    uploadDescriptor = true
    repositories{
        mavenDeployer {
            repository(url: URL_PUCBLIC) {
                authentication(userName: USERNAME, password: PASSWORD)
            }
            pom.version = VERSION
            pom.artifactId = ARTIFACT_ID
            pom.groupId = GROUP_ID
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.在core的build.gradle中引入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// 引用上传脚本
apply from: &amp;quot;./upload.gradle&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.刷新项目,就可以再gradle的任务中看到uploadToPublic,双击执行这个task.就可以在maven库中看到当前aar已上传.我们观察下它的pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.xxxx.cooperate.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;core-thirdpart&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.5&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;aar&amp;lt;/packaging&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.android.support&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;appcompat-v7&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;25.3.1&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.4.1&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.xxxx.cooperate.xlog&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;xlog-common&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.tencent&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mmkv&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.10&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;pl.droidsonroids.gif&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;android-gif-drawable&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.6&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到我们已经做到了当前aar的三方远程依赖.&lt;/p&gt;
&lt;p&gt;4.在common中也可以按照上述操作.&lt;/p&gt;
&lt;p&gt;整理完以后我们可以看下依赖如何:&lt;/p&gt;
&lt;p&gt;common中使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile  fileTree(dir: &#39;libs/main&#39;, include: [&#39;*.jar&#39;])
    compile  fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    compile &#39;com.xxxx.cooperate.core:core-thirdpart:1.0.5&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在SDK中使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    FileTree tree = fileTree(dir: &#39;libs&#39;, includes: [&#39;*.so&#39;, &#39;*.jar&#39;])
    compile tree
    provided fileTree(include: [&#39;*.jar&#39;], dir: &#39;providedlib&#39;)
    compile &#39;com.xxxx.cooperate.common:common-thirdpart:1.0.3&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完美!&lt;/p&gt;
&lt;p&gt;这才是我心目中的使用方式,其实我们也可以把sdk的aar做下类似的包装.不过就比较麻烦了,还有一堆provided的依赖需要处理,这个还是暴露给业务方处理比较合适.&lt;/p&gt;
&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;
&lt;p&gt;冲突问题如何解决.&lt;/p&gt;
&lt;p&gt;在解决aar打包问题前,我使用的是源码依赖.但是这种最简单的方式依旧冲突重重.&lt;/p&gt;
&lt;p&gt;首先提供学习资料&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/82de510b40b9&#34;&gt;Gradle 依赖&amp;amp;解决依赖冲突&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lastsweetop/column/info/18566/1&#34;&gt;Gradle学习&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/83ddb81e73f9&#34;&gt;Gradle3.0新指令api、provided、implementation等对比&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只要掌握了exclude,provided的奥义,就能排除问题.我们以wup.jar为例,看下jar类型冲突解决.&lt;/p&gt;
&lt;p&gt;子模块Reader,Jce均使用了wup.jar,如果都使用compile的话,会出现类冲突.所以我们可以在各自模块中,使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;provided fileTree(include: [&#39;*.jar&#39;], dir: &#39;providedlib&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只保证编译期通过,不降代码打入各模块&lt;/p&gt;
&lt;p&gt;然后在最顶层的app中,打入wup.jar&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就解决了类冲突.&lt;/p&gt;
&lt;p&gt;在集成当中,我发现,冲突最多的还是android自身的support包,各种版本号不一致,会导致各种各样的问题.我们尽量使用依赖的统一管理,来统一各模块的库版本号,尽可能的减少冲突发生.&lt;/p&gt;
">组件化集成</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/an-zhuo-zhui-zong-fang-fa-diao-yong-dui-zhan/"" data-c="
          &lt;p&gt;接到组长下发的书城隐私协议问题，记录了一下排查过程，以后可以模仿此步骤，进行隐私协议排查工作&lt;/p&gt;
&lt;p&gt;问题如下图所示：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200103141931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
很明显，我们在未被授权获取用户设备信息的情况下，频繁的请求了用户的设备信息。这是不允许的。&lt;br&gt;
查找资料，如下代码，可以获取用户信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
imei = telephonyManager.getDeviceId();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那我们可以按照如下逻辑，进行排查工作。&lt;br&gt;
1.分析我们代码里面的获取逻辑，做权限检查+imei缓存处理&lt;br&gt;
2.分析三方SDK里面的获取情况&lt;/p&gt;
&lt;p&gt;那么问题来了，检查1，自己的代码我们可以进行检索，排查。三方的SDK我们如何知晓调用情况呢，断点打到系统上？其实方案很简单，就是Hook。&lt;br&gt;
一方面我们可以使用java的动态代理，Hook本应用获取的系统服务，另一方面我们可以使用Xposed,注入系统进程，Hook所有的系统服务。&lt;br&gt;
市面上经常有模拟器刷量，他们Hook系统api，返回虚假的IMEI，我们可以如法炮制。条条道路通罗马，我们选择最简单的那条路（Xposed Hook）。&lt;/p&gt;
&lt;p&gt;准备工具如下：&lt;br&gt;
1.&lt;a href=&#34;https://www.ldmnq.com/&#34;&gt;雷电模拟器&lt;/a&gt;&lt;br&gt;
2.&lt;a href=&#34;https://bintray.com/rovo89/de.robv.android.xposed/api/82&#34;&gt;Xposed jar&lt;/a&gt;&lt;br&gt;
3.&lt;a href=&#34;http://deelmind.cn/2018/06/09/%E6%9C%80%E6%96%B0Android-Studio%E6%90%AD%E5%BB%BAXposed-Hook%E7%8E%AF%E5%A2%83/&#34;&gt;Xposed开发环境部署&lt;/a&gt;&lt;br&gt;
4.&lt;a href=&#34;https://github.com/shuihuadx/XposedHook&#34;&gt;免重启Xposed模块改进&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先安装雷电模拟器，自带Root权限。启动后，安装Xposed installer（需梯子）。&lt;br&gt;
然后按照工具3，部署Xposed开发环境。我已在文章末尾附上git地址，大家clone下开箱可用。&lt;/p&gt;
&lt;p&gt;回到我们的主题，我们需要Hook系统的&lt;strong&gt;getSystemService&lt;/strong&gt;，咨询了技术部的大佬@杨滨(yangbin)，写出了如下的代码。&lt;/p&gt;
&lt;p&gt;首先，我们Hook &lt;strong&gt;loadClass&lt;/strong&gt;.看看是否加载了 &lt;strong&gt;android.content.ContextWrapper&lt;/strong&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;XposedHelpers.findAndHookMethod(ClassLoader.class, &amp;quot;loadClass&amp;quot;, String.class, new XC_MethodHook() {
                // 在类方法loadClass执行之后执行的代码
                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                 // 参数的检查
                    if (param.hasThrowable()) {
                        return;
                    }
                    // 获取指定名称的类加载之后的Class&amp;lt;?&amp;gt;
                    Class&amp;lt;?&amp;gt; clazz = (Class&amp;lt;?&amp;gt;) param.getResult();
                    // 获取加载的指定类的名称
                    String strClazz = clazz.getName();
                    if (strClazz.startsWith(&amp;quot;android.content.ContextWrapper&amp;quot;)) {
                        XposedBridge.log(&amp;quot;--------------------LoadClass-------------------------- : &amp;quot; + strClazz);
                        .......
                     }
                }
          }
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们Hook &lt;strong&gt;getSystemService&lt;/strong&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (int i = 0; i &amp;lt; m.length; i++) {
    XposedBridge.log(&amp;quot;--------------HOOKED CLASS-METHOD-------------------: &amp;quot; + strClazz + &amp;quot;-&amp;quot; + m[i].toString());
    if (m[i].toString().indexOf(&amp;quot;getSystemService&amp;quot;) == -1) {
        continue;
    }
    if (!Modifier.isAbstract(m[i].getModifiers())           // 过滤掉指定名称类中声明的抽象方法
            // &amp;amp;&amp;amp; !Modifier.isNative(m[i].getModifiers())     // 过滤掉指定名称类中声明的Native方法
            &amp;amp;&amp;amp; !Modifier.isInterface(m[i].getModifiers())  // 过滤掉指定名称类中声明的接口方法
    ) {
            // 对指定名称类中声明的非抽象方法进行java Hook处理
            XposedBridge.hookMethod(m[i], new XC_MethodHook() {

                // 被java Hook的类方法执行完毕之后，打印log日志
                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                   .....
                }
             }
        }
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后我们Hook 获取&lt;strong&gt;Context.TELEPHONY_SERVICE&lt;/strong&gt;服务的调用，打印出调用栈。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 打印被java Hook的类方法的名称和参数类型等信息
if ((param.args != null) &amp;amp;&amp;amp; (param.args.length &amp;gt; 0)) {
    for (int i = 0; i &amp;lt; param.args.length; i++) {
        if (param.args[i] != null) {
            String c = param.args[i].toString();
            if (c.indexOf(&amp;quot;phone&amp;quot;) != -1) {
                Thread.sleep(100);
                new Exception(&amp;quot;-------phone---printStackTrace&amp;quot;).printStackTrace();
            }
            XposedBridge.log(&amp;quot;---------------xxxxxx-----HOOKED METHOD: -------param-------------&amp;quot; + &amp;quot;-&amp;quot; + &amp;quot;-&amp;quot; + param.method + &amp;quot;-&amp;quot; + i + &amp;quot;:&amp;quot; + param.args[i]);
        }
    }

}

// 打印被java Hook的类方法的名称和参数类型等信息
if (param.getResult() != null) {
    try {
        XposedBridge.log(&amp;quot;--------------------HOOKED METHOD: --------------result------&amp;quot; + param.getClass().getName() + &amp;quot;-&amp;quot; + param.method.toString() + &amp;quot;:&amp;quot; + param.getResult().toString());
    } catch (Throwable e) {

    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，我们就可以在所有第三方SDK，调用系统phone服务的时候，打印出当前的调用栈。&lt;/p&gt;
&lt;p&gt;安装好Xposed模块并勾选，因为是免重启模块，杀死宿主和模块，点开我们的书城即可查看。&lt;/p&gt;
&lt;p&gt;在日志中我们可以查看到，广点通服务在频繁的调用，&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200103160807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
QM统计在频繁调用&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200103160702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;哈哈，是不是原形毕露呢，这样我们不仅可以找到是谁在调用IMEI，还可以有证据证明他们在调用，可以愉快的把图发给他们(三方SDK)，让他们整改了。&lt;/p&gt;
&lt;p&gt;一通操作，可以发现，有很多处地方在频繁获取系统服务，比如phone，网络等。可以针对这种问题，给SDK提出整改意见，进行cache处理，优化执行效率。&lt;/p&gt;
&lt;p&gt;举一反三，我们可以Hook系统的函数，修改系统参数,Hook三方App，修改程序逻辑。仅限学习研究！&lt;/p&gt;
&lt;p&gt;备注：&lt;br&gt;
Xposed学习链接&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/claireyuancy/p/6962664.html&#34;&gt;Xposed编写&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/gordon0918/p/6732100.html&#34;&gt;Xposed编写&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/u011956004/article/details/78612502&#34;&gt;免重启Xposed原理解析&lt;/a&gt;&lt;br&gt;
java动态代理学习链接&lt;br&gt;
&lt;a href=&#34;http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/&#34;&gt;维术大佬系列文章&lt;/a&gt;&lt;br&gt;
开箱即用的Xposed开发环境&lt;br&gt;
http://gitlab.inner.yuewen.local/zhanghao.c/XposedHook.git&lt;/p&gt;
">安卓追踪方法调用堆栈</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/an-zhuo-qia-dun-pai-cha-bu-zou/"" data-c="
          &lt;p&gt;接到组长下发的书城卡顿排查任务，学习了两个工具，记录一下排查过程，以后可以模仿此步骤，进行页面卡顿检测&lt;/p&gt;
&lt;p&gt;下面两个工具地址，都在DDMS中，位置如下：your\way\to\androidsdk\tools\monitor.bat,双击即可打开&lt;/p&gt;
&lt;h2 id=&#34;一-systrace&#34;&gt;一、Systrace&lt;/h2&gt;
&lt;p&gt;Systrace 允许您在系统级别收集和检查设备上运行的所有进程的计时信息。 它将来自Android内核的数据（例如CPU调度程序，磁盘活动和应用程序线程）组合起来，以生成HTML报告。&lt;/p&gt;
&lt;h3 id=&#34;抓取systrace的方法&#34;&gt;抓取Systrace的方法&lt;/h3&gt;
&lt;p&gt;1.连接手机，勾选需要分析的进程，点击右侧箭头处的图标&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;2.弹框中，勾选需要分析的参数，点击OK，操作app中感觉卡顿的部分，5秒钟后，可以在弹框中配置的地方，找到生成的trace.html&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;还有一种使用命令行的方式进行抓取，大家可能会碰到某些问题，我这边已经踩过坑了，按照链接步骤操作即可&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/e73768e66b8d&#34;&gt;命令行方式抓取Systrace&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;分析systrace的方法&#34;&gt;分析Systrace的方法&lt;/h3&gt;
&lt;p&gt;使用Chrome打开trace.html文件，有几处需要关注，1.Alerts，2.Frames&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
控制键如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;g键，可开启60fps的红色参考线。&lt;br&gt;
w键，放大&lt;br&gt;
s键，缩小&lt;br&gt;
a键，左移&lt;br&gt;
d键，右移&lt;br&gt;
f键，放大选中的帧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Frames中可以看到一个个F，代表了每一帧。绿色代表了16ms中绘制了一帧，黄色和红色代表了超过16ms，发生了丢帧。&lt;/p&gt;
&lt;p&gt;我们可以先看Alert框中的内容，这里面是系统给我们分析出所有超时帧的问题&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看出，7帧发生了测量布局超时，17帧发生了延时，10帧发生了saveLayer超时，3帧draw超时，72帧设置了Alpha&lt;/p&gt;
&lt;p&gt;一般我们会分析红色的帧。我们选一个比较有特点的帧看一下，依次按下m键，f键。屏幕上可以看到下图&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204648.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最上面可以看到这一帧耗时39.789ms,差不多3帧的时间，下方Alert提示，这一帧中发生了4次saveLayer操作。这个可能是发生在CoverImageView的draw方法中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        canvas.getClipBounds(bounds);
        boundsf.set(bounds);
        super.onDraw(canvas);
        canvas.saveLayer(boundsf, maskXferPaint, Canvas.ALL_SAVE_FLAG);
        canvas.drawARGB(0, 0, 0, 0);
        canvas.drawRoundRect(boundsf, radius, radius, canvasPaint);
        canvas.restore();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;谷歌大会时开发人员讲到，Flutter中不建议用clipPath,saveLayer的，他们优化掉了这个操作。我们换成了Glide,可以研究一下，去掉CoverImageView这个耗时的类&lt;/p&gt;
&lt;p&gt;还有一个被我优化掉的点是，双排10书封。发现DrawFrame时间超长。猜测可能是加载图片导致。修改为，滑动列表时，暂停图片加载，列表暂停时，加载图片。解决了问题。&lt;/p&gt;
&lt;p&gt;从这个烽火图上还可以看出很多问题建议。&lt;br&gt;
比如：在动画过程中避免进行layout操作&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;比如：因耗时操作导致的丢帧，这个可以结合第二部分的TraceView一起看&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，在这一帧中，上方的cpu模块，有很多beacon线程在做操作，推测可能是在进行曝光上报。尤其是多书封的上报，代码中整了个for循环，一本发一次。可以考虑优化成一次上报，不过这个需要数据和后台同学的共同努力。暂时只能这样了。&lt;br&gt;
从烽火图中可以看到很多问题，需要逐帧的进行查看，具体问题具体分析。&lt;/p&gt;
&lt;h2 id=&#34;二-traceview&#34;&gt;二、TraceView&lt;/h2&gt;
&lt;p&gt;TraceView 是 Android SDK 中内置的一个工具，它可以加载 trace 文件，用图形的形式展示代码的执行时间、次数及调用栈，便于我们分析。&lt;/p&gt;
&lt;p&gt;附上参考文章&lt;br&gt;
&lt;a href=&#34;https://cloud.tencent.com/developer/article/1014620&#34;&gt;TraceView是啥&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;抓取trace的方法&#34;&gt;抓取Trace的方法&lt;/h3&gt;
&lt;p&gt;有多种抓Trace的方法，当然是介绍最简单的方式。&lt;/p&gt;
&lt;p&gt;1.连接手机，勾选需要分析的进程，点击左侧箭头处的图标开始抓&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;2.操作app中感觉卡顿的部分，然后再次点击图标，暂停抓取。几秒后会展示出trace的图形化界面&lt;/p&gt;
&lt;h3 id=&#34;分析trace的方法&#34;&gt;分析Trace的方法&lt;/h3&gt;
&lt;p&gt;先用网上的一个图介绍下参数都是什么意思&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用TraceView查看耗时，主要关注Calls+Recur Calls/Total和Cpu Time/Call这两个值，关注调用次数多和耗时久的方法&lt;/p&gt;
&lt;p&gt;程序优化两点要素：&lt;br&gt;
一是调用次数不多，但每次调用却需要花费很长时间的函数。这个可以从Cpu Time / Call反映出来。&lt;br&gt;
一个是那些自身占用时间不长，但调用却非常频繁的函数。这个可以从Calls + Recur Calls / Total反映出来。&lt;/p&gt;
&lt;p&gt;浩哥还介绍了一个适应我们自己程序的点，就是直接搜索attachView，分析我们card列表中的耗时操作有哪些。放个图看看&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119205020.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;从图上可以看出，attachView方法被调用23次，总时长230ms，每个方法稳定在10ms左右。log.d调用次数最多，其次是单书封BaseXLCover，单书封card,点击条目可以查看具体的内容&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119205028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，我们整体的性能还是比较好的，大家都很棒。如果有性能问题的话，可以参考下面的链接，学习寻找的方法&lt;a href=&#34;https://www.jianshu.com/p/388c693c1b58&#34;&gt;Trace图怎么看&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;
&lt;p&gt;还有很多没有写的性能学习资料，大家有时间可以去官网看看&lt;a href=&#34;https://developer.android.com/topic/performance/tracing/&#34;&gt;谷歌官网Trace&lt;/a&gt;,学习一下AS中的Profile,以及SysTrace的替代品Perfetto&lt;/p&gt;
">安卓卡顿排查步骤</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/yue-du-ye-mvp-ji-zhu-xu-qiu/"" data-c="
          &lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;阅读页功能多，代码逻辑复杂，使用mvp改造解耦，利于后期维护&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务拆分&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除冗余代码，封装方法，可读性优化&lt;/li&gt;
&lt;li&gt;将阅读页UI与业务逻辑分层，进行解耦&lt;/li&gt;
&lt;li&gt;结合RxJava，优化消息分发逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二-业务时序图流程图&#34;&gt;二、业务时序图/流程图&lt;/h1&gt;
&lt;p&gt;阅读页核心业务流程图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205102254.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;阅读页核心业务时序图&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205102355.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-mvp一期类结构设计&#34;&gt;三、MVP一期类结构设计&lt;/h1&gt;
&lt;p&gt;ReaderPagePresenter类结构：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205114733.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;四-mvp一期操作步骤与注意点&#34;&gt;四、MVP一期操作步骤与注意点&lt;/h1&gt;
&lt;h2 id=&#34;1操作步骤&#34;&gt;1.操作步骤&lt;/h2&gt;
&lt;p&gt;遵循V-&amp;gt;P-&amp;gt;M的顺序逐步剥离代码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改View层继承的接口，改为内部实现，方便转移到P层&lt;/li&gt;
&lt;li&gt;剥离打开书籍业务到P层&lt;/li&gt;
&lt;li&gt;剥离各类handler消息到P层&lt;/li&gt;
&lt;li&gt;剥离各类控制业务到P层&lt;/li&gt;
&lt;li&gt;剥离P层的数据请求到M层&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2注意点&#34;&gt;2.注意点&lt;/h2&gt;
&lt;h3 id=&#34;1-广播多放在v层还是放在p层&#34;&gt;1. 广播多，放在V层还是放在P层？&lt;/h3&gt;
&lt;p&gt;有多个业务使用广播，方法很长，查看都是业务相关，故放在P层&lt;/p&gt;
&lt;h3 id=&#34;2-handler怎么处理&#34;&gt;2. Handler怎么处理？&lt;/h3&gt;
&lt;p&gt;查看剥离后的P层代码，很多成员变量都会牵扯到Handler，这个怎么处理呢？&lt;/p&gt;
&lt;p&gt;网上大部分的代码均使用回调的方式处理数据。即V-P-M-P-V&lt;/p&gt;
&lt;p&gt;而我们的代码，拿到Handler以后，发送msg到V层处理，即V-P-M-V.&lt;/p&gt;
&lt;p&gt;我们的Handler较多，处理起来难度较大，仿照书架P的处理方式，在P层获取到V的handler。&lt;/p&gt;
&lt;h3 id=&#34;3-空安全内存泄漏&#34;&gt;3. 空安全，内存泄漏？&lt;/h3&gt;
&lt;p&gt;MVP并非无缺点，空安全和内存泄漏需要注意。及时销毁PM,断开引用&lt;/p&gt;
&lt;h1 id=&#34;五-mvp二期类结构设计&#34;&gt;五、MVP二期类结构设计&lt;/h1&gt;
&lt;p&gt;ReaderPagePresenter类结构：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205113159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;六-mvp二期工作&#34;&gt;六、MVP二期工作&lt;/h1&gt;
&lt;p&gt;一期可以先将V中的逻辑转移到P层中，二期可以对大P层进行拆分&lt;/p&gt;
&lt;h3 id=&#34;1-拆分多个pm层&#34;&gt;1. 拆分多个PM层&lt;/h3&gt;
&lt;p&gt;借鉴网上开源项目思路，复杂的业务需求可拆分为多个PM,即一个V持有N个P,一个P持有多个M.进一步解耦庞大的P层代码。&lt;/p&gt;
&lt;p&gt;目前耦合有三类,解耦思路为单例设计模式&lt;/p&gt;
&lt;p&gt;1&amp;gt; 书籍信息类信息：即CurBook，autoBookmark。&lt;/p&gt;
&lt;p&gt;1.当前书籍类型类（文本书，精排书），CurBook,&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205105822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;此变量维护当前书籍类型，并转型为各类书籍调用各自的方法，做成单例类，减少单个变量传递，这样就可解耦到M层获取&lt;/p&gt;
&lt;p&gt;2.当前书籍类，autoBookmark&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205105804.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以前是一个字段autoBookmark来回修改传递，拆分多个M可以在用到这个mark的时候，用一个单例类解耦&lt;/p&gt;
&lt;p&gt;2&amp;gt; 服务器书籍信息类：即OnlineChapterHandle，LocalChapterHandle。这两个在MVP其实充当的是M&lt;/p&gt;
&lt;p&gt;1.OnlineChapterHandle负责在线书的书籍信息，章节解析等功能&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205105904.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个类是比较复杂的一个类，充当为M类。作用有4，获取书籍类型（下载时使用），获取书籍信息和章节信息（保存到OnlineBookOperator中的OnlineBook对象中，包含整本书的信息+章节信息），获取书籍购买类型（查询书籍信息是前置条件，从内部的ob对象中直接拿即可），检测章节一致性&lt;br&gt;
备注：获取书籍信息和章节信息前，还获取了批量购买协议内容，都保存到了OB对象中，此处可以使用rxjava的merge合并两次请求&lt;/p&gt;
&lt;p&gt;2.LocalChapterHandle负责精排试读书的书籍信息等&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205105835.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;内部维护了一个handler的注册表，初始化的时候注册到这个地方。查询完成后，通过handler把查询结果发送出去&lt;br&gt;
一共有两个方法，获取书籍类型（在下载时使用），获取书籍信息（查询精排限免期）&lt;/p&gt;
&lt;p&gt;3&amp;gt; 书籍下载类：即OnlineProvider，这个在MVP中也是M，负责下载章节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205112738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;此类维护了两个对象，书籍下载的章节，和正在预取的章节。作用有2，获取章节（下载章节），维护下载章节队列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;困难点&lt;/strong&gt;：上述三个类考虑到复用问题（新增类还是复用，复用的话handler+听书如何复用），仍有待商榷&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205114240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;4&amp;gt;非耦合类ReaderPageModel&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20191205112925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个类，用来负责阅读页其他网络请求，比如广告，付费等&lt;/p&gt;
&lt;h3 id=&#34;2-rxjava引入与handler&#34;&gt;2. rxjava引入与handler&lt;/h3&gt;
&lt;p&gt;目前数据的处理散布在N个类内，比如OnlineProvider，OnlineChapterHandle，LocalChapterHandle等，这类数据相关的类，可以考虑移动到M层。&lt;/p&gt;
&lt;p&gt;对V的所有操作，都是P层在控制，PM之间通过回调进行。可以逐步去掉handler的使用。&lt;/p&gt;
&lt;p&gt;rxjava的引入。rxjava流式处理较好用，可以无缝切换线程。在项目中的体现就是：子线程拿数据（M）--&amp;gt; 切换--&amp;gt; 主线程展示UI（V).我们可以把rxjava运用到P层，来处理P层中涉及到这个操作的逻辑。&lt;/p&gt;
&lt;h1 id=&#34;七-一期改造效果&#34;&gt;七、一期改造效果&lt;/h1&gt;
&lt;p&gt;仓库地址：http://xxxx/book_cooperate_client/cooperate-baseline.git （feature_xxxx_20181122_readerpage_mvp）&lt;/p&gt;
&lt;p&gt;删减ReaderPageActivity类 初始行数13102，抽取结束后4853，代码减少63%，包含View交互。&lt;/p&gt;
&lt;p&gt;新增ReaderPagePresenter类 行数6170，包含书籍加载+书籍控制+付费&lt;/p&gt;
&lt;p&gt;新增ReaderPageModel类  行数231，包含数据请求&lt;/p&gt;
&lt;h1 id=&#34;八-三期类结构设计&#34;&gt;八、三期类结构设计&lt;/h1&gt;
&lt;p&gt;二期设计因为单例设计模式，在多个阅读页同时存在的情况下，会有实例问题。比如当前在读书籍Mark， 打开新阅读页的时候，会把老阅读页的单例Mark更新，导致老阅读页的书籍信息被修改。&lt;br&gt;
所以对二期的设计进行了下修改，解决多阅读页问题。同时引入代理模式和观察者模式，解决多P协作，多P数据统一等问题。&lt;/p&gt;
&lt;p&gt;ReaderPagePresenter类结构如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200109181855.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以下：ReaderPageActivity简称V，ReadpagePresenterImpl简称代理P，CommonPresenter等简称业务P，ReaderPageModel等简称M&lt;/p&gt;
&lt;h2 id=&#34;代理模式&#34;&gt;代理模式&lt;/h2&gt;
&lt;p&gt;V持有代理P的引用，通过调用代理P的方法，完成P层逻辑。&lt;br&gt;
引入代理P，一共有两个作用：&lt;br&gt;
1.隐藏业务P的业务实现，可以进行后续业务扩展，不用更改V层代码&lt;br&gt;
2.解决多P协作问题，如遇到多P才能完成的业务，可以写在代理P中，不用在V中进行周转&lt;/p&gt;
&lt;h2 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h2&gt;
&lt;p&gt;代理P是被观察者，业务P是观察者。代理P中持有一个观察者队列，ArrayList&lt;ReadpageObserver&gt;，通过业务P的observe(ReadpageObservable observable)方法，注册到观察者队列中。&lt;br&gt;
当业务P中，某些需要同步的对象（如Mark）更新时，可以通知被观察者，更新观察者队列，做到了多P数据统一。&lt;/p&gt;
&lt;p&gt;备注：因为业务涉及到多阅读页形式，无法使用EventBus，RxBus之类类库添加全局观察者，所以就实现了一个有局限性的观察者模式。如果以后无此类多阅读页需求，可以修改为三方类库实现，业务逻辑更加清晰一些。&lt;/p&gt;
&lt;h2 id=&#34;疑问&#34;&gt;疑问&lt;/h2&gt;
&lt;p&gt;通过拆分成不同的Iview，和Ipresenter.可以合理的规划业务边界，编写业务代码。但是也会引入两个新的问题&lt;br&gt;
1.如果业务边界不清晰，怎么划分。即如何避免代理P增大的问题&lt;br&gt;
2.如果业务变动频繁，怎么快速完成，改动量最小。&lt;/p&gt;
">阅读页mvp技术需求</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/pip-wang-luo-chao-shi-jie-jue-ban-fa/"" data-c="
          &lt;p&gt;使用豆瓣源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip3 install -i https://pypi.doubanio.com/simple/ 包名
&lt;/code&gt;&lt;/pre&gt;
">pip网络超时解决办法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/cong-svn-dao-git-dai-ma-qian-yi/"" data-c="
          &lt;p&gt;准备工作:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SOURCE        = 源svn分支
TARGET        = 目的git分支
NAME          = 当前切换目录
USER_NAME     = 用户名
USER_EMAIL    = 用户邮箱
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;git-svn-clone&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git svn clone ${SOURCE} --no-metadata ${NAME}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处会让输入三个参数.1.当前密码(可以直接回车)2.svn用户名,3.svn密码.漫长的过程&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;push到git仓库&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd ${NAME}
git config user.name ${USER_NAME}
git config user.email ${USER_EMAIL}
git checkout -b ${NAME}
git remote add origin ${TARGET}
git push -u origin ${NAME}
&lt;/code&gt;&lt;/pre&gt;
">从SVN到Git代码迁移</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/yue-du-lei-app-jing-pin-fen-xi/"" data-c="
          &lt;h2 id=&#34;一-竞品分析对象选择&#34;&gt;一、竞品分析对象选择&lt;/h2&gt;
&lt;p&gt;经过调研，我选取了艾瑞互联网大数据服务平台，电子阅读分类，按月度活跃设备排名靠前的3款app。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
确定竞品为：掌阅，QQ阅读，书旗小说，再加上我们的OPPO书城，APP产品共4款。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;APP名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;掌阅iReader&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;书旗小说&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;QQ阅读&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OPPO书城&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;版本号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7.5.2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10.6.8.65&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6.6.1.888&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.0.4.303&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数据取自360手机市场，截止2018年5月10日，其中oppo书城取自rdm最新打包&lt;/p&gt;
&lt;h2 id=&#34;二-竞品分析&#34;&gt;二、竞品分析&lt;/h2&gt;
&lt;p&gt;竞品分析主要包含了以下四个方向&lt;br&gt;
&lt;strong&gt;基础调研，性能调研，流畅性调研，产品分析&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203707.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1基础调研&#34;&gt;1.基础调研&lt;/h3&gt;
&lt;p&gt;基础调研，主要调研安装包下载量和安装包大小。&lt;/p&gt;
&lt;h4 id=&#34;1-下载量&#34;&gt;1） 下载量&lt;/h4&gt;
&lt;p&gt;查阅了两个知名的app分发中心，360手机市场和腾讯应用宝。&lt;/p&gt;
&lt;p&gt;其中掌阅app划分为两个：掌阅和爱掌阅读，这个和公司发展战略有关，我们暂时只分析掌阅。&lt;/p&gt;
&lt;p&gt;360市场的下载量如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;APP名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;掌阅iReader&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;书旗小说&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;QQ阅读&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OPPO书城&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;下载量（亿）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.74&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.34&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.46&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出掌阅的下载量较书旗小说和qq阅读多，这也和开头的艾瑞数据吻合。&lt;/p&gt;
&lt;p&gt;应用宝的下载量如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;APP名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;掌阅iReader&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;书旗小说&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;QQ阅读&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OPPO书城&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;下载量（亿）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出，QQ阅读的下载量与掌阅和书旗加起来相当。&lt;/p&gt;
&lt;h4 id=&#34;2-安装包大小&#34;&gt;2） 安装包大小&lt;/h4&gt;
&lt;p&gt;安装包大小如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;APP名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;掌阅iReader&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;书旗小说&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;QQ阅读&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OPPO书城&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;安装包大小&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15.99M&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25.82M&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;22.78M&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;17.63M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;安装包大小是我们技术同学比较关心的一个点，安装包的大小，一方面关系到用户流量问题，越大，用户下载耗费的流量越多。另一方面，因为白牌项目要预装到手机里面出厂，厂商很可能对安装包大小做要求，所以我们要尽量精简安装包的大小。&lt;/p&gt;
&lt;p&gt;下面我们分析下，这几个项目的安装包中包含了些什么，可以从哪些方面进行优化。Android Studio3.x支持分析安装包的资源，直接将安装包拖入AS中，进行观察。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌阅&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203718.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;项目中排行较大的文件夹为assets目录，其中包含字体文件和各种插件apk.&lt;/p&gt;
&lt;p&gt;缺点：字体方案方正黝黑1.2M，占很大一部分空间，可能和产品设计有关，默认为此字体，从安装包大小看来，不是一个很好的选择，应该尽量选取较小体积的字体，后期可通过产品内提示用户下载。&lt;/p&gt;
&lt;p&gt;优点：图片资源控制较好。查阅图片资源目录，基本上未见100K以上图片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书旗&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;项目中排行较大的文件夹为assets目录,lib目录&lt;/p&gt;
&lt;p&gt;查阅了这两个目录，对里面包含的内容十分吃惊。assets目录大小8.8M，包含epub文件，字体文件，图片文件，感觉直接把书放到包里面有点问题，不知道他们产品怎么设计的。字体文件方正兰亭黑3.7M，比掌阅的还大。图片文件含有100K以上的。从中还可以看出使用了淘宝的Atlas技术，还是比较先进的。lib目录大小6.3M，这两个文件夹8.8+6.3=15.1M，都快相当于一个掌阅项目了。可以看出书旗app有很大的优化空间。但是为什么要这么做，可能与产品策略有关，我们不得而知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;qq阅读&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;项目中排行较大的文件夹为res目录，assets目录。&lt;/p&gt;
&lt;p&gt;res目录中有多张100K左右的图片，assets目录中有一个3.1M的压缩包，搜索到可能与腾讯支付相关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;oppo书城&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;项目中排行较大的文件夹为res目录，assets目录。&lt;br&gt;
res目录中大于100K的图片较多，个别文件接近220K,这其中存在很大的优化空间。assets目录中包含一个apk文件，较大。还有和qq阅读中同名的zip文件.比qq阅读的小上不少，911k。不知道这两者的差距。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从分析结果来看，要控制包体大小，有以下几个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目中图片资源应该严格控制，可使用腾讯智图工具或TinyPNG进行图片压缩，对50K以上的图片进行统一处理；&lt;/li&gt;
&lt;li&gt;可以进行lint检测，清除未使用的资源文件；&lt;/li&gt;
&lt;li&gt;使用较小体积的默认字体，如果有切换字体的需求，建议使用远端下载的方式；&lt;/li&gt;
&lt;li&gt;可以精简一些不常用的插件功能，类似字体进行远程下载使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2性能调研&#34;&gt;2.性能调研&lt;/h3&gt;
&lt;p&gt;性能分析从五个方面进行分析：启动时间，cpu，内存，流量，电量。&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203759.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-启动时间&#34;&gt;1） 启动时间&lt;/h4&gt;
&lt;p&gt;毫无疑问，启动时间越短越好，用户点下桌面上的app图标，就开始走启动流程。这其中流程十分复杂，我们暂时不理会这其中的过程，可以留作以后研究。一般来讲，启动分为三种启动：冷启动，热启动，暖启动。&lt;/p&gt;
&lt;p&gt;冷启动为应用在开机后或者被系统停止后的第一次启动过程。&lt;br&gt;
热启动为用户退出应用，但随后重新启动它。应用的进程还在运行，但应用必须重新从 onCreate() 开始创建 Activity。&lt;br&gt;
具体可以参考这篇博文（&lt;a href=&#34;https://blog.csdn.net/lgz_ei/article/details/70041663&#34;&gt;Android 性能优化——启动时间优化指南&lt;/a&gt;），讲解的非常好。&lt;/p&gt;
&lt;p&gt;此次进行竞品分析，我们分析冷启动和热启动。&lt;/p&gt;
&lt;p&gt;使用此命令进行分析,查看 App 启动耗时:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell am start -W packagename/activity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过反编译，查阅到以下信息：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;app名称&lt;/th&gt;
&lt;th&gt;查看方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;掌阅&lt;/td&gt;
&lt;td&gt;adb shell am start -W com.chaozh.iReaderFree/com.chaozh.iReader.ui.activity.WelcomeActivity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书旗&lt;/td&gt;
&lt;td&gt;adb shell am start -W com.shuqi.controller/com.shuqi.activity.SplashActivity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QQ阅读&lt;/td&gt;
&lt;td&gt;adb shell am start -W com.qq.reader/com.qq.reader.activity.SplashActivity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPPO书城&lt;/td&gt;
&lt;td&gt;adb shell am start -W com.oppo.book/com.qq.reader.activity.SplashActivity&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用上述代码，进行测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冷启动&lt;/strong&gt;，测试方式为，清空程序后台，点击app，记录数据。取五次测试结果的平均值，测试数据如下(测试单位：ms):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;App名称&lt;/th&gt;
&lt;th&gt;数据1&lt;/th&gt;
&lt;th&gt;数据2&lt;/th&gt;
&lt;th&gt;数据3&lt;/th&gt;
&lt;th&gt;数据4&lt;/th&gt;
&lt;th&gt;数据5&lt;/th&gt;
&lt;th&gt;均值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;掌阅&lt;/td&gt;
&lt;td&gt;621&lt;/td&gt;
&lt;td&gt;638&lt;/td&gt;
&lt;td&gt;649&lt;/td&gt;
&lt;td&gt;684&lt;/td&gt;
&lt;td&gt;641&lt;/td&gt;
&lt;td&gt;647&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书旗&lt;/td&gt;
&lt;td&gt;628&lt;/td&gt;
&lt;td&gt;622&lt;/td&gt;
&lt;td&gt;598&lt;/td&gt;
&lt;td&gt;603&lt;/td&gt;
&lt;td&gt;629&lt;/td&gt;
&lt;td&gt;616&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QQ阅读&lt;/td&gt;
&lt;td&gt;665&lt;/td&gt;
&lt;td&gt;609&lt;/td&gt;
&lt;td&gt;674&lt;/td&gt;
&lt;td&gt;680&lt;/td&gt;
&lt;td&gt;675&lt;/td&gt;
&lt;td&gt;661&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPPO书城&lt;/td&gt;
&lt;td&gt;582&lt;/td&gt;
&lt;td&gt;560&lt;/td&gt;
&lt;td&gt;580&lt;/td&gt;
&lt;td&gt;543&lt;/td&gt;
&lt;td&gt;556&lt;/td&gt;
&lt;td&gt;564&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出oppo书城以微弱的优势领先，剩余三款app，启动时间不相伯仲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;热启动&lt;/strong&gt;，测试方式为，打开app并退出，不清理后台，点击app，记录数据。取五次测试结果的平均值，测试数据如下(测试单位：ms):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;App名称&lt;/th&gt;
&lt;th&gt;数据1&lt;/th&gt;
&lt;th&gt;数据2&lt;/th&gt;
&lt;th&gt;数据3&lt;/th&gt;
&lt;th&gt;数据4&lt;/th&gt;
&lt;th&gt;数据5&lt;/th&gt;
&lt;th&gt;均值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;掌阅&lt;/td&gt;
&lt;td&gt;607&lt;/td&gt;
&lt;td&gt;582&lt;/td&gt;
&lt;td&gt;576&lt;/td&gt;
&lt;td&gt;590&lt;/td&gt;
&lt;td&gt;570&lt;/td&gt;
&lt;td&gt;585&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书旗&lt;/td&gt;
&lt;td&gt;175&lt;/td&gt;
&lt;td&gt;181&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;td&gt;174&lt;/td&gt;
&lt;td&gt;175&lt;/td&gt;
&lt;td&gt;179&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QQ阅读&lt;/td&gt;
&lt;td&gt;188&lt;/td&gt;
&lt;td&gt;201&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;td&gt;188&lt;/td&gt;
&lt;td&gt;172&lt;/td&gt;
&lt;td&gt;188&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPPO书城&lt;/td&gt;
&lt;td&gt;184&lt;/td&gt;
&lt;td&gt;179&lt;/td&gt;
&lt;td&gt;181&lt;/td&gt;
&lt;td&gt;179&lt;/td&gt;
&lt;td&gt;184&lt;/td&gt;
&lt;td&gt;181&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出，掌阅的数据比较异常，测试机为oppo手机，每次启动均以冷启动的方式进行启动。猜测，可能掌阅的退出为杀掉应用进程的方式，非destory方式。剩余三款app启动时间差距不大，基本一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：一般成熟的app，都会用一个splash页做启动页，在启动的时候减小黑屏或白屏时间，尽量少的做初始化操作，未使用到的模块或功能进行延迟初始化或延迟加载，尽量减少启动时间。&lt;/p&gt;
&lt;h4 id=&#34;2-cpu&#34;&gt;2) cpu&lt;/h4&gt;
&lt;p&gt;查看app的cpu使用率，需要使用top命令。首先输入&lt;strong&gt;adb shell&lt;/strong&gt;,进入linux的命令行模式。然后输入&lt;strong&gt;top -n 1 -d 5&lt;/strong&gt;, 查看手机当前各进程cpu使用情况。 &lt;strong&gt;-n&lt;/strong&gt; 代表刷新次数，&lt;strong&gt;-d&lt;/strong&gt; 代表刷新间隔，我们在5秒后刷新一次，取出瞬时cpu占用。得出的结果为所有进程，我们只关心当前测试app的cpu情况，所以可以使用管道命令，查询出我们所需的内容，即&lt;strong&gt;top -n 1 -d 5 | grep packagename&lt;/strong&gt;，所得结果类似 &lt;strong&gt;18751  7   3% S    61 1754024K 136604K  fg u0_a158  com.chaozh.iReaderFree&lt;/strong&gt;，其中18751为进程pid,3%即为cpu占用。&lt;/p&gt;
&lt;p&gt;因为现在app大多使用多进程架构，我们计算所有的进程占用总和。&lt;/p&gt;
&lt;p&gt;测试分为四种典型使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主页&lt;/li&gt;
&lt;li&gt;读书界面&lt;/li&gt;
&lt;li&gt;漫画界面&lt;/li&gt;
&lt;li&gt;听书界面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌阅&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景/进程&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree:channel&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree:adp&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree:nocket&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出听书界面cpu占用比较高，可能涉及到编解码操作。adp进程，后期就消失了，具体后文会继续分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书旗&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景/进程&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;主页不显示动画&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;听书不显示动画&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:channel&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:pushdaemon&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:daemonwatch&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:daemonwatch&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;相比于掌阅，书旗多出了两种不同的场景。这是由于书旗阅读在首页和听书页面显示动画时，相比于没有动画时，cpu的占用明显增高。滑动列表使水波纹头部消失，cpu占用就下去了。听书页同理，也有一个动态的背景，导致cpu占用较高。下文的流畅性分析中也有和此处相关的测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ阅读&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景/进程&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;主页不显示动画&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:QS&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:game_process&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:pushservice&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:dl&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;同理，主页头部的水波纹移出屏幕后，cpu占用下降。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OPPO书城&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景/进程&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.oppo.book&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.oppo.book:dcs&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出，OPPO书城在这4者中表现最好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：从上面四个表格中可以看出，四款app均使用多进程技术，引入原因暂且不表。一般都是主进程在占用CPU时钟，对比来看，OPPO书城性能最好，QQ阅读次之，书旗最差。究其原因，书旗中使用了持续播放的动画，导致一直在占用cpu。这个东西以后在产品设计的时候一定要注意，恰当少量引入，在合适的位置引入，不然会引起耗电量问题和性能问题。&lt;/p&gt;
&lt;h4 id=&#34;3内存&#34;&gt;3）内存&lt;/h4&gt;
&lt;p&gt;内存指标有 VSS、RSS、PSS、USS，他们的含义分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VSS：Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）&lt;/li&gt;
&lt;li&gt;RSS：Resident Set Size 实际使用物理内存（包含共享库占用的内存）&lt;/li&gt;
&lt;li&gt;PSS：Proportional Set Size 实际使用的物理内存（按比例分配共享库占用的内存）&lt;/li&gt;
&lt;li&gt;USS：Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说内存占用大小有如下规律：VSS &amp;gt;= RSS &amp;gt;= PSS &amp;gt;= USS，一般测试中关注的比较多的是 PSS 这个指标。&lt;/p&gt;
&lt;p&gt;查询程序的内存占用，使用以下步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;adb shell    (进入linux命令行)&lt;/li&gt;
&lt;li&gt;top | grep packagename    (查询关心的进程pid)&lt;/li&gt;
&lt;li&gt;dumpsys meminfo pid   (查询进程的内存信息)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们以qq阅读为例，dumpsys meminfo 7872&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203819.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们关心PSS指标，可以看出TOTAL的第一项数据就是我们关心的结果。可以使用grep命令简化数据，下面的测试数据均使用&lt;strong&gt;dumpsys meminfo pid | grep TOTAL&lt;/strong&gt;测出。&lt;/p&gt;
&lt;p&gt;内存测试场景，也分为主页，读书，漫画，听书四部分测试。由于app使用了多进程技术，我们要把所有进程均计算在内。以下数据测试单位均为M。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌阅&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;进程/场景&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree&lt;/td&gt;
&lt;td&gt;108.21&lt;/td&gt;
&lt;td&gt;117.88&lt;/td&gt;
&lt;td&gt;124.75&lt;/td&gt;
&lt;td&gt;159.86&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree:channel&lt;/td&gt;
&lt;td&gt;15.96&lt;/td&gt;
&lt;td&gt;16.43&lt;/td&gt;
&lt;td&gt;13.23&lt;/td&gt;
&lt;td&gt;12.98&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree:nocket&lt;/td&gt;
&lt;td&gt;15.61&lt;/td&gt;
&lt;td&gt;15.56&lt;/td&gt;
&lt;td&gt;15.59&lt;/td&gt;
&lt;td&gt;15.69&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.chaozh.iReaderFree:adp&lt;/td&gt;
&lt;td&gt;11.50&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总计&lt;/td&gt;
&lt;td&gt;151.28&lt;/td&gt;
&lt;td&gt;149.87&lt;/td&gt;
&lt;td&gt;153.57&lt;/td&gt;
&lt;td&gt;188.53&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出，主进程内存占用最高，其余进程占用稍小。其中adp进程在进入主界面后消失，猜测这个adp为adprocess,即广告进程，主界面前的开屏广告为单独的进程。个人观点不是太必要，如此设计adp进程的初始化信息后续的主进程无法使用，但是此处的初始化基础信息如屏幕宽高等，后续进程都是需要使用的，不知是何种考虑，以后可以慢慢探讨。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书旗&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景/进程&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller&lt;/td&gt;
&lt;td&gt;180.72&lt;/td&gt;
&lt;td&gt;194.34&lt;/td&gt;
&lt;td&gt;239.08&lt;/td&gt;
&lt;td&gt;214.21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:channel&lt;/td&gt;
&lt;td&gt;25.94&lt;/td&gt;
&lt;td&gt;22.36&lt;/td&gt;
&lt;td&gt;21.67&lt;/td&gt;
&lt;td&gt;21.16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:pushdaemon&lt;/td&gt;
&lt;td&gt;11.22&lt;/td&gt;
&lt;td&gt;11.12&lt;/td&gt;
&lt;td&gt;10.77&lt;/td&gt;
&lt;td&gt;10.12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:daemonwatch&lt;/td&gt;
&lt;td&gt;9.20&lt;/td&gt;
&lt;td&gt;8.70&lt;/td&gt;
&lt;td&gt;8.27&lt;/td&gt;
&lt;td&gt;8.33&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:daemonwatch&lt;/td&gt;
&lt;td&gt;6.13&lt;/td&gt;
&lt;td&gt;6.13&lt;/td&gt;
&lt;td&gt;6.08&lt;/td&gt;
&lt;td&gt;6.06&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.shuqi.controller:audio&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;15.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总计&lt;/td&gt;
&lt;td&gt;233.21&lt;/td&gt;
&lt;td&gt;242.65&lt;/td&gt;
&lt;td&gt;285.87&lt;/td&gt;
&lt;td&gt;274.88&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出，书旗的各场景内存占用均比掌阅的高，而且，书旗在听书界面分出来一个audio进程，这个很有借鉴价值。一般来讲分进程有几种原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分担主进程压力，如推送进程，游戏进程等&lt;/li&gt;
&lt;li&gt;减小产品风险，划分单独进程，出现问题不影响主进程，如web进程，听书进程等&lt;/li&gt;
&lt;li&gt;守护进程，和主进程互相守护，互相保活，如daemon进程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看出，书旗划分的进程贴合了上述几种原因，单独的听书进程，单独的push进程，两个守护进程。当然进程也不是越多越好，多进程之间信息共享与进程开销都比正常单进程应用复杂，都要看产品设计和架构设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ阅读&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景/进程&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader&lt;/td&gt;
&lt;td&gt;61.46&lt;/td&gt;
&lt;td&gt;92.92&lt;/td&gt;
&lt;td&gt;134.75&lt;/td&gt;
&lt;td&gt;101.05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:QS&lt;/td&gt;
&lt;td&gt;11.61&lt;/td&gt;
&lt;td&gt;10.43&lt;/td&gt;
&lt;td&gt;10.03&lt;/td&gt;
&lt;td&gt;10.97&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:game_process&lt;/td&gt;
&lt;td&gt;46.01&lt;/td&gt;
&lt;td&gt;36.76&lt;/td&gt;
&lt;td&gt;36.11&lt;/td&gt;
&lt;td&gt;36.73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:pushservice&lt;/td&gt;
&lt;td&gt;9.97&lt;/td&gt;
&lt;td&gt;10.34&lt;/td&gt;
&lt;td&gt;10.33&lt;/td&gt;
&lt;td&gt;10.35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.qq.reader:dl&lt;/td&gt;
&lt;td&gt;28.72&lt;/td&gt;
&lt;td&gt;19.84&lt;/td&gt;
&lt;td&gt;19.72&lt;/td&gt;
&lt;td&gt;18.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总计&lt;/td&gt;
&lt;td&gt;157.78&lt;/td&gt;
&lt;td&gt;170.29&lt;/td&gt;
&lt;td&gt;210.95&lt;/td&gt;
&lt;td&gt;177.94&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出，QQ阅读各场景的内存占用比书旗要好，和掌阅相当。此处唯一有疑问的是game_process进程，一般来讲，进程都是在使用的时候创建，不使用的时候销毁，从字面意义来看，这属于游戏进程，但是我在上述四个场景中，并未使用到任何游戏相关的功能，自始至终游戏进程都存在，占用了一部分内存。后续可以查看下主线代码，看看此进程的用意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OPPO书城&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景/进程&lt;/th&gt;
&lt;th&gt;主页&lt;/th&gt;
&lt;th&gt;读书&lt;/th&gt;
&lt;th&gt;漫画&lt;/th&gt;
&lt;th&gt;听书&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;com.oppo.book&lt;/td&gt;
&lt;td&gt;105.31&lt;/td&gt;
&lt;td&gt;144.32&lt;/td&gt;
&lt;td&gt;156.72&lt;/td&gt;
&lt;td&gt;144.54&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;com.oppo.book:dcs&lt;/td&gt;
&lt;td&gt;4.79&lt;/td&gt;
&lt;td&gt;4.80&lt;/td&gt;
&lt;td&gt;4.79&lt;/td&gt;
&lt;td&gt;4.77&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总计&lt;/td&gt;
&lt;td&gt;110.10&lt;/td&gt;
&lt;td&gt;149.12&lt;/td&gt;
&lt;td&gt;160.51&lt;/td&gt;
&lt;td&gt;149.31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;直观上可以看出，OPPO书城是四款产品中内存使用情况最少的，表现最好。当然这个和他产品特点有关，进程数量少，猜测push使用系统push，保活有系统保证。漫画界面内存增长较高，可能与图片较多，较大有关。其中dcs进程在测试过程中时有时无。&lt;/p&gt;
&lt;h4 id=&#34;4电量和流量&#34;&gt;4）电量和流量&lt;/h4&gt;
&lt;p&gt;电量和流量是很重要的两个性能指标，这个十分影响用户体验。耗费流量越少，产生的资费越少；耗费的电量越少，待机时间越长。所以用户肯定喜欢耗流量少，耗电少的应用，这才是用户喜闻乐用的应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流量&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;流量指标测试比较麻烦，因为时间和设备原因，暂时未能进行详细的测试。在此处可以提出几点测试原则和开发原则。&lt;/p&gt;
&lt;p&gt;测试原则：使用控制变量法，测试4G,WIFI等环境下，各使用场景的流量消耗情况。&lt;/p&gt;
&lt;p&gt;开发原则：4G网络下的流量弹框提醒，网络重试次数时机控制等。分模块划分缓存时长，对于实时性不敏感的数据，进行缓存处理等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电量&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;电量测试也比较麻烦，实际使用中，需要测试同学制定相应的测试用例，测试4G,WIFI等环境下，各使用场景的电量消耗情况。&lt;/p&gt;
&lt;p&gt;此次分析使用了&lt;strong&gt;battery-historian V2.0&lt;/strong&gt;，对四款app进行了简要的电量消耗分析。&lt;/p&gt;
&lt;p&gt;Battery historian是一款通过上传bugreport文件分析用户手机中App的电池耗电情况的工具。具体的使用流程可以参考此篇博文（&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/liangxy2014/article/details/78311938&#34;&gt;battery-historian V2.0的数据获取及参数分析&lt;/a&gt;）。由于搭建分析环境比较麻烦，有热心的网友搭建了在线服务，此处提供一下地址（&lt;a href=&#34;https://bathist.ef.lc/&#34;&gt;在线分析网站&lt;/a&gt;），大家可以在线分析了，不用自己搭建，方便省心，再次感谢热心网友。&lt;/p&gt;
&lt;p&gt;测试场景如下：测试时长 10分钟 = app浏览1分钟 + 电子书阅读3分钟 + 漫画浏览3分钟 + 听书3分钟。&lt;br&gt;
对上述场景，按照上述博文描述，进行电量日志抓取，文末会给出文件，大家也可以拿文件进行分析。&lt;/p&gt;
&lt;p&gt;我们首先拿掌阅的app进行测试，给出一个分析步骤，后续的均按照此步骤分析。&lt;/p&gt;
&lt;p&gt;上传完日志文件，可以生成一个图表，类似下图：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然此处可以分析的不止箭头指出的那么简单一项，下面还有详细的各项内容，可以参考上述提到的博文中各项参数进行分析。此次我们只关注流量和电量，别的暂时先不分析。app stats选项卡下，有电量信息，如下图：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;可以看出我们使用了2.02%的电量。&lt;br&gt;
Network Information下有具体的流量消耗，此次测试仅测试WIFI网络，其余环境暂未测试。&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203908.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;可以看出我们使用了7.29M的流量。&lt;/p&gt;
&lt;p&gt;测试结果如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;APP\电量&lt;/th&gt;
&lt;th&gt;电量(%)&lt;/th&gt;
&lt;th&gt;流量（M）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;掌阅&lt;/td&gt;
&lt;td&gt;2.02&lt;/td&gt;
&lt;td&gt;7.29&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书旗&lt;/td&gt;
&lt;td&gt;2.12&lt;/td&gt;
&lt;td&gt;6.89&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QQ阅读&lt;/td&gt;
&lt;td&gt;2.17&lt;/td&gt;
&lt;td&gt;28.17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPPO书城&lt;/td&gt;
&lt;td&gt;1.91&lt;/td&gt;
&lt;td&gt;34.63&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对比来看，电量消耗相当，但是流量情况差距比较大。不知道是我自己测试的问题，还是实际使用情况如此，QQ阅读和OPPO书城的流量使用比掌阅和书旗的大，具体可以问测试同学要详细的测试数据。Battery historian中还有更加详尽的描述，如service，jobservice使用情况，cpu使用情况，alarm使用情况，wifilock，wakelock等。由于电量差距不是很大，此处便不做详尽分析，后续遇见异常情况可以使用此工具分析。&lt;/p&gt;
&lt;h2 id=&#34;3流畅性调研&#34;&gt;3.流畅性调研&lt;/h2&gt;
&lt;p&gt;流畅性分析主要分为以下两个方面：GPU呈现模式分析和GPU过度绘制&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203920.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;1gpu呈现模式分析&#34;&gt;1）GPU呈现模式分析&lt;/h4&gt;
&lt;p&gt;具体可以参考这篇博文（&lt;a href=&#34;https://www.cnblogs.com/ldq2016/p/6667381.html&#34;&gt;Android开发者选项——Gpu呈现模式分析&lt;/a&gt;），我们此次测试主要关注绿线（16ms线），红色条形（执行任务时间），蓝色条形（测量绘制时间）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌阅&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;掌阅的流畅性方面是4款产品中表现最好的。大部分页面滑动效果流畅，未超过16ms线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书旗&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;书旗这个和CPU测试结果一样，因为在某些页面存在持续性的动画，导致一直在渲染绘制，比如主页头部的水波纹特效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ阅读&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204002.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;QQ阅读整体表现也很棒，但是有一个界面卡顿状况明显。书库界面，每每滑动，就会出现越过16ms线的部分，从图中可以看出，最底下绿色较多，对照博文中的信息可知，代表Input Handling（事件处理）Misc Time/Vsync Delay（UI渲染跟不上vSync的信号），猜测此处可能执行了大量的主线程任务，有可能和图片处理和图片复用有关，具体的可以对照代码进行分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OPPO书城&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对比QQ阅读来看，同样是书城/分类界面，表现就很优异，基本上都在16ms线以下。可能测试的页面较少，未发现有特别卡顿的页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;br&gt;
整体来看，OPPO书城表现最优异，其余三者不相伯仲。可以看出动画的使用会影响模式分析结果，如书旗首页头部水波纹动画，QQ阅读、书旗小说、掌阅听书指示动画。&lt;/p&gt;
&lt;h4 id=&#34;2gpu过度绘制&#34;&gt;2）GPU过度绘制&lt;/h4&gt;
&lt;p&gt;过度绘制（Overdraw）描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的 CPU 以及 GPU 资源,所以我们应该避免过度绘制。具体关于过度绘制的知识点可以参考博文&lt;a href=&#34;https://blog.csdn.net/a740169405/article/details/53896497&#34;&gt;Android性能优化-过度绘制解决方案&lt;/a&gt;，然后对照下图进行分析。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204035.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;掌阅&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;毫不夸张的讲，掌阅的过度绘制优化是我见过最好的，做的和系统app一样优秀,他们应该下了不少功夫进行过度绘制优化。只有极少部分有4x的，大部分都是1x,2x,十分优秀。翻页界面，漫画界面等等，表现十分良好，大家可以自己按照博文的步骤，进行测试。有部分界面有1x,应该可以去掉的，有优化空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书旗&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204054.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;书旗的书城界面，过度绘制比较严重，存在优化空间。可能是由于控件背景未移除，导致过度绘制严重。大量二级三级页面都是红色的，需要进一步进行优化。值得表扬的是阅读界面，没有过度绘制的现象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;QQ阅读过度绘制问题比较明显，挑几个比较直观的地方说&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
侧栏过度绘制严重，这个上面博文中有解决方案，可以参考下，看下是否能解决。部分二级页网页形式，存在3x重绘。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;书籍详情页和读书界面有过度绘制情况，具体情况可以以后慢慢分析，逐渐解决。&lt;/p&gt;
&lt;p&gt;对比下QQ阅读的书城和掌阅的书城，如下图（左掌阅，右QQ阅读）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以很直观的看出差距，也许我们与掌阅差了一个背景色的距离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OPPO书城&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;书城也有部分页面存在过度绘制问题&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看出我们的书架页面和QQ阅读书架页面是有差距的，QQ阅读是1X，2X，我们是3X，4X，可以向主线同学学习，进行优化。听书界面也存在过度绘制。&lt;/p&gt;
&lt;p&gt;最严重的问题出现在夜间模式场景下。&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开夜间模式后，所有界面都增加了1x，漫天绯红，惨不忍睹。现在主流的app夜间模式都是采取控件换肤模式，我们也可以采用这种方案解决这个问题，而不是添加一层半透明遮罩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一环节掌阅大比分胜出，QQ阅读和OPPO书城表现较差，这方面还有较大的优化空间。&lt;/p&gt;
&lt;h3 id=&#34;4产品分析&#34;&gt;4.产品分析&lt;/h3&gt;
&lt;p&gt;作为研发同学，也要有一些产品思维，研发可以说是接触产品时间最长的用户，也能代表一部分用户观点。平时有好的用户需求，交互逻辑等，都可以与产品同学交流，共同促进用户体验。因为此前未做过此类产品分析，此次分析主要参考此篇博文（&lt;a href=&#34;http://www.woshipm.com/evaluating/654327.html&#34;&gt;从阅读、交流场景的功能设计，对四种阅读类APP进行竞品分析&lt;/a&gt;）思路，均为个人观点，如果不合理的地方，欢迎批评指正，交流学习。以下所有产品分析，因OPPO书城未在应用市场上线，只参与部分分析。&lt;/p&gt;
&lt;p&gt;产品分析从以下几点进行分析：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204200.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;1用户与产品定位&#34;&gt;1）用户与产品定位&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;用户定位&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;没有调查就没有发言权，我们首先了解下宏观上的产品定位。拿数据说话，从艾瑞app指数划分用户如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;App\项目&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;男&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;女&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;35岁以下占比&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;25-30岁占比&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;掌阅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;63.4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36.6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;94.85&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;41.58&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QQ阅读&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;53.91&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;46.09&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;95.06&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;39.59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书旗&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;42.36&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;57.64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;93.93&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;39.63&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数据表明：掌阅男性用户较多，书旗女性用户较多，QQ阅读男女用户占比相当。大部分用户为35岁以下，其中25-35岁居多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品定位&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;一般产品定位可以从企业的slogan看出。我们打开产品的闪屏页一般都会带有这句话。依次打开，发现如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;掌阅：引领品质阅读。可以看出，掌阅主打品质阅读，较为关注书籍品质。&lt;/li&gt;
&lt;li&gt;书旗：不一样的阅读。可以看出，应该是较为关注用户阅读体验。&lt;/li&gt;
&lt;li&gt;QQ阅读：海量原著，想读就读。可以看出，QQ阅读较为关注书籍内容广度，体现在于书库资源丰富，从APP内的产品分类详细程度上可以窥见一斑。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2产品功能分析&#34;&gt;2）产品功能分析&lt;/h4&gt;
&lt;p&gt;产品功能分析从以下三个部分进行解读：&lt;strong&gt;阅读需求，产品结构，功能分析&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;1阅读需求&#34;&gt;1.阅读需求&lt;/h4&gt;
&lt;p&gt;阅读分为电子书和纸质书，需求一般分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;娱乐爱好：各类网文，男频女频等&lt;/li&gt;
&lt;li&gt;知识积累：专业书籍，各类出版物等&lt;/li&gt;
&lt;li&gt;新型阅读：漫画杂志，听书等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们着重分析前两类需求，总结出来的需求大致如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;KANO模型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;用户需求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基本型需求&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;阅读稳定性，便捷性等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;期望型需求&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;推书，搜书等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;魅力型需求&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用户交流，阅读效率等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;三个产品，基本上都实现了以上的需求对应的功能。&lt;/p&gt;
&lt;h4 id=&#34;2产品结构&#34;&gt;2.产品结构&lt;/h4&gt;
&lt;p&gt;为了给用户提供1中表格的功能，产品设计方面就要围绕此表格进行设计，还有部分扩充。我们一一看下3款产品，提出优点与不足。此次分析的四款产品均为底部多tab结构，清晰明确。体现出了同质化设计，用户切换成本较小。而且此设计经调研，可运营可扩展性强，属于业内主流设计，如微信，QQ等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌阅&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204210.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;书城划分合理，分类清晰明确，比较符合直观感受&lt;/li&gt;
&lt;li&gt;发现页面定位为书友交流，其余三款均有此功能，但入口较深。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点： 本地书架缺少书名提示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书旗&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;优点： 单独拎出免费专区，方便用户查找。&lt;/p&gt;
&lt;p&gt;缺点： 书城定位模糊，仅突出了4大类，具体分类页放在了精选下一个小条目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ阅读&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204228.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;优点： 书库页分类详细，种类繁多。用户可挑选自己喜欢的类目进行查阅。&lt;/p&gt;
&lt;p&gt;缺点： 书库页不能滑动切换分类，而且书评广场入口隐藏较深。作为QQ类产品，用户量庞大，应突出书评交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OPPO书城&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204236.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;优点： 分类页既有掌阅的简洁大方，又有QQ阅读的详实充足&lt;/p&gt;
&lt;p&gt;缺点：听书分类和漫画分类不太明显。&lt;/p&gt;
&lt;h4 id=&#34;3功能分析&#34;&gt;3.功能分析&lt;/h4&gt;
&lt;p&gt;从用户需求出发，阅读的本质就是读书，我们从读书前，读书中，读书后三个部分进行功能分析，看一看三款APP的合理与不合理之处。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119204247.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;读书前&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读书前的功能分析主要分为，找书，搜书，推荐。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推荐方面，均有热门推荐，排行榜，相似推荐等功能&lt;/li&gt;
&lt;li&gt;找书方面，书库目录子条目清晰，分类明确&lt;/li&gt;
&lt;li&gt;搜书方面，搜索页热门推荐，搜索关键字自动补全等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三款产品做得中规中矩，可以算是打成平手。值得一提的是，QQ阅读中有阅读基因功能，后期可以让用户指定喜爱的类别，进行修正。掌阅和书旗出现在引导页，app内未发现修改入口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读书中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读书中的功能分析主要分为，阅读功能，段落评论和批注。阅读功能属于阅读类产品特有的功能，三款产品设计也都是大同小异，不做过多评价。值得一提的是段落评论功能，这个设计有失也有得，失在于打破了安静的阅读环境，引诱用户点击，降低用户阅读效率。得在于增进用户交流，深化用户阅读体验，类似于B站弹幕类，体验较好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读书后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读书后，主要分为书评，书友交流。书评功能做得都比较好，在当前阅读页的设置中，都加入了书评入口，方便用户进行阅读评论，掌阅的书评入口在二级设置页，稍微有点深。书友交流功能三款产品设计差异较大，分析如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;掌阅，单独划分发现页，对书友交流重视程度较大&lt;/li&gt;
&lt;li&gt;书旗，未见单独的书友交流功能，主页划分出一个原创tab，可能产品侧重点不同&lt;/li&gt;
&lt;li&gt;QQ阅读，包含书友交流，名为书评广场，个人感觉可以单独拎出来做产品方向，值得深入挖掘&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三款产品在此分析环节，表现均优异，平分秋色。大方向上各有侧重，具体设计上可以看出同质化，猜测产品同学也经常进行竞品分析。此处建议多从阅读本质出发，多从用户角度出发，结合KANO模型，设计出用户喜欢，满意的功能，尽量避免为了需求而需求的伪需求发生。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过竞品分析，我们可以了解到竞品的优势和劣势，知己知彼，百战不殆，从而更好的去优化我们自己的产品。当然以上只是简单的技术分析，更详细的可以参考以往同学写的内容，进行补充。此次也重温了下许多基础知识，确实是一个快速了解产品的好办法。当然，写的比较仓促，如果有错误的地方，欢迎大家指出问题，进行修改，互相学习。&lt;/p&gt;
&lt;h2 id=&#34;附录&#34;&gt;附录：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;竞品分析文件：链接：https://pan.baidu.com/s/1Kx3iR1uzDnHyyo0GziZVuw 密码：s8db 内含apk文件，电量文件，脑图文件&lt;/li&gt;
&lt;li&gt;cpu,内存测试参考博文：三篇app性能测试 &lt;a href=&#34;https://blog.csdn.net/heshushun/article/category/7158418&#34;&gt;https://blog.csdn.net/heshushun/article/category/7158418&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">阅读类app竞品分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/tong-guo-guan-cha-zhe-mo-shi-jian-ting-mei-ti-ku-de-bian-hua-shi-xian-app-ben-di-shu-ju-zi-dong-geng-xin/"" data-c="
          &lt;p&gt;转自:&lt;a href=&#34;http://zmywly8866.github.io/2015/03/03/auto-update-app-data.html?utm_source=tuicool&amp;amp;utm_medium=referral&#34;&gt;http://zmywly8866.github.io/2015/03/03/auto-update-app-data.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;当我在使用音乐播放器和各种小说APP的过程中，感觉非常不好的一个体验就是你需要通过手动点击全盘检索后，新下载的数据、从磁盘拷贝的数据才会更新显示在列表上，这对于我们来说看上去没有什么不对，但从用户的角度出发这是一个非常不好的体验，因为多数人是根本不知道全盘检索这个概念的，手动更新APP的本地数据无形之中增加了用户使用APP的学习成本。&lt;/p&gt;
&lt;p&gt;我们之前做的小系统APP也是通过手动检索这种方式来刷新程序中的本地数据列表的，在接触到Android的媒体库后，发现这个问题能够通过观察者模式监听Android媒体数据库变化的方式来实现APP本地数据的自动更新，在成功实现这个功能后，现在将其总结下来方便后面查看。&lt;/p&gt;
&lt;h3 id=&#34;android媒体库&#34;&gt;Android媒体库&lt;/h3&gt;
&lt;p&gt;媒体库是什么？：在Android系统中，为了提高应用检索数据的效率，Android会将存储在文件系统中的文件信息保存在一个数据库文件中，这样在应用中就可以通过读取该数据库来快速查找满足APP需求的文件列表，比如一个电子书阅读APP，通过如下方法就可以获取到媒体库中存在的电子书文件列表，保存哪些格式的文件是可以通过修改Android原来来调整的，不过对于多媒体文件来说，Android原生系统默认就保存在媒体库中了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
   * 从媒体库中获取指定后缀的文件列表
   * 
   * @param searchFileSuffix 文件后缀列表，eg: new String[]{&amp;quot;epub&amp;quot;,&amp;quot;mobi&amp;quot;,&amp;quot;pdf&amp;quot;,&amp;quot;txt&amp;quot;};
   * @return 指定后缀的文件列表
   * */
  public static ArrayList&amp;lt;String&amp;gt; getSupportFileList(Context context, String[] searchFileSuffix) {
    ArrayList&amp;lt;String&amp;gt; searchFileList = null;
    if (null == context || null == searchFileSuffix
        || searchFileSuffix.length == 0) {
      return null;
    }
    String searchPath = &amp;quot;&amp;quot;;
    int length = searchFileSuffix.length;
    for (int index = 0; index &amp;lt; length; index++) {
      searchPath += (MediaStore.Files.FileColumns.DATA + &amp;quot; LIKE &#39;%&amp;quot; + searchFileSuffix[index] + &amp;quot;&#39; &amp;quot;);
      if ((index + 1) &amp;lt; length) {
        searchPath += &amp;quot;or &amp;quot;;
      }
    }
    searchFileList = new ArrayList&amp;lt;String&amp;gt;();
    Uri uri = MediaStore.Files.getContentUri(&amp;quot;external&amp;quot;);
    Cursor cursor = context.getContentResolver().query(
        uri,new String[] { MediaStore.Files.FileColumns.DATA,MediaStore.Files.FileColumns.SIZE }, searchPath, null,null);
    if (cursor == null) {
      System.out.println(&amp;quot;Cursor 获取失败!&amp;quot;);
    } else {
      if (cursor.moveToFirst()) {
        do {
          String filepath = cursor.getString(cursor.getColumnIndex(MediaStore.Files.FileColumns.DATA));
          if (isFileExist(filepath)) {
            try {
              searchFileList.add(new String(filepath.getBytes(&amp;quot;UTF-8&amp;quot;)));
            } catch (UnsupportedEncodingException e) {
              e.printStackTrace();
            }
          }
        } while (cursor.moveToNext());
      }
      if (!cursor.isClosed()) {
        cursor.close();
      }
    }
    return searchFileList;
  }
  /**
   * 判断SD卡上的文件夹是否存在
   * 
   * @param fileName 文件名
   * @return true 文件存在，false 文件不存在
   */
  private static boolean isFileExist(String filePath) {
    File file = null;
    boolean isExist = false;
    if (null != filePath) {
      file = new File(filePath);
      isExist = (null != file &amp;amp;&amp;amp; file.isFile()) ? file.exists() : false;
      if (isExist &amp;amp;&amp;amp; null != file &amp;amp;&amp;amp; 0 == file.length()) {
        isExist = false;
      }
    }
    return isExist;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;媒体库更新时机：Android系统会在系统开机、USB插拔、TF卡插拔的时候自动更新媒体库（将新增的文件添加到媒体库中，移除不存在的文件数据记录），除了Android系统会自动更新媒体库文件外，开发者也可以在程序中手动更新媒体库，这样能够在文件系统中有新的文件或者通过程序删掉某些文件时能够将动态及时更新到媒体库，保证媒体库中的文件信息是实时的，更新的具体方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;context.sendBroadcast( new Intent( Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse( &amp;quot;file://&amp;quot; + filePath ) ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：上面介绍是的更新单个文件的方式，Android没有提供直接更新整个文件夹的方式，如果是整个文件夹，可以先得到文件夹下的所有文件路径列表，然后挨个更新，对于这个如果有更先进的方法欢迎提出。&lt;/p&gt;
&lt;h3 id=&#34;app本地数据自动更新的具体实现&#34;&gt;APP本地数据自动更新的具体实现&lt;/h3&gt;
&lt;p&gt;类似于上述的音视频播放器、小说阅读APP，如果我们需要实现本地数据APP自动更新的功能，只要保持APP支持文件列表的数据库和媒体库中的对应格式的文件同步就可以了，所以我们需要做的是：监听媒体库中文件列表的变化，然后将变化告知APP即可，原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过广播监听USB插拔、TF卡插拔，如果检查到在APP运行过程中有这些操作，直接通过APP全盘检索；&lt;/li&gt;
&lt;li&gt;通过观察者模式监听媒体库中的文件变化，如果有变化，每隔五秒钟将APP现存列表和媒体库中检索到对应格式的文件列表做比较，如果列表有变化，则将变化的列表更新给APP；&lt;/li&gt;
&lt;li&gt;在APP进入、退出时注册/反注册广播、打开/关闭计时器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个代码非常简单，一个类搞定，具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Timer;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Handler;
import android.provider.MediaStore;
/**
 * 自动更新书架
 * 
 * */
public class AutoRefreshBookShelf {
  public AutoRefreshBookShelf( Context context, AutoRefreshListener autoRefreshListener, String[] supportSuffix ) throws NullPointerException{
    if( null == context || null == autoRefreshListener || null == supportSuffix ){
      throw new NullPointerException( &amp;quot;传非空的参数进来！&amp;quot; );
    }
    mContext = context;
    mAutoRefreshListener = autoRefreshListener;
    mSupportSuffix = supportSuffix;
    initAutoRefreshBookShelf( );
  }
  // 不在本界面停止后台检索
  public void onPause( ){
    stopCheckFileTimer( );
  }
  // 返回界面恢复后台检索
  public void onResume( ){
    startCheckFileTimer( );
  }
  /**
   * 注销广播
   * 
   * */
  public void unregisterAutoRefreshBookShelf( ) throws NullPointerException{
    if( null == mBroadcastReceiver || null == mMediaStoreChangeObserver || null == mContext ){
      throw new NullPointerException( &amp;quot;没有初始化&amp;quot; );
    }
    mContext.unregisterReceiver( mBroadcastReceiver );
    mContext.getContentResolver( ).unregisterContentObserver( mMediaStoreChangeObserver );
    stopCheckFileTimer( );
  }
  /**
   * 得到变化的文件列表
   * 
   * */
  public void getChangedFileList( ){
    System.out.println( &amp;quot;toast ================= getChangedFileList &amp;quot; );
    startCheckFileTimer( );
  }
  private void initAutoRefreshBookShelf( ){
    startMediaFileListener( );
    observerMediaStoreChange( );
  }
  private void observerMediaStoreChange( ){
    if( null == mMediaStoreChangeObserver ){
      mMediaStoreChangeObserver = new MediaStoreChangeObserver( );
    }
    mContext.getContentResolver( ).registerContentObserver( MediaStore.Files.getContentUri(&amp;quot;external&amp;quot;), false, mMediaStoreChangeObserver );
  }
  /**
   * 监听USB的状态，更新书架书本信息
   * 
   * */
  private void startMediaFileListener( ){
    if( null != mBroadcastReceiver ){
      return;
    }
    IntentFilter intentFilter = new IntentFilter( );
    intentFilter.addAction( Intent.ACTION_MEDIA_SCANNER_FINISHED );
    intentFilter.addAction( Intent.ACTION_MEDIA_MOUNTED );
    intentFilter.addAction( Intent.ACTION_MEDIA_EJECT );
    intentFilter.addDataScheme( &amp;quot;file&amp;quot; );
    mBroadcastReceiver = new BroadcastReceiver(){
      @Override
      public void onReceive(Context context,Intent intent){
        String action = intent.getAction( );
        if( Intent.ACTION_MEDIA_SCANNER_FINISHED.equals( action ) ){
          System.out.println( &amp;quot;toast ================= ACTION_MEDIA_SCANNER_FINISHED &amp;quot; );
          mTimerWorking = false;
          startCheckFileTimer( );
        }else if( action.equals( Intent.ACTION_MEDIA_MOUNTED ) ){
          System.out.println( &amp;quot;toast ================= ACTION_MEDIA_MOUNTED or ACTION_MEDIA_EJECT &amp;quot; );
          mTimerWorking = true;
          mAutoRefreshListener.onBookScan( );
        }else if( action.equals( Intent.ACTION_MEDIA_EJECT ) ){
          mAutoRefreshListener.onBookScan( );
        }
      }
    };
    mContext.registerReceiver( mBroadcastReceiver, intentFilter );//注册监听函数
  }
  /**
   * 媒体数据库变更观察类
   * 
   * */
  class MediaStoreChangeObserver extends ContentObserver{
    public MediaStoreChangeObserver( ) {
      super( new Handler( ) );
    }
    @Override
    public void onChange(boolean selfChange) {
      super.onChange(selfChange);
      startCheckFileTimer( );
    }
  }
  private void startCheckFileTimer( ){
    if( mTimerWorking ){
      return;
    }
    mCheckFileTimer = new Timer( );
    mCheckFileTimer.schedule( new CheckFileChangeTimerTask( ), 5000 );
    mTimerWorking = true;
  }
  private void stopCheckFileTimer( ){
    if( null != mCheckFileTimer ){
      mCheckFileTimer.cancel( );
      mCheckFileTimer = null;
      mTimerWorking = false;
    }
  }
  /**
   * 得到新增的文件列表
   * 
   * */
  public ArrayList&amp;lt;String&amp;gt; getChangedFileList( Context context, String[] searchFileSuffix, ArrayList&amp;lt;String&amp;gt; existFileList ){
    ArrayList&amp;lt;String&amp;gt; changedFileList = null;
    if( null == context || null == searchFileSuffix ){
      return changedFileList;
    }
    ArrayList&amp;lt;String&amp;gt; supportFileList = getSupportFileList( context, searchFileSuffix );
    changedFileList = getDifferentFileList( supportFileList, existFileList );
    if( null == changedFileList || changedFileList.size( ) == 0 ){
      changedFileList = null;
    }
    return changedFileList;
  }
  /**
   * 获取新增的文件列表
   * 
   * */
  private ArrayList&amp;lt;String&amp;gt; getDifferentFileList( ArrayList&amp;lt;String&amp;gt; newFileList, ArrayList&amp;lt;String&amp;gt; existFileList ){
    ArrayList&amp;lt;String&amp;gt; differentFileList = null;
    if( null == newFileList || newFileList.size( ) == 0 ){
      return differentFileList;
    }
    differentFileList = new ArrayList&amp;lt;String&amp;gt;( );
    boolean isExist = false;
    if( null == existFileList ){
      // 如果已存在文件为空，那肯定是全部加进来啦。
      for( String newFilePath : newFileList ){
        differentFileList.add( newFilePath );
      }
    }else{
      for( String newFilePath : newFileList ){
        isExist = false;
        for( String existFilePath : existFileList ){
          if( existFilePath.equals( newFilePath ) ){
            isExist = true;
            break;
          }
        }
        if( !isExist ){
          differentFileList.add( newFilePath );
        }
      }
    }
    return differentFileList;
  }
  /**
   * 从媒体库中获取指定后缀的文件列表
   * 
   * */
  public ArrayList&amp;lt;String&amp;gt; getSupportFileList( Context context, String[] searchFileSuffix ) {
    ArrayList&amp;lt;String&amp;gt; searchFileList = null;
    if( null == context || null == searchFileSuffix || searchFileSuffix.length == 0 ){
      return null;
    }
    String searchPath = &amp;quot;&amp;quot;;
    int length = searchFileSuffix.length;
    for( int index = 0; index &amp;lt; length; index++ ){
      searchPath += ( MediaStore.Files.FileColumns.DATA + &amp;quot; LIKE &#39;%&amp;quot; + searchFileSuffix[ index ] + &amp;quot;&#39; &amp;quot; );
      if( ( index + 1 ) &amp;lt; length ){
        searchPath += &amp;quot;or &amp;quot;;
      }
    }
    searchFileList = new ArrayList&amp;lt;String&amp;gt;();
    Uri uri = MediaStore.Files.getContentUri(&amp;quot;external&amp;quot;);
    Cursor cursor = context.getContentResolver().query(
        uri, new String[] { MediaStore.Files.FileColumns.DATA, MediaStore.Files.FileColumns.SIZE, MediaStore.Files.FileColumns._ID },
        searchPath, null, null);
    String filepath = null;
    if (cursor == null) {
      System.out.println(&amp;quot;Cursor 获取失败!&amp;quot;);
    } else {
      if (cursor.moveToFirst()) {
        do {
          filepath = cursor.getString(cursor.getColumnIndex(MediaStore.Files.FileColumns.DATA));
          try {
            searchFileList.add(new String(filepath.getBytes(&amp;quot;UTF-8&amp;quot;)));
          } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
          }
        } while (cursor.moveToNext());
      }
      if (!cursor.isClosed()) {
        cursor.close();
      }
    }
    return searchFileList;
  }
  /**
   * 得到媒体库更新的文件
   * 
   * */
  class GetMediaStoreDataTask extends AsyncTask&amp;lt; Void , Void , Void&amp;gt;{
    @Override
    protected Void doInBackground(Void... arg0) {
      ArrayList&amp;lt;String&amp;gt; changedFileList = getChangedFileList( mContext, mSupportSuffix, mAutoRefreshListener.onGetBookPathList( ) );
      if( null != changedFileList &amp;amp;&amp;amp; changedFileList.size( ) &amp;gt; 0 ){
        mAutoRefreshListener.onBookRefresh( changedFileList );
      }
      mTimerWorking = false;
      return null;
    }
  }
  class CheckFileChangeTimerTask extends java.util.TimerTask{
    @Override
    public void run() {
      new GetMediaStoreDataTask( ).execute( );
    }
  }
  /**
   * 书架自动刷新接口
   * 
   * */
  public interface AutoRefreshListener{
    public ArrayList&amp;lt;String&amp;gt; onGetBookPathList( ); // 得到书架书本列表
    public void onBookRefresh( ArrayList&amp;lt;String&amp;gt; bookInfoList );// 刷新书架
    public void onBookScan( );//全盘扫描书架
  }
  private boolean mTimerWorking = false;
  private Context mContext = null;
  private String[] mSupportSuffix = null;
  private BroadcastReceiver mBroadcastReceiver = null;
  private MediaStoreChangeObserver mMediaStoreChangeObserver = null;
  private AutoRefreshListener mAutoRefreshListener = null;
  private Timer mCheckFileTimer = null;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：建议该功能只在APP运行时开启，因为现实的文件列表只有你真正在使用APP时才会去查看，所以没有必要通过这种方式在后台操作。&lt;/p&gt;
">通过观察者模式监听媒体库的变化实现APP本地数据自动更新</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/huo-qu-wei-an-zhuang-zi-yuan-apk-chong-de-zi-yuan-wen-jian/"" data-c="
          &lt;p&gt;最近做游戏联运的sdk插件，里面涉及到了游戏的登录、应用内支付等功能，故而界面的布局是少不了的。首先，想到的是xml布局，但是，作为第三方的sdk插件，作为jar包需要加到第三方的libs中，xml界面布局是不被打包到jar包中的。虽然，xml布局文件可以通过反射获取到，但是，这对第三方的要求是所有文件必须放的位置正确，不得出现疏忽。为此，想到，如果把所有的资源文件全部放到一个apk中，然后去加载这个apk的资源，那问题岂不是都解决了？带着这个想法，一步一步来实现这个功能。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;众所周知，apk中的资源文件基本上全部放到res目录下面，所以，怎么获取到资源apk的res实体是首要目标。以下代码就是获取资源apk中的Resource：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.tabolt.reflect;  
  
import java.io.File;  
import java.lang.reflect.Constructor;  
import java.lang.reflect.Field;  
import java.lang.reflect.Method;  
import android.content.Context;  
import android.content.res.Resources;  
import android.util.DisplayMetrics;  
  
public class GetOtherApkRes {  
    /** 
     *获取指定路径apk的resources 
     *@param context 上下文 
     *@param apkPath apk绝对路径  
     */  
    public static Resources getResources(Context context, String apkPath) {  
        File file = new File(apkPath);  
        String PATH_PackageParser = &amp;quot;android.content.pm.PackageParser&amp;quot;;  
        String PATH_AssetManager = &amp;quot;android.content.res.AssetManager&amp;quot;;  
        try {  
            // 反射得到pkgParserCls对象并实例化,有参数  
            Class&amp;lt;?&amp;gt; pkgParserCls = Class.forName(PATH_PackageParser);  
            Class&amp;lt;?&amp;gt;[] typeArgs = { String.class };  
            Constructor&amp;lt;?&amp;gt; pkgParserCt = pkgParserCls.getConstructor(typeArgs);  
            Object[] valueArgs = { file.getAbsolutePath() };  
            Object pkgParser = pkgParserCt.newInstance(valueArgs);  
  
            // 从pkgParserCls类得到parsePackage方法  
            DisplayMetrics metrics = new DisplayMetrics();  
            metrics.setToDefaults();// 这个是与显示有关的, 这边使用默认  
            typeArgs = new Class&amp;lt;?&amp;gt;[] { File.class, String.class,DisplayMetrics.class, int.class };  
            Method pkgParser_parsePackageMtd = pkgParserCls.getDeclaredMethod(&amp;quot;parsePackage&amp;quot;, typeArgs);  
            valueArgs = new Object[] { file, file.getAbsolutePath(), metrics, 0 };  
  
            // 执行pkgParser_parsePackageMtd方法并返回  
            Object pkgParserPkg = pkgParser_parsePackageMtd.invoke(pkgParser,valueArgs);  
  
            // 从返回的对象得到名为&amp;quot;applicationInfo&amp;quot;的字段对象  
            if (pkgParserPkg == null) {  
                return null;  
            }  
            Field appInfoFld = pkgParserPkg.getClass().getDeclaredField(&amp;quot;applicationInfo&amp;quot;);  
  
            // 从对象&amp;quot;pkgParserPkg&amp;quot;得到字段&amp;quot;appInfoFld&amp;quot;的值  
            if (appInfoFld.get(pkgParserPkg) == null) {  
                return null;  
            }  
            // 反射得到assetMagCls对象并实例化,无参  
            Class&amp;lt;?&amp;gt; assetMagCls = Class.forName(PATH_AssetManager);  
            Object assetMag = assetMagCls.newInstance();  
            // 从assetMagCls类得到addAssetPath方法  
            typeArgs = new Class[1];  
            typeArgs[0] = String.class;  
            Method assetMag_addAssetPathMtd = assetMagCls.getDeclaredMethod(&amp;quot;addAssetPath&amp;quot;, typeArgs);  
            valueArgs = new Object[1];  
            valueArgs[0] = file.getAbsolutePath();  
            // 执行assetMag_addAssetPathMtd方法  
            assetMag_addAssetPathMtd.invoke(assetMag, valueArgs);  
            // 得到Resources对象并实例化,有参数  
            Resources res = context.getResources();  
            typeArgs = new Class[3];  
            typeArgs[0] = assetMag.getClass();  
            typeArgs[1] = res.getDisplayMetrics().getClass();  
            typeArgs[2] = res.getConfiguration().getClass();  
            Constructor&amp;lt;Resources&amp;gt; resCt = Resources.class.getConstructor(typeArgs);  
            valueArgs = new Object[3];  
            valueArgs[0] = assetMag;  
            valueArgs[1] = res.getDisplayMetrics();  
            valueArgs[2] = res.getConfiguration();  
            res = (Resources) resCt.newInstance(valueArgs);  
            return res;  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        return null;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ok，上面的代码已经获取到了资源apk里面的Resource，然后接下来就是获取你要得到的资源了。&lt;br&gt;
第一步：Resource中有个方法是getIdentifie，三个参数分别是 资源名，资源类型，资源apk包名，通过此方法可以获取到资源的id号。&lt;br&gt;
第二步：上一步获取到资源id号之后，接下来就是要得到实质性的资源了。对于简单类型的资源，如：&lt;/p&gt;
&lt;p&gt;(1)图片资源，可以获取到Drawable类型的图片&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Drawable getResApkDrawable(int id) {  
	return res.getDrawable(id);
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)String类型资源，获取String文件夹中的字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String getResApkString(int id) {  
    return res.getString(id)  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于color，dimens文件中的资源，获取方式与以上两种相同，再次不在赘述。&lt;br&gt;
(3.1) layout布局资源的获取，要想获取layout资源，我采用的是根据id先获取XmlPullParser，然后再调用LayoutInflater的inflate方法获取layout资源，视图view。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public View getResApkLayoutView(Context context, int id) {  
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);  
    return inflater.inflate(res.getLayout(id), null);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3.2) 上一步获取到layout布局，然后就是要获取到layout中控件的实体view了，很简单，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public View getResApkWidgetView(View layout, int id) {  
    return layout.findViewById(id);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(4) anim动画资源的获取，res中没有方法可以直接获取到Animation，只有方法getAnimation获取到XmlPullParser，查询AnimationUtils的loadAnimation方法，发现加载Animation的最后一步是方法createAnimationFromXml，此方法的源码是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Animation createAnimationFromXml(Context c, XmlPullParser parser,AnimationSet parent,AttributeSet attrs)                                 throws XmlPullParserException, IOException {  
  
    Animation anim = null;  
    int type;  
    int depth = parser.getDepth();  
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &amp;gt; depth) &amp;amp;&amp;amp; 
						type != XmlPullParser.END_DOCUMENT) {  
        if (type != XmlPullParser.START_TAG) {  
            continue;  
        }  
        String name = parser.getName();  
        if (name.equals(&amp;quot;set&amp;quot;)) {  
            anim = new AnimationSet(c, attrs);  
            createAnimationFromXml(c, parser, (AnimationSet) anim, attrs);  
        } else if (name.equals(&amp;quot;alpha&amp;quot;)) {  
            anim = new AlphaAnimation(c, attrs);  
        } else if (name.equals(&amp;quot;scale&amp;quot;)) {  
            anim = new ScaleAnimation(c, attrs);  
        } else if (name.equals(&amp;quot;rotate&amp;quot;)) {  
            anim = new RotateAnimation(c, attrs);  
        } else if (name.equals(&amp;quot;translate&amp;quot;)) {  
            anim = new TranslateAnimation(c, attrs);  
        } else {  
            throw new RuntimeException(&amp;quot;Unknown animation name: &amp;quot;+ parser.getName());  
        }  
        if (parent != null) {  
            parent.addAnimation(anim);  
        }  
    }  
    return anim;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有就是attrs的获取，AttributeSet attrs = Xml.asAttributeSet(parser);至此，动画Animation的获取算是完毕，最后的调用方法是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Animation getResApkAnim(Context context, int id) {  
    Animation animation = null;  
    XmlPullParser parser = res.getAnimation(id); 
	AttributeSet attrs = Xml.asAttributeSet(parser);  
    try {  
        animation = createAnimationFromXml(context, parser, null, attrs);  
    } catch (XmlPullParserException e) {  
        e.printStackTrace();  
    } catch (IOException e) {  
        e.printStackTrace();  
    }  
    return animation;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，到现在为止，资源apk中的要获取的资源现在都可以获取的到了，需要注意的是，获取layout布局视图view的时候，布局中用到的@资源的设置失效，不建议使用。&lt;/p&gt;
">获取未安装资源apk种的资源文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/jian-dan-ming-liao-che-di-di-li-jie-binder/"" data-c="
          &lt;p&gt;转自:&lt;a href=&#34;http://blog.csdn.net/huachao1001/article/details/51504469&#34;&gt;http://blog.csdn.net/huachao1001/article/details/51504469&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你是不是看过很多Binder文章但是还是对Binder没有一个深刻理解？不是那些文章讲得不够好，主要是存在两种情况，一种是讲的深，全C代码&lt;sub&gt;，对我这种专做Java的人来说没有心情往下看；另一种是只讲framework层，Binder驱动并没有具体提，导致我们会用Binder，也大致能说的出一些原理，可并没有一个完整的深刻认知。那么接下来让我们一起学习Binder吧，相信接下来的内容会让你有一定的收获&lt;/sub&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;什么是binder&#34;&gt;什么是Binder&lt;/h3&gt;
&lt;p&gt;这个问题很多文章都有解释，比如：Binder是Android跨进程通信方式，它实现了IBinder接口，是ServiceManager连接各种Manager(如WindowManager、ActivityManager等)的桥梁。但是我觉得这些说法还是过于抽象。刚接触Binder时，看到这些定义还是一头雾水，只是内心觉得Binder很牛逼、很底层，仅此而已。&lt;/p&gt;
&lt;p&gt;那么应该怎么去理解Binder呢？我不打算介绍这个概念，而是介绍Binder是怎么来到Android世界的。我是这样理解的：Android团队想要实现进程之间的通信，需要解决以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何知道客户端需要调用哪个进程以及该进程中的函数&lt;/li&gt;
&lt;li&gt;客户端如何将函数形参发送给远程进程中的函数，以及如何将远程进程函数计算结果返回客户端&lt;/li&gt;
&lt;li&gt;如何去屏蔽底层通信细节，让实现客户端调用远程函数就像调用本地函数一样&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个问题，很容易解决，只要给每个需要远程通信的类唯一标识就可以通过包名+类名的字符串就可以做到，然后在类里面给每个函数编号即可对函数唯一编码。第二个问题，定义一个可打包的接口Parcelable，这个接口提供2个重要函数，分别是将对象中的属性写入到数组和从数组中的数据还原对象，每个可以发送到远程函数作为形参的对象只需实现Parcelable对象即可。Parcelable具体使用不再本文讨论范围。第三个问题，为了屏蔽进程之间的通信细节，那么Android团队肯定在想，定义一个类，由这个类来实现这些细节。这个类应该做哪些事情呢？首先，这个类得帮用户发送远程请求并将拿到返回结果提交给用户，这是最重要的功能了，有了这个功能，妈妈再也不用担心我的进程通信。其次，如果我想实现服务端，什么时候客户端调用我了，这些细节不用用户操心。当然，这个类还要帮用户封装更多细节。既然打算定义这个类了，那总得取个响当当的名称吧，什么？你说取名为Binder，好吧，那就叫Binder吧。Binder类既然封装很多功能，那该怎么用这个类呢？让客户端去继承还是服务端继承呢？答案是服务端。接下来有个约定，本文后面所指的Binder类都是指远程服务端的对象。服务端想要实现被跨进程访问，就必须继承Binder类。&lt;br&gt;
首先我们看看我们的程序跨进程调用系统服务的简单示例，实现浮动窗口部分代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//获取WindowManager服务引用
WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);  
//布局参数layoutParams相关设置略...
View view=LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, null);  
//添加view
wm.addView(view, layoutParams);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统服务都是运行在systemServer进程中，因此我们调用系统服务都是跨进程的调用。第2行代码中，得到的wm是WindowManager对象的引用，第6行调用WindowManager的addView函数，将触发远程调用，调用的是运行在systemServer进程中的WindowManager的addView函数。是不是很想知道addView发生了什么？我们先看看Binder机制吧！看完Binder原理，再解释！&lt;/p&gt;
&lt;h3 id=&#34;binder机制&#34;&gt;Binder机制&lt;/h3&gt;
&lt;p&gt;先看看一般执行过程&lt;/p&gt;
&lt;h4 id=&#34;代码执行过程&#34;&gt;代码执行过程&lt;/h4&gt;
&lt;p&gt;假设你已经创建好服务端类MyService、客户端类MyClient。在客户端持有MyService的引用，并且调用了MyService的func函数，那么Android内部调用过程如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;看了这个图以后，相信你对你的代码在调用远程进程函数时有个全局的认识。这张图有一点很重要，就是客户端当前线程会被挂起！因此，如果远程进程是执行长时间的运算，请不要使用主线程去调用远程函数，以防止ANR。&lt;/p&gt;
&lt;h3 id=&#34;binder的cs架构&#34;&gt;Binder的C/S架构&lt;/h3&gt;
&lt;p&gt;上面一节我们对远程进程调用代码执行过程有个初步了解，在Android开发中，我们大量使用到了系统Service，比如媒体播放、各种传感器以及WindowManagerService等等等等（太多了~）。那么Android是怎么管理这些服务，并且让用户跨进程调用这些服务呢？首先我们看看调用系统服务的过程。在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册（即让ServiceManager管理）。客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，然后通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203442.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;binder驱动实现原理&#34;&gt;Binder驱动实现原理&lt;/h3&gt;
&lt;p&gt;一直以来，我有个困惑！！！这个困惑让我迷茫了很久：客户端持有远程进程的某个对象引用，然后调用引用类中的函数，远程进程的函数就执行了。我在想，凭什么？学过操作系统都知道，不同的进程之间是不共享资源的。也就是说，客户端持有的这个对象跟远程进程中的实际对象完全是两个不同的对象。客户端调用引用的对象跟远程进程半毛钱关系都没有，凭啥远程进程就调用了执行了？相信也有一部分人跟我有同样的困惑！仔细研读一下下面这张图，相信你会豁然开朗！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203454.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;服务端跨进程的类都要继承Binder类。我们所持有的Binder引用(即服务端的类引用)并不是实际真实的远程Binder对象，我们的引用在Binder驱动里还要做一次映射。也就是说，设备驱动根据我们的引用对象找到对应的远程进程。客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数，transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存，把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数，这个函数也是属于Binder类。远程进程Binder对象执行完成后，将得到的写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。&lt;/p&gt;
&lt;h3 id=&#34;binder机制运用&#34;&gt;Binder机制运用&lt;/h3&gt;
&lt;p&gt;好了，现在对Binder机制已经理解了，我们再看看Android是怎么运用Binder的。再现前面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//获取WindowManager服务引用
WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);  
//布局参数layoutParams相关设置略...
View view=LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, null);  
//添加view
wm.addView(view, layoutParams);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码前面已经出现过。getSystemService(getApplication().WINDOW_SERVICE);函数内部原理就是向ServiceManager查询标识符为getApplication().WINDOW_SERVICE的远程对象的引用。即WindowManager对象的引用，这个引用的真正实现是WindowManager的某个代理。得到这个引用后，在调用addView时，真正的实现是在代理里面，代理把参数打包到Parcel对象中，然后调用transact函数（该函数继承自Binder），再触发Binder驱动的一系列调用过程，在Binder驱动实现原理一节中有具体介绍，忘记了的同学可以返回继续看。关于Binder的代理对象，可以参考AIDL工具生成的代码，这里不再具体介绍。&lt;/p&gt;
">简单明了，彻底地理解Binder</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/ying-jian-jia-su-setlayertype/"" data-c="
          &lt;p&gt;从Android 3.0开始，Android的2D渲染管线可以更好的支持硬件加速。硬件加速使用GPU进行View上的绘制操作。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;硬件加速可以在一下四个级别开启或关闭：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Application&lt;/li&gt;
&lt;li&gt;Activity&lt;/li&gt;
&lt;li&gt;Window&lt;/li&gt;
&lt;li&gt;View&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;application级别&#34;&gt;Application级别&lt;/h3&gt;
&lt;p&gt;往您的应用程序AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启硬件加速：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;application android:hardwareAccelerated=&amp;quot;true&amp;quot; ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;activity级别&#34;&gt;Activity级别&lt;/h3&gt;
&lt;p&gt;您还可以控制每个activity是否开启硬件加速，只需在activity元素中添加android:hardwareAccelerated属性即可办到。比如下面的例子，在application级别开启硬件加速，但在某个activity上关闭硬件加速。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;application android:hardwareAccelerated=&amp;quot;true&amp;quot;&amp;gt;    
	&amp;lt;activity ... /&amp;gt;    
	&amp;lt;activity android:hardwareAccelerated=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;/application&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;window级别&#34;&gt;Window级别&lt;/h3&gt;
&lt;p&gt;如果您需要更小粒度的控制，可以使用如下代码开启某个window的硬件加速：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getWindow().setFlags(    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：目前还不能在window级别关闭硬件加速。&lt;/p&gt;
&lt;h3 id=&#34;view级别&#34;&gt;View级别&lt;/h3&gt;
&lt;p&gt;您可以在运行时用以下的代码关闭单个view的硬件加速：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：您不能在view级别开启硬件加速&lt;/p&gt;
">硬件加速 setlayertype</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/fu-chuang-kai-fa-zhi-chuang-kou-ceng-ji/"" data-c="
          &lt;p&gt;转载自:&lt;a href=&#34;http://www.liuguangli.win/archives/476&#34;&gt;http://www.liuguangli.win/archives/476&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;最近在项目中遇到了这样的需求：需要在特定的其他应用之上悬浮自己的UI交互（拖动、输入等复杂的UI交互），和九游的浮窗类似，不过我们的比九游的体验更好，我们越过了很多授权的限制。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;很多人都知道如何去实现一个简单的浮窗，但是却很少有人去深入的研究背后的流程机制，由于项目中浮窗交互比较复杂，遇到了些坑查看了很多资料，故总结浮窗涉及到的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窗口层级关系（浮窗是如何“浮”的）？&lt;/li&gt;
&lt;li&gt;浮窗有哪些限制，如何越过用户授权实现浮窗功能？&lt;/li&gt;
&lt;li&gt;窗口与用户输入系统（Activity是如何接收到touch事件?）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本章我们来研究第一个问题:浮窗为何会浮。浮窗之所以叫浮窗，是因为它能悬浮于应用或者桌面窗口之上，能脱离Activity而存在。为了研究其中区别，我们先来看看我们最熟悉的Activity是怎么显示出来的。&lt;/p&gt;
&lt;h3 id=&#34;activity是怎么显示出来的&#34;&gt;Activity是怎么显示出来的？&lt;/h3&gt;
&lt;p&gt;要弄清这个问题答案，我们先从Activity的setContentView()这个方法的源码开始找起，在Activity中看到setCententView的源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void setContentView(int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getWindow是返回返回Activity的mWindow变量，指向一个Window的对象，Window是一个抽象类，这里返回的是PhoneWindow对象（PhoneWindow是Window的子类），PhoneWindow中有一个DecorView对象，decorView成员，这是一个FrameLayout，setContentView的子布局最终会添加到decorView中,这个decorView就是当前窗口的根视图,这个根视图是如何最终被绘制出来的？在ActivityThread中有这样一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
l.softInputMode |= forwardBit;
if (a.mVisibleFromClient) {
    a.mWindowAdded = true;
    wm.addView(decor, l);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个decorView，最终会被WindowManager.addView添加到绘制系统中,并类型是WindowManager.LayoutParams.TYPE_BASE_APPLICATION，这个参数决定了要绘制的窗口的z轴层次，为了避免思维栈过深，这里就不贴出详细的源码跟踪过程了，直接给结论。&lt;/p&gt;
&lt;p&gt;先来看看Activity和window的关系：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202835.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;再来window和View的关系：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Activity窗口显示过程：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;说Activity是怎么显示出来的，其实是说Activity管理的View是怎么显示出来的。最后再来总结一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Activity通过setContentView设置的视图是添加到PhoneWindow的根视图decor中。&lt;/li&gt;
&lt;li&gt;Window是一个抽象的概念，Window关了了一个View（根视图），最终被WindowManager管理的还是一个View（根视图）和它的LayoutParams，视图绘制刷新都是通过WindowManager（WindowManagerGlobal）与WindowManagerServiceIPC交互调用底层绘制的。&lt;/li&gt;
&lt;li&gt;Activity是四大组件中唯一和窗体紧密联系的组件（这是为什么会有初学者把Activity直接理解为绘制界面的原因），所有掌管的视图只不过是一种window和Dialog、Toast、墙纸所掌管的Window类型不一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;浮窗为什么会浮&#34;&gt;浮窗为什么会“浮”？&lt;/h3&gt;
&lt;p&gt;上面讲到Activity的显示过程其实已经揭示了通用界面的显示过程，浮窗的显示过程更为简单：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
做过浮窗的同学应该都明白了，为啥浮窗能脱离Activity而显示，本质上我们是把一个View交给WindowManager来管理了，LayoutParams.type类型决定了这个View显示窗口的类型，不同类型显示的窗口层次（z轴）是不一样的。大方面来讲可以分为应用窗口（APPLICATION_WINDOW）、子窗口（SUB_WINDOW）、系统窗口（SYSTEM_WINDOW）三种类型，应用窗口z轴范围是1～99，子窗口的范围是1001～1999，系统窗口是（2000～2999），所以要实现浮动窗口我们只能在系统窗口范围中实现。&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119203018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;到这里我们对Android系统的窗口层次有个大致的了解了，Activity是Android应用的四大组件之一，描述的是应用的活动状态和周期，受ActivityManagerService的管理；Window／View是图形窗口的抽象模型，描述的是窗口的绘制信息，受WindowManagerService的管理；Activity聚合Window来和图形窗口产生联系。&lt;/p&gt;
">浮窗开发之窗口层级</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/mei-ge-cheng-xu-yuan-du-bi-du-de-10-pian-wen-zhang/"" data-c="
          &lt;p&gt;作为一名Java程序员和软件开发人员，那些每个程序员都应该知道的XXX的文章教会了我不少东西，它们提供了某个特定领域的一些实用的并且有深度的信息，这些东西通常很难找到。&lt;!--more--&gt;在我学习的过程中我读到过许多非常有用的文章，我把它们添加到了书签里，方便以后阅读或者引用。我个人认为所有开发人员都能从这些文章中受益，因此我也写了篇“每个程序员都应该了解的”文章，准备分享给你们。这是我的个人收藏。在这篇文章中，你会看到每个程序员都应该了解的一些经典文章，涵盖了内存，unicode，浮点数，网络，面向对象设计，时间，URL编码，字符串等话题。这个列表对初学者和新手来说非常重要，因为他们现在缺的正是实战的经验。而这些文章正好是实践相关的，他们可以从中学到很多东西。在职业生涯的初级，早点了解一些基础的知识有助于今后避免犯错，这些坑已经被其他的程序员和软件开发人员在他们学习的过程中踩过了。你可能还搞不明白浮点数的一些细节，或者被内存的细节弄得晕头转向，不过将这份列表保留在手边还是很有必要的，在适当的时候可以时不时的参考下。祝你好运，希望你能喜欢这些文章。顺便提一句，如果有任何的程序员必读系列的文章没在这个列表中，别忘了分享一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.akkadia.org/drepper/cpumemory.pdf&#34; title=&#34;程序员必知之内存篇&#34;&gt;程序员必知之内存篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是篇非常经典的文章，它将会带领你走入内存的各个方面，有老的，也有新的，有知道的，也有不知道的。尽管内存十分常见，无处不在，但并不是每个程序员都足够了解它。如果你正在编写高性能的应用程序的话，了解现代系统中的内存尤为重要。硬件设计师们带来了更复杂的内存处理及加速的技术，比如说CPU缓存，但如果离开了程序员它们也无法发挥出最大的价值。我仍在阅读这篇文章，很难说清楚我到底从中学到了多少关于随机访问内存（RAM），CPU缓存，包括1级，2级缓存，不同类型的内存，直接内存访问，内存控制器设计及普通内存的知识。简而言之，它是各个层次的程序员都必读的文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&#34;&gt;每个计算机科学家都必知之浮点数运算&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浮点数运算是一个非常有技术含量的话题，不太容易掌握。许多Java程序员都不清楚使用==操作符比较float/double类型的话到底出现什么问题。许多人在使用float/double进行货币计算的时候经常会犯错。这篇文章是这一系列中的精华，所有的软件开发人员都应该读一下。随着你经验的增长，你肯定想去深入了解一些常见的东西的细节，浮点数运算就是其中之一。作为一名Java高级开发人员，你必须了解如何进行货币运算，何时使用float,double或者BigDecimal，如何对浮点数进行舍入运算等等。就算你知道了浮点数运算的一些基础知识，读下这篇文章，你肯定还会学到一些新的东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.joelonsoftware.com/articles/Unicode.html&#34;&gt;每个程序员必知之Unicode篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符编码是另一个许多程序员痛苦挣扎的领域，”每一个程序员都绝对绝对应该了解Unicode以及字符集（不许找任何借口！）“填补了这一空白。标注一下，是的，这就是这篇文章的标题。它是由stackoverflow.com的创始人之一，Joel Spolsky所写的。Joel10年前就在他的博客上发表了这篇文章，不过对于现在而言仍然适用。这篇文章会告诉你什么是Unicode，什么是字符编码，字符是如何通过字节来表示的等等。这篇文章最赞的一点就是它的语言及行文，尽管你根本不知道什么是Unicode，你也能够很容易地看懂。一句话，这又是一篇程序员，码农，软件工程师必读的文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://unix4lyfe.org/time/?v=1&#34;&gt;每个程序员必知之时间篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了字符编码外，时间和日期又是另一个程序员经常栽倒的领域，包括我自己在内。甚至是高级开发人员也会被格林尼治标准时间（GMT），世界标准时间（UTC），夏令时，闰秒这些东西搞的死去活来。坦白地说，在处理时区这个问题上，很难不踩一些坑，更别说再加上夏令时什么的。如果你想要试错法的话则更糟糕，因为这么做永远也解决不了你的问题。这里有许多可能出错或者产生误解的地方。比方说，日期是否包括时区可能就会困扰到你，将UNIX时间转化成其它的时区可能会让你崩溃，你还是忘了时钟同步和延迟这些事吧。我希望读完这篇经典的文章后，你的许多关于时间的误解都能够消除，自己能够巩固一些关于日期的基础常识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding&#34;&gt;每个WEB开发人员必知之URL编码篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章介绍了Uniform Resource Locator(URL）编码中的一些常见的误解，然后试图阐明什么是HTTP的URL编码，最后列举了一些常见的错误及解决方案。尽管这篇文章的内容并不特定于某种编程语言，但它是用Java来进行问题的描述，并修复URL编码中存在的问题。你会学习到URL的基础语法，HTTP及其它协议中通用的URL格式。这篇文章还介绍了URL中的一些常见错误，比如字符编码，URL不同部分的保留字符，以及URL编解码问题。如果你是一名Java开发人员，你会学习到如何在Java中正确地处理URL，如何构造URL，以及如何使用Apache Common Http client库。最后它还提供了一些最佳实践的建议，比如你应该在构建URL的时候进行编码，确保你的重写URL的过滤器正确地处理了URL，等等。这是任何WEB开发人员必读的文章 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://programmers.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before&#34;&gt;每个程序员必知之WEB开发&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是programmers.stackexchange.com上的一篇非常有趣的文章，它讲的是程序员在将网站对外发布之前需要实现的技术细节。这包括接口设计及用户体验，安全性，WEB标准，性能，搜索引擎优化(SEO），以及一些重要的资源。当今世界严重地依赖于互联网，很多程序员都有自己的网站，通常是一个博客。这篇文章中学到的东西可能对你的专业没有帮助，但它对你个人的事情肯定会有所帮助。你会了解到一些关键的技术，比如HTML,HTTP,XML,CSS，JavaScript,浏览器兼容性，减少网站加载时间的技巧，XML站点地图，W3C规范，以及许多其它的关键的细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://katemats.com/what-every-programmer-should-know-about-seo/&#34;&gt;每个程序员必知之SEO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这对WEB开发人员，程序员，博主而言又是一篇很重要的文章。由于很多程序员同时也是博主，你无法对SEO视而不见，学一个搜索引擎优化的基础知识还是非常重要的，这能帮助Google检索到你的内容并推荐给其它程序员。在今天这个网络互联的时代，没有任何公司可以脱离WEB而存在，SEO变得尤为重要。如果你有一家初创企业在卖一些产品，那么SEO就是你要关注的事情。所有程序员，尤其是WEB开发人员，都可以从这篇文章中受益良多。记住，SEO是一个很宽泛变化的题目，不同的搜索引擎，比如Google，Yahoo等，它们的SEO都各不相同。因此，要想掌握这项技能你得经常更新你的知识库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.deepinmind.com/blog/2014/05/15/what-every-c-programmer-should-know.html&#34;&gt;C程序必知的未定义行为&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C语言有一个未定义行为的概念。未定义行为是一个很宽泛的主题，它有许多细微的差别，这就是为什么我喜欢Java的一个原因，没有这么多的未定义行为，没有这么多的困惑，更稳定也更消停。很多人看起来很自然的事情在C里其实是未定义的行为，这也是程序BUG的一个常见的来源。除此之外，C中的任何未定义行为都由具体实现来决定（编译器和运行时），它们生成的代码会格式化你硬盘，做一些意想不到的事情，甚至更糟。读下这篇文章，到未定义行为的海洋里遨游吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/&#34;&gt;程序员必知之网络&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这段话摘自这篇文章，”你是一个程序员。你有想过多玩家的游戏是如何实现的吗？从外面看起来它是：两个或多个玩家通过网络共享相同的经验，就像他们在同一个虚拟世界中一样。不过作为程序员，我们知道底下的真相和你看到的东西是有所区别的。事实上这都只是一个错觉“。这是篇关于网络的非常有趣的文章，它是为游戏开发人员而写的，不过我认为每个程序开发人员都能从中受益。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.deepinmind.com/blog/2014/05/15/java-string-tutorial-and-examples-beginners-programming.html&#34;&gt;Java程序员必知之String&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是我自己关于java.lang.String的一篇文章，我个人认为每个Java开发人员都应该了解一下。String在日常的Java开发中非常重要，这就是为什么每个Java程序员都应该对它非常了解。这篇文章涉及到了String的许多重要的领域，包括String池，字符串常量，使用==和equals比较字符串，将字节数组转化成String，为什么字符串是不可变的，如何正确拼接字符串，等等。高级程序员应该都知道这些东西了，不过回顾一下也是不错的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/2794016/what-should-every-programmer-know-about-security&#34;&gt;程序员必知之安全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一个计算机系的学生在StackOverFlow上问了这个问题。就像我们了解到的一些常见编程概念比如操作系统，算法，数据结构，计算机体系结构，以及其它东西一样，了解安全也同样重要。安全是一个很大的话题，包括加密解密，SSL，WEB安全，混淆，认证，授权，等等，它是每个程序员都应该了解的基础知识。刚进这行的时候，我个人对安全这块还不是很了解，这时候我就开始基于Servlet/JSP写一些的Java WEB程序，后来我才了解到EWB安全性以及一些安全威胁比如SQL注入，拒绝服务，XML注入，跨站脚本，等等。作为一名Java开发人员，我现在遵循fortify, PMP，以及其它一些静态代码分析器提供的Java安全编码规范进行编码。这篇文章是关于安全这个主题的一个很好的合集，不管你现在还写不写代码，这些资源对你来说都非常有用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eecs.berkeley.edu/~rcs/research/interactive_latency.html&#34;&gt;程序员必知之延迟时间&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章是一份额外的福利，但也是每个程序员都应该读的。不管用的是什么语言，Java还是C++都好，要写出高性能的应用程序，你都得了解延迟时间的基础常识，比如从内存中读取一个变量需要多久，从一级缓存中读取又需要多久，二级缓存呢，SSD硬盘中随机读又需要多久，还有要是从磁盘中读呢？互斥锁的加锁解锁需要多长时间，从一个城市发送一个数据包到另一个城市需要多长时间，在同一个数据中心又需要多久？这些延迟的数字是独立于任何编程语言的，开发人员必须要想写高频低延迟的应用程序，它们是核心知识库中的一部分。这篇文章还有一个好消息就是，它会告诉你这些年以来这些延迟时间的变化。你可以看到2006年的延迟时间是多少，而现在又是多少。&lt;/p&gt;
&lt;p&gt;这就是所有程序员必读文章的列表。看到这些文章的标题，每个程序员都应该知道的XXX，你能了解到关于某个主题的一些比较有深度的知识。坦白说程序员有太多东西要学了，像学习Java语言这种只是冰山的一角，但并不是所有人都有热情去学习。写程序是一份很有挑战的工作，在你的职业生涯中，能帮忙到你的就是这些基础知识，比如，内存，Unicode，浮点数，时间，安全，这些对任何程序员来说都非常重要。有些文章是和语言相关的，比如我自己那篇关于String的文章，还有每个C程序员都应该了解的未定义行为，不过对于许多初学者来说学习一下也有好处。&lt;/p&gt;
&lt;p&gt;译注：我觉得还有一个必读的，就是数数，这里一共是12篇了。。有几篇访问不了的，我也搬运到自己的博客上了。&lt;/p&gt;
&lt;p&gt;原创文章转载请注明出处：&lt;a href=&#34;http://it.deepinmind.com/others/2014/05/15/10-articles-every-programmer-must-read.html&#34;&gt;每个程序员都必读的10篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://javarevisited.blogspot.sg/2014/05/10-articles-every-programmer-must-read.html&#34;&gt;英文原文链接&lt;/a&gt;&lt;/p&gt;
">每个程序员都必读的10篇文章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/shu-mei-pai-an-zhuang-nginxphp5sqlite3-yun-xing-typecho/"" data-c="
          &lt;p&gt;环境说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件:RasyberryPi 2B&lt;/li&gt;
&lt;li&gt;系统：&lt;a href=&#34;http://pan.baidu.com/s/1pJqQxHD&#34;&gt;raspbian-wheezy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Blog站：&lt;a href=&#34;http://pan.baidu.com/s/1o61bO6Y&#34;&gt;Typecho 1.0（14.10.10）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;操作步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装nginx,先更新一下软件源（建议修改镜像源为国内镜像，速度会快很多）&lt;br&gt;
&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;br&gt;
更新过后就可以安装nginx了&lt;br&gt;
&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装sqlite3&lt;!--more--&gt;&lt;br&gt;
&lt;code&gt;sudo apt-get install sqlite3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装php&lt;br&gt;
PHP5&lt;br&gt;
&lt;code&gt;sudo apt-get install php5-fpm&lt;/code&gt;&lt;br&gt;
php5数据库&lt;br&gt;
&lt;code&gt;sudo apt-get install php5-sqlite&lt;/code&gt;&lt;br&gt;
php优化&lt;br&gt;
&lt;code&gt;sudo apt-get install php-apc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置nginx的php支持&lt;br&gt;
备份nginx的默认配置&lt;br&gt;
&lt;code&gt;sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak&lt;/code&gt;&lt;br&gt;
然后就可以放心的修改了&lt;br&gt;
&lt;code&gt;sudo nano /etc/nginx/sites-available/default&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面这一行将前面的#号去掉，变成：&lt;br&gt;
&lt;code&gt;listen 80; ## listen for ipv4;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面这一行需要增加一句index.php&lt;br&gt;
&lt;code&gt;index index.html index.htm;&lt;/code&gt;&lt;br&gt;
变成&lt;br&gt;
&lt;code&gt;index index.php index.html index.htm;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接着往下翻页继续修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#location ~ \.php$ {
# fastcgi_split_path_info ^(.+\.php)(/.+)$;
# # NOTE: You should have &amp;quot;cgi.fix_pathinfo = 0;&amp;quot; in php.ini
#
# # With php5-cgi alone:
# fastcgi_pass 127.0.0.1:9000;
# # With php5-fpm:
# fastcgi_pass unix:/var/run/php5-fpm.sock;
# fastcgi_index index.php;
# include fastcgi_params;
#}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!-e $request_filename) {
rewrite ^(.*)$ /index.php$1 last;
}
location ~ \.php$ {
# fastcgi_split_path_info ^(.+\.php)(/.+)$;
# # NOTE: You should have &amp;quot;cgi.fix_pathinfo = 0;&amp;quot; in php.ini
#
# # With php5-cgi alone:
# fastcgi_pass 127.0.0.1:9000;
# # With php5-fpm:
fastcgi_pass unix:/var/run/php5-fpm.sock;
fastcgi_index index.php;
include fastcgi_params;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;测试php&lt;br&gt;
&lt;code&gt;sudo nano /etc/share/nginx/www/test.php&lt;/code&gt;&lt;br&gt;
输入如下内容：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
phpinfo();
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启nginx，和php5-fpm&lt;br&gt;
&lt;code&gt;sudo /etc/init.d/nginx restart&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo /etc/init.d/php5-fpm restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;局域网的电脑中输入树莓派的ip地址查看是否成功&lt;br&gt;
&lt;code&gt;http://192.169.1.102/test.php&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;上传并配置typecho权限&lt;br&gt;
修改&lt;code&gt;www&lt;/code&gt;目录权限，使网页文件能正常上传。&lt;br&gt;
&lt;code&gt;sudo chmod 777 /usr/share/nginx/www&lt;/code&gt;&lt;br&gt;
使用&lt;a href=&#34;http://pan.baidu.com/s/1sjJSCWl&#34;&gt;winscp&lt;/a&gt;工具上传到nginx的默认目录&lt;br&gt;
修改typecho的文件夹权限，以便之后的安装能够顺利进行。&lt;br&gt;
&lt;code&gt;sudo chmod 777 /usr/share/nginx/www/usr&lt;/code&gt;&lt;br&gt;
修改后台上传默认文件夹的权限，使后台能够上传附件。&lt;br&gt;
&lt;code&gt;sudo chmod 777 /usr/share/nginx/www/usr/uploads&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置typecho&lt;br&gt;
在浏览器上面输入树莓派IP地址，进行初始化安装。数据库会自动创建，我们仅需输入初始的账号和密码即可。完成后进入后台修改永久链接，根据需要可开启地址重写功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
"> 树莓派安装nginx+php5+sqlite3运行Typecho</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/ru-he-jie-jue-android-50-zhong-chu-xian-de-jing-gao-service-intent-must-be-explitict/"" data-c="
          &lt;p&gt;有些时候我们使用Service的时需要采用隐私启动的方式，但是Android 5.0一出来后，其中有个特性就是Service Intent  must be explitict，也就是说从Lollipop开始，service服务必须采用显示方式启动。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;而android源码是这样写的（源码位置：sdk/sources/android-21/android/app/ContextImpl.java）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void validateServiceIntent(Intent service) {
    if (service.getComponent() == null &amp;amp;&amp;amp; service.getPackage() == null) {
        if (getApplicationInfo().targetSdkVersion &amp;gt;= Build.VERSION_CODES.LOLLIPOP) {
            IllegalArgumentException ex = new IllegalArgumentException(
                    &amp;quot;Service Intent must be explicit: &amp;quot; + service);
            throw ex;
        } else {
            Log.w(TAG, &amp;quot;Implicit intents with startService are not safe: &amp;quot; + service
                    + &amp;quot; &amp;quot; + Debug.getCallers(2, 3));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然，源码里是这样写的，那么这里有两种解决方法：&lt;/p&gt;
&lt;p&gt;1、设置Action和packageName：&lt;/p&gt;
&lt;p&gt;参考代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Intent mIntent = new Intent();
mIntent.setAction(&amp;quot;XXX.XXX.XXX&amp;quot;);//你定义的service的action
mIntent.setPackage(getPackageName());//这里你需要设置你应用的包名
context.startService(mIntent);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此方式是google官方推荐使用的解决方法。&lt;/p&gt;
&lt;p&gt;2、将隐式启动转换为显示启动： --参考地址： http://stackoverflow.com/a/26318757/1446466&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Intent getExplicitIntent(Context context, Intent implicitIntent) {
    // Retrieve all services that can match the given intent
    PackageManager pm = context.getPackageManager();
    List&amp;lt;ResolveInfo&amp;gt; resolveInfo = pm.queryIntentServices(implicitIntent, 0);
    // Make sure only one match was found
    if (resolveInfo == null || resolveInfo.size() != 1) {
        return null;
    }
    // Get component info and create ComponentName
    ResolveInfo serviceInfo = resolveInfo.get(0);
    String packageName = serviceInfo.serviceInfo.packageName;
    String className = serviceInfo.serviceInfo.name;
    ComponentName component = new ComponentName(packageName, className);
    // Create a new intent. Use the old one for extras and such reuse
    Intent explicitIntent = new Intent(implicitIntent);
    // Set the component to be explicit
    explicitIntent.setComponent(component);
    return explicitIntent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是使用上面这段代码解决了出错的问题&lt;/p&gt;
&lt;p&gt;调用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Intent mIntent = new Intent();
mIntent.setAction(&amp;quot;XXX.XXX.XXX&amp;quot;);
Intent eintent = new Intent(getExplicitIntent(mContext,mIntent));
context.startService(eintent);
&lt;/code&gt;&lt;/pre&gt;
">如何解决Android 5.0中出现的警告：Service Intent must be explitict</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/duo-tai-ji-zi-gong-tong-wei-hu-hexo-bo-ke/"" data-c="
          &lt;p&gt;转自CrazyMilk.&lt;a href=&#34;http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/&#34;&gt;GitHub Pages + Hexo搭建博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(&lt;sup&gt;▽&lt;/sup&gt;)o ）。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦(╬▔皿▔)凸）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。&lt;br&gt;
但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(ˉ▽ˉ；)…）。&lt;br&gt;
所以，我利用了分支！！！&lt;br&gt;
简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。&lt;br&gt;
下面以我的博客作为例子详细地讲述。&lt;/p&gt;
&lt;h3 id=&#34;1博客搭建流程&#34;&gt;1.博客搭建流程&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;创建仓库，CrazyMilk.github.io；&lt;/li&gt;
&lt;li&gt;创建两个分支：master 与 hexo；&lt;/li&gt;
&lt;li&gt;设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；&lt;/li&gt;
&lt;li&gt;使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库；&lt;/li&gt;
&lt;li&gt;在本地CrazyMilk.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;&lt;/li&gt;
&lt;li&gt;修改_config.yml中的deploy参数，分支应为master；&lt;/li&gt;
&lt;li&gt;依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；&lt;/li&gt;
&lt;li&gt;执行hexo generate -d生成网站并部署到GitHub上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！&lt;/p&gt;
&lt;h3 id=&#34;2管理流程&#34;&gt;2.管理流程&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1日常修改&#34;&gt;1.日常修改&lt;/h4&gt;
&lt;p&gt;在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；&lt;/li&gt;
&lt;li&gt;然后才执行hexo generate -d发布网站到master分支上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。&lt;/p&gt;
&lt;h4 id=&#34;2本地资料丢失&#34;&gt;2.本地资料丢失&lt;/h4&gt;
&lt;p&gt;当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；&lt;/li&gt;
&lt;li&gt;在本地新拷贝的CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;备注&#34;&gt;备注&lt;/h3&gt;
&lt;p&gt;问题总出现在上传博客的时候,固把_config.yml中git参数记录在这里.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;deploy:
  type: git
  repository: ssh://git@github.com/yeqiling/yeqiling.github.io.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;
">多台机子共同维护hexo博客</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/jian-guo-yun-gityou-xiao-guan-li-nin-de-dai-ma/"" data-c="
          &lt;p&gt;不少程序员用户，直接将自己的代码放在坚果云同步文件夹中，每次修改自动同步，这样做有几个问题：&lt;/p&gt;
&lt;!--more--&gt;
&lt;ul&gt;
&lt;li&gt;坚果云的版本历史是自动保存的，不能添加版本信息。对于代码而言，不方便找回和比对历史代码；&lt;/li&gt;
&lt;li&gt;专业的代码管理工具（Git/Hg）能够很容易查看用户对所有代码进行的每次修改，易于分析bug的来源。而坚果云不能提供这样的功能。&lt;/li&gt;
&lt;li&gt;如果将eclipse, Visual Studio等IDE的workspace直接放于坚果云中，假如同步不及时造成冲突，而IDE自动生成文件的冲突无法解决，可能导致IDE无法正常打开。&lt;/li&gt;
&lt;li&gt;编译，重构等自动化工作引发的同步，容易导致大量的带宽占用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，我们推荐用如下的方法利用坚果云同步代码，可以完全保留代码管理工具的长处，同时利用坚果云提供的自动同步和备份功能。 对于初学者，我们推荐使用hg管理代码，因为其更简单易学。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;假设你用的是Git，当前的开发目录叫“&lt;sub&gt;/projects”，而坚果云路径为“&lt;/sub&gt;/Nutstore”，进行如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;~/projects $&amp;gt;git init            （注释：初始化git repository）&lt;/li&gt;
&lt;li&gt;~/projects $&amp;gt; git add .&lt;/li&gt;
&lt;li&gt;~/projects $&amp;gt; git commit -m “first commit”&lt;/li&gt;
&lt;li&gt;~/projects $&amp;gt; mkdir -p ~/Nutstore/git/project.git  （注释：在坚果云中创建bare git repository）&lt;/li&gt;
&lt;li&gt;~/projects $&amp;gt; cd ~/Nutstore/git/project.git&lt;/li&gt;
&lt;li&gt;~/Nutstore/git/project.git $&amp;gt; git init –bare&lt;/li&gt;
&lt;li&gt;~/Nutstore/git/project $&amp;gt; cd ~/project   （注释：push代码到坚果云中）&lt;/li&gt;
&lt;li&gt;~/project $&amp;gt; git remote add orig ~/Nutstore/git/project.git&lt;/li&gt;
&lt;li&gt;~/project $&amp;gt; git push orig master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样在所有电脑上都可以正常的进行git pull &amp;amp; git push，以后每次修改代码只需commit，然后将代码push到~/Nutstore/git/project即可享受到git+坚果云的所有好处。如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;~/project $&amp;gt; git push orig master&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也可以在~/Nutstore/git/project.git 下定期运行GC(垃圾回收），减少文件数目和节约空间，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;~/Nutstore/git/project.git&amp;gt; git gc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面是坚果云官网写的如何同步,那么接下来我写下如何在其他电脑上使用.假如你的坚果云路径为“&lt;sub&gt;/Nutstore”,而你的开发目录为“&lt;/sub&gt;/projects”.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;~/projects $&amp;gt;git clone ~/Nutstore/project.git&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后就可以用各种各样的git操作了.相当于你有两个本地服务器.每次都提交到本地服务器了,然后坚果云来保持你这两个服务器文件一致性.&lt;/p&gt;
&lt;p&gt;我感觉这同步盘的想法真是nice.这样我们就可以自己搭建私有服务器了.&lt;/p&gt;
&lt;p&gt;最近360云盘已经不行了,数据都需要自己备份.而同步盘则不需要担心数据备份的问题.因为数据你自己本地就有一份.唯一需要担心的是同步功能什么时候会收费或者取消.23333&lt;/p&gt;
">坚果云+git，有效管理您的代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/guan-yu-na-xie-android-zhong-bu-chang-yong-de-she-zhi-shu-xing/"" data-c="
          &lt;p&gt;很多在manifest中的属性我们经常遗忘了它们，或者经常看到但又不是很明白它的作用。那么在这里我就拿了一些属性简单的解释一下，防止以后碰到却不知道其中的意思。不是很全，以后会断断续续的补充吧&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;一-androidinstalllocationinternalonly&#34;&gt;一、android:installLocation=&#39;internalOnly&#39;&lt;/h3&gt;
&lt;p&gt;android:installLocation隶属于AndroidManifest.XML中的manifest节点.如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;manifest xmlns:android=&#39;http://schemas.android.com/apk/res/android&#39;
	package=&#39;string&#39;
	android:sharedUserId=&#39;string&#39;
	android:sharedUserLabel=&#39;string resource&#39;
	android:versionCode=&#39;integer&#39;
	android:versionName=&#39;string&#39;
	android:installLocation=[&#39;auto&#39; | &#39;internalOnly&#39; | &#39;preferExternal&#39;] &amp;gt;
	. . .
&amp;lt;/manifest&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;android:installLocation可以设置为&#39;auto&#39;、&#39;internalOnly&#39;、&#39;preferExternal&#39;三个值中的任何一个.&lt;/p&gt;
&lt;p&gt;auto:程序可能被安装在外部存储介质上(例如:SD Card),但是默认会被安装到手机内存中.当手机内存为空时,程序将被安装到外部存储介质上.当程序安装到手机上后,用户可以决定把程序放在外部储介质还是内存中.&lt;/p&gt;
&lt;p&gt;internalOnly:默认值.当设置为该值时,程序只能被安装在内存中,如果内存为空,则程序将不能成功安装.&lt;/p&gt;
&lt;p&gt;preferExternal:将程序安装在外部存储介质上,但是系统不保证程序一定会被安装到外部存储介质上.当外部存储介质不可以或空时,程序将被安装到内存中.程序使用了forward-locking机制时也将被安装到内存中,因为外部存储不支持此机制.程序安装后,用户可以自由切换程序应该在外部还是内部存储介质上.&lt;/p&gt;
&lt;p&gt;简而言之，就是控制应用是安装在外部存储上还是内存中，安装在内存中&lt;br&gt;
①Service&lt;/p&gt;
&lt;p&gt;正在运行的服务将被终止,当外部存储介质被重新加载时服务不会被重启.&lt;/p&gt;
&lt;p&gt;②Alarm Service&lt;/p&gt;
&lt;p&gt;闹钟服务将被取消,开发者必须在外部存储介质重新加载后重新注册闹钟服务.&lt;/p&gt;
&lt;p&gt;③Input Method Engines&lt;/p&gt;
&lt;p&gt;输入法将被换成系统输入法,当外部存储介质被重新加载后用户可以通过系统设置来启动我们的输入法&lt;/p&gt;
&lt;p&gt;④Live Wallpapers&lt;/p&gt;
&lt;p&gt;我们的动态壁纸将被替换为默认的动态壁纸.外部存储介质重载后,用户可以更换回来.&lt;/p&gt;
&lt;p&gt;⑤Live Folders&lt;/p&gt;
&lt;p&gt;我们的动态文件夹将被移出.&lt;/p&gt;
&lt;p&gt;⑥App Widgets&lt;/p&gt;
&lt;p&gt;我们的小部件将被移出,通常只有系统重启后我们的小部件才可用.&lt;/p&gt;
&lt;p&gt;⑦Account Managers&lt;/p&gt;
&lt;p&gt;使用AccountManager创建的账户将会消失,直至存储介质被重新加载.&lt;/p&gt;
&lt;p&gt;⑧Sync Adapters&lt;/p&gt;
&lt;p&gt;只有外部存储介质被重新加载时,我们的同步功能才可用&lt;/p&gt;
&lt;p&gt;⑨Device Administrators&lt;/p&gt;
&lt;p&gt;我们的DeviceAdminReceiver将会失效&lt;/p&gt;
&lt;p&gt;⑩监听开机结束事件&lt;/p&gt;
&lt;p&gt;系统会在加载外部存储介质之前发送ACTION_BOOT_COMPLETED广播.因此安装在外部存储介质的程序将不能接受开机广播.&lt;/p&gt;
&lt;h3 id=&#34;二-androidversioncode&#34;&gt;二、android:versionCode&lt;/h3&gt;
&lt;p&gt;Google为APK定义了两个关于版本属性：VersionCode和VersionName，他们有不同的用途。&lt;/p&gt;
&lt;p&gt;VersionCode：对消费者不可见，仅用于应用市场、程序内部识别版本，判断新旧等用途。 VersionName：展示给消费者，消费者会通过它认知自己安装的版本，下文提到的版本号都是说这个&lt;/p&gt;
&lt;h3 id=&#34;三-androidprotectionlevelsignature&#34;&gt;三、android:protectionLevel=&#39;signature&#39;&lt;/h3&gt;
&lt;p&gt;normal：低风险权限，只要申请了就可以使用（在AndroidManifest.xml中添加&lt;uses-permission&gt;标签），安装时不需要用户确认；&lt;br&gt;
dangerous：高风险权限，安装时需要用户的确认才可使用；&lt;br&gt;
signature：只有当申请权限的应用程序的数字签名与声明此权限的应用程序的数字签名相同时（如果是申请系统权限，则需要与系统签名相同），才能将权限授给它；&lt;br&gt;
signatureOrSystem：签名相同，或者申请权限的应用为系统应用（在system image中）。&lt;/p&gt;
&lt;p&gt;上述四类权限级别同样可用于自定义权限中。如果开发者需要对自己的应用程序（或部分应用）进行访问控制，则可以通过在AndroidManifest.xml中添加&lt;permission&gt;标签，将其属性中的protectionLevel设置为上述四类级别中的某一种来实现。&lt;br&gt;
A方：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 声明权限 --&amp;gt; 
&amp;lt;permission android:name=&#39;com.example.testbutton.RECEIVE&#39; /&amp;gt; 
&amp;lt;!-- 注册Broadcast Receiver，并指定了给当前Receiver发送消息方需要的权限 --&amp;gt; 
&amp;lt;receiver 
	android:name=&#39;com.example.testbutton.TestButtonReceiver&#39; 
	android:permission=&#39;com.example.testbutton.RECEIVE&#39; &amp;gt; 
		&amp;lt;intent-filter&amp;gt; 
		&amp;lt;action android:name=&#39;com.test.action&#39; /&amp;gt; 
		&amp;lt;/intent-filter&amp;gt; 
&amp;lt;/receiver&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B方：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 声明使用指定的权限 --&amp;gt; 
&amp;lt;uses-permission android:name=&#39;com.example.testbutton.RECEIVE&#39; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;四-uses-feature&#34;&gt;四、uses-feature&lt;/h3&gt;
&lt;p&gt;Android Market会根据uses-feature过滤所有你设备不支持的应用。通过使用&lt;uses-feature&gt;元素，一个应用可以指定它所 支持的硬件型号，举个例子，有些设备不支持多点触控或者OpenGL ES 2.0，那么过滤器就会过滤需要这些硬件支持（多点触控或者OpenGL ES 2.0）的应用，用户就不会在android market上看到这些应用。&lt;/p&gt;
&lt;p&gt;android.hardware.touchscreen.multitouch：它要求设备有一个多点触控的屏幕以支持基本的多点触控交互，就如收缩（放大）图像比例。这些类型的屏幕跟踪多个手指的能力都有所不同，所以你必须确保这个屏幕的性能是能够支持的游戏进行。&lt;/p&gt;
&lt;p&gt;android.hardware.touchscreen.multitouch.distinct: 这是一个多点触控的兄弟属性，它要求提设备供完整的多点触控功能。&lt;/p&gt;
&lt;p&gt;现在只要记住在当你的游戏需要一个支持多点触控的屏幕的时候，我们可以使用 &lt;uses-feature&gt;元素来剔除所有不支持多点触控的设备，就像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-feature android:name=&#39;android.hardware.touchscreen.multitouch&#39; android:required=&#39;true&#39;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一个在游戏开发中非常有用的是去指定需要的OpenGL ES版本。如果你的游戏需要更强大的图形处理能力，我们可以指定OpenGL ES 2.0，然后我们的游戏只会被支持OpenGL ES 2.0的设备所看见。注意，在本书中不会使用OPenGL ES 2.0, 我们只是过滤那些不能提供足够图形处理能力的设备。下面显示了我们怎么去实现它。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-feature android:glEsVersion=&#39;0x00020000&#39; required=&#39;true&#39;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;五-androidsupportsrtltrue&#34;&gt;五、android:supportsRtl=&#39;true&#39;&lt;/h3&gt;
&lt;p&gt;android4.2有一个新特性 layoutRtl，当然是对于开发者而言的，主要是方便开发者去支持阿拉伯语/波斯语等阅读习惯是从右往左的。&lt;/p&gt;
&lt;p&gt;可以在manifest的application标签添加：android:supportsRtl 取值：true/false&lt;/p&gt;
&lt;p&gt;这样就可以打开layoutRtl这个功能。如果当前系统语言是阿拉伯语/波斯语，打开了这个功能的应用的布局就会自动变成从右往左的，当然前提是布局没有写死控件间的位置。&lt;/p&gt;
&lt;h3 id=&#34;六-androidshareduserid&#34;&gt;六、android:sharedUserId&lt;/h3&gt;
&lt;p&gt;Android给每个APK进程分配一个单独的空间,manifest中的userid就是对 应一个分配的Linux用户ID，并且为它创建一个沙箱，以防止影响其他应用程序（或者其他应用程序影响它）。用户ID 在应用程序安装到设备中时被分配，并且在这个设备中保持它的永久性。&lt;/p&gt;
&lt;p&gt;通常，不同的APK会具有不同的userId，因此运行时属于不同的进程中，而不同进程中的资源是不共享的，在保障了程序运行的稳定。然后在有些时候，我们自己开发了多个APK并且需要他们之间互相共享资源，那么就需要通过设置shareUserId来实现这一目的。&lt;/p&gt;
&lt;p&gt;通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。&lt;/p&gt;
&lt;p&gt;shareUserId设置：&lt;/p&gt;
&lt;p&gt;在需要共享资源的项目的每个AndroidMainfest.xml中添加shareuserId的标签。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;android:sharedUserId=&#39;com.example&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id名自由设置，但必须保证每个项目都使用了相同的sharedUserId。一个mainfest只能有一个Shareuserid标签。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;manifest xmlns:android=&#39;http://schemas.android.com/apk/res/android&#39;    
			package=&#39;com.example.shareusertesta&#39;    
			android:versionCode=&#39;1&#39;    
			android:versionName=&#39;1.0&#39;     
			android:sharedUserId=&#39;com.example&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;datadata自定义的package 路径下的互相访问&lt;/p&gt;
&lt;p&gt;每个安装的程序都会根据自己的包名在手机文件系统的datadatayour package建立一个文件夹（需要su权限才能看见），用于存储程序相关的数据。&lt;/p&gt;
&lt;p&gt;在代码中，我们通过context操作一些IO资源时，相关文件都在此路径的相应文件夹中。比如默认不设置外部路径的文件、DB等等。&lt;/p&gt;
&lt;p&gt;正常情况下，不同的apk无法互相访问对应的app文件夹。但通过设置相同的shareUserId后，就可以互相访问了。&lt;/p&gt;
&lt;p&gt;如：A程序中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//默认建立在data/data/xxx/file/            
fOut = openFileOutput(&#39;settings.dat&#39;, MODE_PRIVATE);                       
osw = new OutputStreamWriter(fOut);           
osw.write(data);           
osw.flush();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B程序中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//获取程序A的context           
Context ctx = this.createPackageContext(&#39;com.example.shareusertesta&#39;,Context.CONTEXT_IGNORE_SECURITY);           
String msg = ReadSettings(ctxDealFile);           
Toast.makeText(this, &#39;DealFile2 Settings read&#39; + msg,Toast.LENGTH_SHORT).show();           
WriteSettings(ctx, &#39;deal file2 write&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个程序就能互相的访问资源了。（当然前提是都设置了相同的shareUserId）&lt;/p&gt;
&lt;p&gt;Resources和SharedPreferences的共享&lt;/p&gt;
&lt;p&gt;通过shareuserId共享，我们可获取到程序A的context。因此，我们就可以通过context来获取程序A对应的各种资源。比较常用的就是Raw资源的获取，如一些软件的apk皮肤包就是采用了这种技术，将主程序和皮肤资源包分在两个apk中。&lt;/p&gt;
&lt;p&gt;获 取Resources很简单，在程序A和B的mainfest中设置好相同的shareuserId后，通过createPackageContext获 取context即可。之后就和原来的方式一样，通过getResources函数获取各种资源，只是此时的context环境是目标APP的 context环境。&lt;/p&gt;
&lt;p&gt;看见程序A和B之间的联系有三个：&lt;/p&gt;
&lt;p&gt;1 mainfest中声明shareuserId时需要知道一个共同的userId&lt;/p&gt;
&lt;p&gt;2 createpackageContext时需要知道目标APK的package的name&lt;/p&gt;
&lt;p&gt;3 获取资源时需要知道该资源的对应ID&lt;/p&gt;
&lt;h3 id=&#34;七-androidsettingsactivity&#34;&gt;七、android:settingsActivity&lt;/h3&gt;
&lt;p&gt;不知道怎么用的==，这是在一个源码里看到&lt;/p&gt;
&lt;h3 id=&#34;八-androidlaunchmodesingletop-activity节点下&#34;&gt;八、android:launchMode=&#39;singleTop&#39;  &amp;lt;Activity节点下&amp;gt;&lt;/h3&gt;
&lt;p&gt;Activity一共有以下四种launchMode：&lt;/p&gt;
&lt;p&gt;1.standard    2.singleTop   3.singleTask    4.singleInstance&lt;/p&gt;
&lt;p&gt;（1）standard：系统默认的标准型，每次跳转系统都会在task中生成一个新的Activity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的Activity实例。&lt;/p&gt;
&lt;p&gt;这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。跟普通的栈一样，先进后出。&lt;/p&gt;
&lt;p&gt;（2）single:它是在standard的标准下加了一个属性。即当你要跳转的activity是位于栈顶时，它不会再new一个新的实例出来。但如果是firstactivity和secondactivity交替跳转，那跟普通的standard模式一样。&lt;/p&gt;
&lt;p&gt;（3）singleTask。它的原理是保证这个activity实例生成后是不会再生成新的实例。比如说两个activity,first和second。First设为singleTask，然后跳转到second，再返回first时，first不会生成实例，而是从栈中取出first放在栈顶。还有一点比较重要的一点是，在first上的activity会全部移除出栈，不管你这个activitys是不是也是singleTask模式，一律移除。&lt;/p&gt;
&lt;p&gt;（4）singleInstance。这个就比较特殊了，不过也比较简单。就是新开一个task栈专门放这个activity,而其它activity不让它进去。&lt;/p&gt;
&lt;h3 id=&#34;九-androidtaskaffinity&#34;&gt;九、android:taskAffinity&lt;/h3&gt;
&lt;p&gt;每 个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该 Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果 Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根 Activity的taskAffinity的值。 一开始，创建的Activity都会在创建它的Task中，并且大部分都在这里度过了它的整个生命。&lt;/p&gt;
&lt;p&gt;allowTaskReparenting用来标记Activity能否从启动的Task移动到taskAffinity指定的Task，默认是继承至 application中的allowTaskReparenting=false，如果为true，则表示可以更换；false表示不可以。&lt;/p&gt;
&lt;p&gt;这两个属性通常是放在一起用的。&lt;/p&gt;
&lt;p&gt;简而言之，用了taskAffinity的activity实例化的时候会先看看有没有与taskAffinity相同的task,如果有，则会跑到那边的task中,并实例化。&lt;/p&gt;
&lt;h3 id=&#34;十-androidconfigchanges&#34;&gt;十、android:configChanges&lt;/h3&gt;
&lt;p&gt;对android:configChanges属性，一般认为有以下几点：&lt;/p&gt;
&lt;p&gt;1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次&lt;/p&gt;
&lt;p&gt;2、设置Activity的android:configChanges=&#39;orientation&#39;时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次&lt;/p&gt;
&lt;p&gt;3、设置Activity的android:configChanges=&#39;orientation|keyboardHidden&#39;时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法&lt;/p&gt;
&lt;p&gt;但是，自从Android 3.2（API 13），在设置Activity的android:configChanges=&#39;orientation|keyboardHidden&#39;后，还是一样 会重新调用各个生命周期的。因为screen size也开始跟着设备的横竖切换而改变。所以，在AndroidManifest.xml里设置的MiniSdkVersion和 TargetSdkVersion属性大于等于13的情况下，如果你想阻止程序在运行时重新加载Activity，除了设置&#39;orientation&#39;， 你还必须设置&#39;ScreenSize&#39;。&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/adamzuocy/archive/2009/10/15/1583670.html&lt;/p&gt;
&lt;h3 id=&#34;十一-androidexported&#34;&gt;十一、android:exported&lt;/h3&gt;
&lt;p&gt;这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。如果设置为true，则能够被调用或交互，否则不能。设置为false时，只有同一个应用程序的组件或带有相同用户ID的应用程序才能启动或绑定该服务。它的默认值依赖与该服务所包含的过滤器。没有过滤器则意味着该服务只能通过指定明确的类名来调用，这样就是说该服务只能在应用程序的内部使用（因为其他外 部使用者不会知道该服务的类名），因此这种情况下，这个属性的默认值是false。另一方面，如果至少包含了一个过滤器，则意味着该服务可以给外部的其他 应用提供服务，因此默认值是true。&lt;br&gt;
这个属性不是限制把服务暴露给其他应用程序的唯一方法。还可以使用权限来限制能够跟该服务交互的外部实体。&lt;/p&gt;
&lt;h3 id=&#34;十二-androidimmersive&#34;&gt;十二、android:immersive&lt;/h3&gt;
&lt;p&gt;貌似是全屏的设置，可以用来隐藏标题栏和菜单栏。可以通过代码来实现不同的UI响应事件&lt;/p&gt;
&lt;h3 id=&#34;十三-androidexcludefromrecents&#34;&gt;十三、android:excludeFromRecents&lt;/h3&gt;
&lt;p&gt;控制在不在recent列表中显示，就是使用该activity时app不会出现在最近使用app列表中&lt;/p&gt;
">关于那些Android中不常用的设置属性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/guan-yu-android-webviewclient-he-webchromeclient/"" data-c="
          &lt;h2 id=&#34;一-android之webviewclient与webchromeclient的区别&#34;&gt;一、Android之WebViewClient与WebChromeClient的区别&lt;/h2&gt;
&lt;p&gt;ANDROID应用开发的时候可能会用到WEBVIEW这个组件，使用过程中可能会接触到WEBVIEWCLIENT与WEBCHROMECLIENT，那么这两个类到底有什么不同呢？&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;WebViewClient主要帮助WebView处理各种通知、请求事件的，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onLoadResource
onPageStart
onPageFinish
onReceiveError
onReceivedHttpAuthRequest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onCloseWindow(关闭WebView)
onCreateWindow()
onJsAlert (WebView上alert无效，需要定制WebChromeClient处理弹出)
onJsPrompt
onJsConfirm
onProgressChanged
onReceivedIcon
onReceivedTitle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看上去他们有很多不同，实际使用的话，如果你的WebView只是用来处理一些html的页面内容，只用WebViewClient就行了，如果需要更丰富的处理效果，比如JS、进度条等，就要用到WebChromeClient。&lt;br&gt;
更多的时候，你可以这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WebView webView;
webView= (WebView) findViewById(R.id.webview);
webView.setWebChromeClient(new WebChromeClient());
webView.setWebViewClient(new WebViewClient());
webView.getSettings().setJavaScriptEnabled(true);
webView.loadUrl(url);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样你的WebView理论上就能有大部分需要实现的特色了&lt;br&gt;
当然，有些更精彩的内容还是需要你自己添加的&lt;/p&gt;
&lt;h2 id=&#34;二-webviewclient的方法说明&#34;&gt;二、WebViewClient的方法说明&lt;/h2&gt;
&lt;p&gt;1、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean shouldOverrideUrlLoading(WebView view, String url) { 
       view.loadUrl(url);
       return true;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在点击请求的是链接是才会调用，重写此方法返回true表明点击网页里面的链接还是在当前的webview里跳转，不跳到浏览器那边。&lt;br&gt;
2、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onReceivedSslError(WebView view, SslErrorHandler handler, android.net.http.SslError error) {
	handler.proceed();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重写此方法可以让webview处理https请求。&lt;br&gt;
3、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event) {
   return super.shouldOverrideKeyEvent(view, event);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重写此方法才能够处理在浏览器中的按键事件。&lt;br&gt;
4、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onLoadResource(WebView view, String url) {
    if (DEBUG) {
        Log.d(TAG, &amp;quot; onLoadResource &amp;quot;);
    }
    super.onLoadResource(view, url);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。&lt;br&gt;
5、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onPageStarted(WebView view, String url, Bitmap favicon) {
    if (DEBUG) {
        Log.d(TAG, &amp;quot; onPageStarted &amp;quot;);
    }
   	if (url.endsWith(&amp;quot;.apk&amp;quot;)) {
      	download(url);//下载处理
    }
    super.onPageStarted(view, url, favicon);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在页面加载开始时调用。&lt;br&gt;
6、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onPageFinished(WebView view, String url) {
    // TODO Auto-generated method stub
    if (DEBUG) {
        Log.d(TAG, &amp;quot; onPageFinished &amp;quot;);
    }
    super.onPageFinished(view, url);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在页面加载结束时调用。&lt;/p&gt;
">关于android WebViewClient和WebChromeClient</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/guan-yu-android-42-ban-ben-de-sdcard-wen-jian-mu-lu-fen-xi-han-xiu-zheng/"" data-c="
          &lt;p&gt;关于文件软链接,这个问题曾经困扰过我,后来经过正则排除了软链接的影响.下面是以前找到的资料,坐下备份.以后遇到还能解释.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;
&lt;p&gt;在Android 4.2版本之前，通过Environment.getExternalStorageDirectory()获取的sdcard默认目录是正常的，可进行读写，一般的结果是“/mnt/sdcard”，但是在4.2版本之后，获取的sdcard目录是“/storage/emulated/0”，使用File.exist()方法返回true表示文件/目录是存在的，但是通过adb向该返回的目录中写数据（上传文件＝）是不成功的，返回的错误是&amp;quot;No such file or directory&amp;quot;，个人判断是返回的路径“/storage/emulated/0”其实是个类似快捷方式的文件，通过特定的解析方式可以认为是目录，但对于adb来说，该路径就是个文件，adb没有做过多的属性＝判断。上述判断也是有依据的，通过adb的shell命令获取指定目录下的文件/文件夹列表， 该路径显示的是文件，且有大小。&lt;/p&gt;
&lt;p&gt;之前就有猜测，关于目录结构中会存在不同程度的虚拟链接文件，google了下确实如此，以下的3处虚拟符号链接(类似windows下的快捷方式)是：&lt;/p&gt;
&lt;p&gt;&amp;quot;/storage/emulated/0 and /storage/emulated/0/0 (new and &amp;quot;backup&amp;quot; locations, respectively)&lt;br&gt;
/storage/emulated/legacy and /storage/emulated/legacy/0 (new and &amp;quot;backup&amp;quot; locations, respectively)&lt;br&gt;
/storage/sdcard0 and /storage/sdcard0/0 (new and &amp;quot;backup&amp;quot; locations, respectively)&amp;quot; (文章链接是http://androidforums.com/verizon-galaxy-nexus-all-things-root/649940-4-2-sdcard-sdcard-0-observation.html)&lt;/p&gt;
&lt;p&gt;所以在处理sdcard目录时，尽量自己先判断处理后提供同一的接口&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;
&lt;p&gt;关于目录/storage/emulated/legacy/目录的问题&lt;br&gt;
因为google在4.2中考虑多用户的问题，对每个用户（user）来说，看各自的文件夹可以，但对于数据文件夹的处理就稍微麻烦了，所以调整了数据的挂载结构，如使用fuse技术/dev/fuse 会被挂载到/storage/emulated/0 目录，为了兼容以前，同时挂载到 /storage/emulated/legacy （故名思议，传统的），还建立三个软连接 /storage/sdcard0 ，/sdcard，/mnt/sdcard ，都指向  /storage/emulated/legacy/，（链接参见：http://bbs.gfan.com/android-5382920-1-1.html），但是就可能造成获取文件目录中的文件（如image）时，会出现相同的图片（本来上传1张，但出现了2张＝＝）&lt;br&gt;
将上面的类的判断修改如下&lt;/p&gt;
&lt;p&gt;另外，针对image的上传后通过provider获取image图片时同一张图片给了2份，地址分别是&amp;quot;/storage/emulated/legacy/dcim/camera/1.jpg&amp;quot;和&amp;quot;/storage/sdcard0/DCIM/Camera/1.jpg&amp;quot;，其中legacy的属于兼容的，但获取能获取出来，所以获取时要进行过滤处理&lt;/p&gt;
&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;
&lt;p&gt;安卓系统的问题，android 4.2使用fuse技术/dev/fuse 会被挂载到/storage/emulated/0 目录，为了兼容以前的版本，同时挂载到 /storage/emulated/legacy （故名思议，传统的），还建立三个软连接 /storage/sdcard0 ，/sdcard，/mnt/sdcard ，都指向 /storage/emulated/legacy。也就是说文件夹0和legacy指向的地址是一致的，都是存储盘里的，楼主想放到哪个文件夹都可以。&lt;/p&gt;
&lt;h3 id=&#34;4&#34;&gt;4&lt;/h3&gt;
&lt;p&gt;In short: It has to do with the multi-user functionality introduced with Jelly Bean:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;/storage/emulated/0/: to my knowledge, this refers to the &amp;quot;emulated MMC&amp;quot; (&amp;quot;owner part&amp;quot;). Usually this is the internal one. The &amp;quot;0&amp;quot; stands for the user here, &amp;quot;0&amp;quot; is the first user aka device-owner. If you create additional users, this number will increment for each.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/storage/emulated/legacy/ as before, but pointing to the part of the currently working user (for the owner, this would be a symlink to /storage/emulated/0/). So this path should bring every user to his &amp;quot;part&amp;quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/sdcard/: According to a comment by Shywim, this is a symlink to...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/mnt/sdcard (Android &amp;lt; 4.0)&lt;/li&gt;
&lt;li&gt;/storage/sdcard0 (Android 4.0+)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/storage/sdcard0/: As there&#39;s no legacy pendant here (see comments below), the &amp;quot;0&amp;quot; in this case rather identifies the device (card) itself. One could, eventually, connect a card reader with another SDCard via OTG, which then would become /storage/sdcard1 (no proof for that, just a guess -- but I&#39;d say a good one)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Though one might get to the conclusion there should be a /storage/sdcard/legacy as well, there isn&#39;t (see comments) -- which completely makes sense with my assumption of the numbers here are not related to the user, but rather to possible multiple cards: &amp;quot;0&amp;quot; would always be the one in the card-slot of the device, so no need for a &amp;quot;legacy symlink&amp;quot; here.&lt;/p&gt;
">关于android 4.2版本的sdcard文件目录分析(含修正)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/shi-yong-android-studio-de-lint-qing-chu-wu-yong-de-zi-yuan-wen-jian/"" data-c="
          &lt;p&gt;如图：在项目中，点击菜单栏的Analyze -&amp;gt; Run Inspection by Name ...&lt;/p&gt;
&lt;!--more--&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;弹出输入框：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Enter 之后会弹出：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般选择整个项目或某个模块，当然也可以指定某个目录&lt;/p&gt;
&lt;p&gt;OK之后 Studio会自动分析，然后可以根据结果清除无用的资源文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Note:
1. 一般得提前删掉已经无用的java文件 
2. 接着根据分析后的结果删除 xml文件 
3. 我使用的过程，分析结果未发现图片资源文件是否可清除，所以是通过指定图片Alt+F7(Find Usages) 一张张分析删除的（累~ ）&lt;/code&gt;&lt;/pre&gt;
">使用Android Studio的lint清除无用的资源文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/ni-xu-yao-zhi-dao-de-android-pai-zhao-gua-pei-fang-an/"" data-c="
          &lt;p&gt;转自:&lt;a href=&#34;http://www.jianshu.com/p/f269bcda335f&#34;&gt;http://www.jianshu.com/p/f269bcda335f&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;拍照功能实现&#34;&gt;拍照功能实现&lt;/h3&gt;
&lt;p&gt;Android 程序上实现拍照功能的方式分为两种：第一种是利用相机的 API 来自定义相机，第二种是利用 Intent 调用系统指定的相机拍照。下面讲的内容都是针对第二种实现方式的适配。&lt;/p&gt;
&lt;p&gt;通常情况下，我们调用拍照的业务场景是如下面这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A 界面，点击按钮调用相机拍照；&lt;/li&gt;
&lt;li&gt;A 界面得到拍完照片，跳转到 B 界面进行预览；&lt;/li&gt;
&lt;li&gt;B 界面有个按钮，点击后触发某个业务流程来处理这张照片；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现的大体流程代码如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;到这里基本科普完了如何调用系统相机拍照，相信这些网上一搜一大把的代码，很多童鞋都能看懂。&lt;/p&gt;
&lt;h3 id=&#34;有没有相机可用&#34;&gt;有没有相机可用？&lt;/h3&gt;
&lt;p&gt;前面讲到我们是调用系统指定的相机app来拍照，那么系统是否存在可以被我们调用的app呢？这个我们不敢确定，毕竟 Android 奇葩问题多，还真有遇到过这种极端的情况导致闪退的。虽然很极端，但作为客户端人员还是要进行处理，方式有二：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用相机时，简单粗暴的 try-catch&lt;/li&gt;
&lt;li&gt;调用相机前，检测系统有没有相机 app 可用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;try-catch 这种粗暴的方式大家肯定很熟悉了，那么要如何检测系统有没有相机 app 可用呢？系统在  PackageManager 里为我们提供这样一个 API&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过这样一个 API ，可以知道系统是否存在 action 为 MediaStore.ACTION_IMAGE_CAPTURE 的 intent 可以唤起的拍照界面，具体实现代码如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201759.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;拍出来的照片歪了&#34;&gt;拍出来的照片“歪了”！！！&lt;/h3&gt;
&lt;p&gt;经常会遇到一种情况，拍照时看到照片是正的，但是当我们的 app 获取到这张照片时，却发现旋转了 90 度（也有可能是180、270，不过90度比较多见，貌似都是由于手机传感器导致的）。很多童鞋对此感到很困扰，因为不是所有手机都会出现这种情况，就算会是出现这种情况的手机上，也并非每次必现。要怎么解决这个问题呢？从解决的思路上看，只要获取到照片旋转的角度，利用 Matrix 来进行角度纠正即可。那么问题来了，要怎么知道照片旋转的角度呢？细心的童鞋可能会发现，拍完一张照片去到相册点击属性查看，能看到下面这样一堆关于照片的属性数据&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;没错，这里面就有一个旋转角度，倘若拍照后保存的成像照片文件发生了角度旋转，这个图片的属性参数就能告诉我们到底旋转了多少度。只要获取到这个角度值，我们就能进行纠正的工作了。 Android 系统提供了 ExifInterface 类来满足获取图片各个属性的操作&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201818.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过 ExifInterface 类拿到 TAG_ORIENTATION 属性对应的值，即为我们想要得到旋转角度。再根据利用 Matrix 进行旋转纠正即可。实现代码大致如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;ExifInterface 能拿到的信息远远不止旋转角度，其他的参数感兴趣的童鞋可以看看 API 文档。&lt;/p&gt;
&lt;h3 id=&#34;拍完照怎么闪退了&#34;&gt;拍完照怎么闪退了？&lt;/h3&gt;
&lt;p&gt;曾在小米和魅族的某些机型上遇到过这样的问题，调用系统相机拍照，拍完点击确定回到自己的app里面却莫名奇妙的闪退了。这种闪退有两个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有什么错误日志（有些机子啥日志都没有，有些机子会出来个空异常错误日志）；&lt;/li&gt;
&lt;li&gt;同个机子上非必现（有时候怎么拍都不闪退，有时候一拍就闪退）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对待非必现问题往往比较头疼，当初遇到这样的问题也是非常不解。上网搜罗了一圈也没方案，后来留意到一个比较有意思信息：有些系统厂商的 ROM 会给自带相机应用做优化，当某个 app 通过 intent 进入相机拍照界面时，系统会把这个 app 当前最上层的 Activity 销毁回收。（注意：我遇到的情况是有时候很快就回收掉，有时候怎么等也不回收，没有什么必现规律）为了验证一下，便在启动相机的 Activity 中对 onDestory 方法进行加 log 。果不其然，终于发现进入拍照界面的时候 onDestory 方法被执行了。所以，前面提到的闪退基本可以推测是 Activity 被回收导致某些非UI控件的成员变量为空导致的。（有些机子会报出空异常错误日志，但是有些机子闪退了什么都不报，是不是觉得很奇葩！）&lt;/p&gt;
&lt;p&gt;既然涉及到 Activity 被回收的问题，自然要想起 onSaveInstanceState 和 onRestoreInstanceState 这对方法。去到 onSaveInstanceState 把数据保存，并在 onRestoreInstanceState 方法中进行恢复即可。大体代码思路如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对于  onSaveInstanceState 和 onRestoreInstanceState 方法的作用还不熟悉的童鞋，网上资料很多，可以自行搜索。&lt;/p&gt;
&lt;p&gt;到这里，可能有童鞋要问，这种闪退并不能保证复现，我要怎么知道问题所在和是否修复了呢？我们可以去到开发者选项里开启不保留活动这一项进行调试验证&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201858.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;它作用是保留当前和用户接触的 Activity ，并将目前无法和用户交互 Activity 进行销毁回收。打开这个调试选项就可以满足验证的需求，当你的 app 的某个 Activity 跳转到拍照的 Activity 后，这个 Activity 立马就会被系统销毁回收，这样就可以很好的完全复现闪退的场景，帮助开发者确认问题有没有修复了。&lt;/p&gt;
&lt;p&gt;涉及到 Activity 被销毁，还想提一下代码实现上的问题。假设当前有两个 Activity ，MainActivity 中有个 Button ，点击可以调用系统相机拍照并显示到 PreviewActivity 进行预览。有下面两种实现方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案一：MainActivity 中点击 Button 后，启动系统相机拍照，并在 MainActivity 的 onActivityResult 方法中获取拍下来的照片，并启动跳转到 PreviewActivity 界面进行效果预览；&lt;/li&gt;
&lt;li&gt;方案二：MainActivity 中点击 Button 后，启动 PreviewActivity 界面，在 PreviewActivity 的 onCreate（或者onStart、onResume）方法中启动系统相机拍照，然后在 PreviewActivity 的 onActivityResult 方法中获取拍下来的照片进行预览；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面两种方案得到的实现效果是一模一样的，但是第二种方案却存在很大的问题。因为启动相机的代码放在 onCreate（或者onStart、onResume）中，当进入拍照界面后，PreviewActivity 随即被销毁，拍完照确认后回到 PreviewActivity 时，被销毁的 PreviewActivity 需要重建，又要走一遍 onCreate、onStart、onResume，又调用了启动相机拍照的代码，周而复始的进入了死循环状态。为了避免让你的用户抓狂，果断明智的选择方案一。&lt;/p&gt;
&lt;p&gt;以上这种情况提到调用系统拍照时，Activity就回收的情况，在小米4S和小米4 LTE机子上（MIUI的版本是7.3，Android系统版本是6.0）出现的概率很高。 所以，建议看到此文的童鞋也可以去验证适配一下。&lt;/p&gt;
&lt;h3 id=&#34;图片无法显示&#34;&gt;图片无法显示&lt;/h3&gt;
&lt;p&gt;图片无法显示这个问题也是略坑，如何坑法？往下看，同样是在小米4S和小米4 LTE机子上（MIUI的版本是7.3，Android系统版本是6.0）出现概率很高的场景（当然，不保证其他机子没出现过）。按照我们前面提到的业务场景，调用相机拍照完成后，我们的 app 会有一个预览图片的界面。但是在用了小米的机子进行拍照后，自己 app 的预览界面却怎么也无法显示出照片来，同样是相当郁闷，郁闷完后还是要一步一步去排查解决问题的！为此，需要一步一步猜测验证问题所在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;猜测一：没有拿到照片路径，所以无法显示？&lt;br&gt;
直接断点打 log 跟踪，猜测一很快被推翻，路径是有的。&lt;/li&gt;
&lt;li&gt;猜测二：Bitmap太大了，无法显示？&lt;br&gt;
直接在 AS 的 log 控制台仔细的观察了一下系统 log ，发现了一些蛛丝马迹&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201920.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每次拍完照片，都会出现上面这样的 log ，果然，因为图片太大而导致在 ImageView 上无法显示。到这里有童鞋要吐槽了，没对图片的采样率 inSampleSize 做处理？天地良心啊，绝对做处理了，直接看代码：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;瞄了代码后，是不是觉得没有问题了？没错，inSampleSize 确确实实经过处理，那为什么图片还是太大而显示不出来呢？ requestWidth、int requestHeight 设置得太大导致 inSampleSize 太小了？不可能啊，我都试着把长宽都设置成 100 了还是没法显示！干脆，直接打印 inSampleSize 值，一打印，inSampleSize 值居然为 1 。 我去，彻底打脸了，明明说好的处理过了，居然还是 1 ！！！！为了一探究竟，干脆加 log 。&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;运行打印出来的日志如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202049.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图片原来的宽高居然都是 -1 ，真是奇葩了！难怪，inSampleSize 经过处理之后结果还是 1 。狠狠的吐槽了之后，总是要回来解决问题的。那么，图片的宽高信息都丢失了，我去哪里找啊？ 像下面这样？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202037.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;no，此方案行不通，inJustDecodeBounds = true 时，BitmapFactory 获得 Bitmap 对象是 null；那要怎样才能获图片的宽高呢？前面提到的 ExifInterface 再次帮了我们大忙，通过它的下面两个属性即可拿到图片真正的宽高&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;顺手吐槽一下，为什么高不是 TAG_IMAGE_HEIGHT 而是 TAG_IMAGE_LENGTH。改良过后的代码实现如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;再看一下，打印出来的log&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119202010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样就可以解决问题啦。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;以上总结了这么些身边童鞋经常问起，但网上又不多见的适配问题，希望可以帮到一些开发童鞋少走弯路。文中多次提到小米的机子，并不代表只有MIUI上有这样的问题存在，仅仅只是因为我身边带的几部机子大都是小米的。对待适配问题，在搜索引擎都无法提供多少有效的信息时，我们只能靠断点、打log、观察控制台的日志、以及API文档来寻找一些蛛丝马迹作为突破口，相信办法总比困难多。&lt;/p&gt;
&lt;p&gt;以上的示例代码已经整理到：&lt;a href=&#34;https://github.com/D-clock/AndroidStudyCode&#34;&gt;https://github.com/D-clock/AndroidStudyCode &lt;/a&gt;&lt;/p&gt;
">你需要知道的Android拍照适配方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/url-schemes/"" data-c="
          &lt;p&gt;最近折腾iOS快捷启动应用或应用内的某个动作的神器launch center pro （LCP），发现很多国产app并没有被LCP官方收录，所以不得不想办法找到app的url schemes. 下面是其中的一些iOS应用URL schemes，供分享：&lt;/p&gt;
&lt;!--more--&gt;
&lt;ul&gt;
&lt;li&gt;QQ mqq://&lt;/li&gt;
&lt;li&gt;微信是 weixin://&lt;/li&gt;
&lt;li&gt;网易新闻 newsapp://&lt;/li&gt;
&lt;li&gt;淘宝 taobao://&lt;/li&gt;
&lt;li&gt;点评 dianping:// dianping://search&lt;/li&gt;
&lt;li&gt;微博 sinaweibo://&lt;/li&gt;
&lt;li&gt;weico微博 weico://&lt;/li&gt;
&lt;li&gt;支付宝 alipay://&lt;/li&gt;
&lt;li&gt;豆瓣fm： doubanradio://&lt;/li&gt;
&lt;li&gt;网易公开课 ntesopen://&lt;/li&gt;
&lt;li&gt;美团 imeituan://&lt;/li&gt;
&lt;li&gt;人人 renren://&lt;/li&gt;
&lt;li&gt;我查查 wcc://&lt;/li&gt;
&lt;li&gt;1号店 wccbyihaodian://&lt;/li&gt;
&lt;li&gt;有道词典 yddictproapp://&lt;/li&gt;
&lt;li&gt;知乎 zhihu://&lt;/li&gt;
&lt;li&gt;优酷 youku://&lt;/li&gt;
&lt;li&gt;ZAKER zakeripad://&lt;/li&gt;
&lt;li&gt;mdict mdict://&lt;/li&gt;
&lt;li&gt;京东hd openApp.jdiPad://&lt;/li&gt;
&lt;li&gt;易迅 icson://；yixunipad://&lt;/li&gt;
&lt;li&gt;wunderlist wunderlist://&lt;/li&gt;
&lt;li&gt;支付宝 alipay://&lt;/li&gt;
&lt;li&gt;查找朋友 grenada://；findmyfriends://；fmf1://&lt;/li&gt;
&lt;li&gt;查找iphone fmip1://&lt;/li&gt;
&lt;li&gt;触宝拨号：dialer://&lt;/li&gt;
&lt;li&gt;蜂窝网络：prefs:root=MOBILE_DATA_SETTINGS_ID&lt;/li&gt;
&lt;li&gt;WIFI：prefs:root=WIFI（WIFI这几个字母一定要大写）&lt;/li&gt;
&lt;li&gt;定位服务：prefs:root=LOCATION_SERVICES&lt;/li&gt;
&lt;li&gt;备忘录：mobilenotes://&lt;/li&gt;
&lt;li&gt;高德地图：iosamap://&lt;/li&gt;
&lt;li&gt;今日头条 snssdk141://&lt;/li&gt;
&lt;li&gt;挖财记账 wacai://&lt;/li&gt;
&lt;li&gt;QQ音乐 :QQmusic://&lt;/li&gt;
&lt;li&gt;猎豹浏览器:sinaweibosso.422729959://&lt;/li&gt;
&lt;li&gt;UC浏览器:ucbrowser://&lt;/li&gt;
&lt;li&gt;支付宝:alipay://&lt;/li&gt;
&lt;li&gt;新浪微博:weibo://&lt;/li&gt;
&lt;li&gt;优酷:youku://&lt;/li&gt;
&lt;li&gt;节奏大师:节奏大师tencentrm://&lt;/li&gt;
&lt;li&gt;刀塔传奇:刀塔传奇teiron2273://&lt;/li&gt;
&lt;li&gt;天天动听:ttpod://&lt;/li&gt;
&lt;li&gt;淘宝taobao://&lt;/li&gt;
&lt;li&gt;名片全能王camcard://&lt;/li&gt;
&lt;li&gt;支付宝alipay://&lt;/li&gt;
&lt;li&gt;豆瓣fm：doubanradio://&lt;/li&gt;
&lt;li&gt;微盘 sinavdisk://&lt;/li&gt;
&lt;li&gt;网易公开课ntesopen://&lt;/li&gt;
&lt;li&gt;我查查 wcc://&lt;/li&gt;
&lt;li&gt;1号店wccbyihaodian://&lt;/li&gt;
&lt;li&gt;有道词典yddictproapp://&lt;/li&gt;
&lt;li&gt;知乎zhihu://&lt;/li&gt;
&lt;li&gt;墨客 com.moke.moke-1://&lt;/li&gt;
&lt;li&gt;名片全能王 camcard://&lt;/li&gt;
&lt;li&gt;扫描全能王 camscanner://&lt;/li&gt;
&lt;li&gt;12306订票助手 trainassist://&lt;/li&gt;
&lt;li&gt;金山词霸 com.kingsoft.powerword.6://&lt;/li&gt;
&lt;li&gt;节奏大师 tencentrm://&lt;/li&gt;
&lt;li&gt;凤凰新闻 comIfeng3GifengNews://&lt;/li&gt;
&lt;li&gt;高铁管家 gtgj://&lt;/li&gt;
&lt;li&gt;飞信 fetion://&lt;/li&gt;
&lt;li&gt;豆瓣FM doubanradio://&lt;/li&gt;
&lt;li&gt;大智慧 dzhiphone://&lt;/li&gt;
&lt;li&gt;布卡漫画 buka://&lt;/li&gt;
&lt;li&gt;爱奇艺PPS ppstream://&lt;/li&gt;
&lt;li&gt;哔哩哔哩动画 bilibili://&lt;/li&gt;
&lt;li&gt;56视频 com.56Video://&lt;/li&gt;
&lt;li&gt;365日历 rili365://&lt;/li&gt;
&lt;li&gt;58同城 wbmain://&lt;/li&gt;
&lt;li&gt;遇见 iaround://&lt;/li&gt;
&lt;li&gt;陌陌 momochat://&lt;/li&gt;
&lt;li&gt;旺旺卖家版 wangwangseller://&lt;/li&gt;
&lt;li&gt;有道词典 yddict://&lt;/li&gt;
&lt;li&gt;掌阅iReader iReader://&lt;/li&gt;
&lt;li&gt;艺龙旅行 elongIPhone://&lt;/li&gt;
&lt;li&gt;迅雷+迅雷云播 thunder://&lt;/li&gt;
&lt;li&gt;熊猫公交 wb1405365637://&lt;/li&gt;
&lt;li&gt;携程无线 CtripWireless://&lt;/li&gt;
&lt;li&gt;无线苏州 SuZhouTV://&lt;/li&gt;
&lt;li&gt;唯品会 vipshop://&lt;/li&gt;
&lt;li&gt;微视 weishiiosscheme://&lt;/li&gt;
&lt;li&gt;微拍 wpweipai://&lt;/li&gt;
&lt;li&gt;旺信 wangxin://&lt;/li&gt;
&lt;li&gt;网易公开课 ntesopen://&lt;/li&gt;
&lt;li&gt;网易将军令 netease-mkey://&lt;/li&gt;
&lt;li&gt;万年历 youloft.419805549://&lt;/li&gt;
&lt;li&gt;土豆视频 tudou://&lt;/li&gt;
&lt;li&gt;同花顺 amihexin://&lt;/li&gt;
&lt;li&gt;天涯社区 tianya://&lt;/li&gt;
&lt;li&gt;天气通Pro sinaweatherpro://&lt;/li&gt;
&lt;li&gt;天气通 sinaweather://&lt;/li&gt;
&lt;li&gt;墨迹天气 rm434209233MojiWeather://&lt;/li&gt;
&lt;li&gt;腾讯新闻 qqnews://&lt;/li&gt;
&lt;li&gt;腾讯微云 weiyun://&lt;/li&gt;
&lt;li&gt;腾讯地图 sosomap://&lt;/li&gt;
&lt;li&gt;淘宝旅行 taobaotravel://&lt;/li&gt;
&lt;li&gt;人人 renrenios://&lt;/li&gt;
&lt;li&gt;蜻蜓FM qtfmp://&lt;/li&gt;
&lt;li&gt;浦发银行 wx1cb534bb13ba3dbd://&lt;/li&gt;
&lt;li&gt;招商银行 cmbmobilebank://&lt;/li&gt;
&lt;li&gt;支付宝 alipay://&lt;/li&gt;
&lt;li&gt;建设银行 wx2654d9155d70a468://&lt;/li&gt;
&lt;li&gt;工商银行 com.icbc.iphoneclient://&lt;/li&gt;
&lt;li&gt;酷我音乐 com.kuwo.kwmusic.kwmusicForKwsing://&lt;/li&gt;
&lt;li&gt;酷狗音乐 kugouURL://&lt;/li&gt;
&lt;li&gt;京东 openApp.jdMobile://&lt;/li&gt;
&lt;li&gt;QQ音乐 qqmusic://&lt;/li&gt;
&lt;li&gt;QQ斗地主 tencent382://&lt;/li&gt;
&lt;li&gt;QQ浏览器 mttbrowser://&lt;/li&gt;
&lt;li&gt;QQ安全中心 qmtoken://&lt;/li&gt;
&lt;li&gt;QQ国际版 mqqiapi://&lt;/li&gt;
&lt;li&gt;PPTV pptv://&lt;/li&gt;
&lt;li&gt;爱奇艺视频 qiyi-iphone://&lt;/li&gt;
&lt;li&gt;暴风影音 com.baofeng.play://&lt;/li&gt;
&lt;li&gt;保卫萝卜2 wb2217954495://&lt;/li&gt;
&lt;li&gt;保卫萝卜 wb1308702128://&lt;/li&gt;
&lt;li&gt;百度云 baiduyun://&lt;/li&gt;
&lt;li&gt;百度音乐 baidumusic://&lt;/li&gt;
&lt;li&gt;百度视频 baiduvideoiphone:// 或 bdviphapp://&lt;/li&gt;
&lt;li&gt;百度糯米 bainuo://&lt;/li&gt;
&lt;li&gt;百度魔图 photowonder://&lt;/li&gt;
&lt;li&gt;百度魔拍 wondercamera://&lt;/li&gt;
&lt;li&gt;百度地图 baidumap://&lt;/li&gt;
&lt;li&gt;百度导航 bdNavi://&lt;/li&gt;
&lt;li&gt;百度视频hd BaiduVideoiPad://；baiduvideoipadapp://&lt;/li&gt;
&lt;li&gt;百度相册hd BaiDuCloudAlbumHD://&lt;/li&gt;
&lt;li&gt;百度浏览器hd bdbrowser://&lt;/li&gt;
&lt;li&gt;百度文库hd bdwenku://&lt;/li&gt;
&lt;li&gt;搜狗输入法 com.sogou.sogouinput://&lt;/li&gt;
&lt;li&gt;搜狐视频 sohuvideo-iphone:// 或 sohuvideo://&lt;/li&gt;
&lt;li&gt;搜狐新闻 sohunews://&lt;/li&gt;
&lt;li&gt;随手记 FDMoney://&lt;/li&gt;
&lt;li&gt;腾讯企业邮箱 qqbizmailDistribute2://&lt;/li&gt;
&lt;li&gt;腾讯手机管家 mqqsecure://&lt;/li&gt;
&lt;li&gt;腾讯视频 tenvideo:// 或 tenvideo2:// 或 tenvideo3://&lt;/li&gt;
&lt;li&gt;腾讯微博 TencentWeibo://&lt;/li&gt;
&lt;li&gt;天猫 tmall://&lt;/li&gt;
&lt;li&gt;天天星连萌 tencent100689806://&lt;/li&gt;
&lt;li&gt;天天爱消除 tencent100689805://&lt;/li&gt;
&lt;li&gt;天天酷跑 tencent100692648://&lt;/li&gt;
&lt;li&gt;天天飞车 tencent100695850://&lt;/li&gt;
&lt;li&gt;天天动听 ttpod://&lt;/li&gt;
&lt;li&gt;威锋网 com.weiphone.forum://&lt;/li&gt;
&lt;li&gt;新浪微博 weibo:// 或 sinaweibo://&lt;/li&gt;
&lt;li&gt;网易邮箱 neteasemail://&lt;/li&gt;
&lt;li&gt;百度输入法 BaiduIMShop://&lt;/li&gt;
&lt;li&gt;C浏览器 ucbrowser://&lt;/li&gt;
&lt;li&gt;一个one clover-one://&lt;/li&gt;
&lt;li&gt;当当hd dangdanghd://；ddhd://&lt;/li&gt;
&lt;li&gt;大众点评hd dianpinghd://&lt;/li&gt;
&lt;li&gt;多看阅读 duokan-reader://&lt;/li&gt;
&lt;li&gt;艺龙旅行hd elongiPad://&lt;/li&gt;
&lt;li&gt;圈点hd skitch://&lt;/li&gt;
&lt;li&gt;印象笔记hd enx://&lt;/li&gt;
&lt;li&gt;电话 mobilephone://&lt;/li&gt;
&lt;li&gt;备忘录 mobilenotes://&lt;/li&gt;
&lt;li&gt;设置 prefs:root=SETTING&lt;/li&gt;
&lt;li&gt;定位服务 prefs:root=LOCATION_SERVICES&lt;/li&gt;
&lt;li&gt;E-Mail MESSAGE://&lt;/li&gt;
&lt;li&gt;popAgraph popagraphtumblr://&lt;/li&gt;
&lt;li&gt;dropbox db-auth://；dbapi-1://；dbapi-2://；dbapi-3://&lt;/li&gt;
&lt;li&gt;goodreader ghttp://；ghttps://；grhttp://；grhttps://；&lt;/li&gt;
&lt;li&gt;giwhttp://；giwhttps://；gropen://；&lt;/li&gt;
&lt;li&gt;com.goodreader.sendtogr://&lt;/li&gt;
&lt;li&gt;ifttt ifttt://&lt;/li&gt;
&lt;li&gt;名片全能王hd camcard://；CamCardHDOpenAPI://&lt;/li&gt;
&lt;li&gt;拉手团购hd LaShouGroupHDPay://&lt;/li&gt;
&lt;li&gt;美团hd iMeituan://&lt;/li&gt;
&lt;li&gt;evermemo evermemo://&lt;/li&gt;
&lt;li&gt;网易云课堂 wangyiyunketang://&lt;/li&gt;
&lt;li&gt;网易公开课 ntesopen://&lt;/li&gt;
&lt;li&gt;订票助手2 trainassistfree://&lt;/li&gt;
&lt;li&gt;pcalc lite pcalc://&lt;/li&gt;
&lt;li&gt;爱奇艺视频 QIYIHD-iPad://&lt;/li&gt;
&lt;li&gt;三国kill sgk://&lt;/li&gt;
&lt;li&gt;扇贝新闻 shanbaynews://&lt;/li&gt;
&lt;li&gt;扇贝单词 shanbay://&lt;/li&gt;
&lt;li&gt;扇贝单词hd shanbaywordshd://&lt;/li&gt;
&lt;li&gt;skype skype://&lt;/li&gt;
&lt;li&gt;搜狐视频hd sohu-SViPad://；sohuvideohd://&lt;/li&gt;
&lt;li&gt;teamviewer:teamviewer8://&lt;/li&gt;
&lt;li&gt;格志 griddiary://；sumi-interactive://&lt;/li&gt;
&lt;li&gt;淘宝hd taobao://；itaobao://；taobaohd://&lt;/li&gt;
&lt;li&gt;天猫 tmall://&lt;/li&gt;
&lt;li&gt;腾讯视频hd tenvideohd://；tenvideo2://&lt;/li&gt;
&lt;li&gt;qq通讯录 tencentappqqpim://&lt;/li&gt;
&lt;li&gt;同步推正版HD tbtui://；tuihd://&lt;/li&gt;
&lt;li&gt;航旅纵横pro umetrippro://&lt;/li&gt;
&lt;li&gt;mathpad myscriptmathpad://&lt;/li&gt;
&lt;li&gt;雅虎天气！ yweather://&lt;/li&gt;
&lt;li&gt;一号店 ipadstore://&lt;/li&gt;
&lt;li&gt;优酷hd youkuhd://&lt;/li&gt;
&lt;li&gt;知乎 zhihu://&lt;/li&gt;
&lt;li&gt;欧陆词典pro eudic://&lt;/li&gt;
&lt;li&gt;拓词 towordsp://&lt;/li&gt;
&lt;li&gt;TuneIn Radio tunein:// 或 tuneinpro://&lt;/li&gt;
&lt;li&gt;OfficeSuite mobisystemsofficesuite://&lt;/li&gt;
&lt;li&gt;WPS Office KingsoftOfficeApp://&lt;/li&gt;
&lt;li&gt;Line line://&lt;/li&gt;
&lt;li&gt;1Password onepassword://&lt;/li&gt;
&lt;li&gt;Clear(著名的Todo应用) clearapp://&lt;/li&gt;
&lt;li&gt;Chrome谷歌浏览器 googlechrome://&lt;/li&gt;
&lt;li&gt;Calendars 5 calendars://&lt;/li&gt;
&lt;li&gt;PDF Expert 5 pdfexpert5presence://&lt;/li&gt;
&lt;li&gt;Documents 5 rdocs://&lt;/li&gt;
&lt;li&gt;nPlayer nplayer-http://&lt;/li&gt;
&lt;li&gt;GPlayer gplayer://&lt;/li&gt;
&lt;li&gt;AVPlayer HD AVPlayerHD://&lt;/li&gt;
&lt;li&gt;AVPlayer AVPlayer://&lt;/li&gt;
&lt;li&gt;Ace Player aceplayer://&lt;/li&gt;
&lt;/ul&gt;
">URL schemes</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/sdcard-wen-jian-mu-lu-fen-xi-han-xiu-zheng/"" data-c="
          &lt;p&gt;关于文件软链接,这个问题曾经困扰过我,后来经过正则排除了软链接的影响.下面是以前找到的资料,坐下备份.以后遇到还能解释.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;
&lt;p&gt;在Android 4.2版本之前，通过Environment.getExternalStorageDirectory()获取的sdcard默认目录是正常的，可进行读写，一般的结果是“/mnt/sdcard”，但是在4.2版本之后，获取的sdcard目录是“/storage/emulated/0”，使用File.exist()方法返回true表示文件/目录是存在的，但是通过adb向该返回的目录中写数据（上传文件＝）是不成功的，返回的错误是&amp;quot;No such file or directory&amp;quot;，个人判断是返回的路径“/storage/emulated/0”其实是个类似快捷方式的文件，通过特定的解析方式可以认为是目录，但对于adb来说，该路径就是个文件，adb没有做过多的属性＝判断。上述判断也是有依据的，通过adb的shell命令获取指定目录下的文件/文件夹列表， 该路径显示的是文件，且有大小。&lt;/p&gt;
&lt;p&gt;之前就有猜测，关于目录结构中会存在不同程度的虚拟链接文件，google了下确实如此，以下的3处虚拟符号链接(类似windows下的快捷方式)是：&lt;/p&gt;
&lt;p&gt;&amp;quot;/storage/emulated/0 and /storage/emulated/0/0 (new and &amp;quot;backup&amp;quot; locations, respectively)&lt;br&gt;
/storage/emulated/legacy and /storage/emulated/legacy/0 (new and &amp;quot;backup&amp;quot; locations, respectively)&lt;br&gt;
/storage/sdcard0 and /storage/sdcard0/0 (new and &amp;quot;backup&amp;quot; locations, respectively)&amp;quot; (文章链接是http://androidforums.com/verizon-galaxy-nexus-all-things-root/649940-4-2-sdcard-sdcard-0-observation.html)&lt;/p&gt;
&lt;p&gt;所以在处理sdcard目录时，尽量自己先判断处理后提供同一的接口&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;
&lt;p&gt;关于目录/storage/emulated/legacy/目录的问题&lt;br&gt;
因为google在4.2中考虑多用户的问题，对每个用户（user）来说，看各自的文件夹可以，但对于数据文件夹的处理就稍微麻烦了，所以调整了数据的挂载结构，如使用fuse技术/dev/fuse 会被挂载到/storage/emulated/0 目录，为了兼容以前，同时挂载到 /storage/emulated/legacy （故名思议，传统的），还建立三个软连接 /storage/sdcard0 ，/sdcard，/mnt/sdcard ，都指向  /storage/emulated/legacy/，（链接参见：http://bbs.gfan.com/android-5382920-1-1.html），但是就可能造成获取文件目录中的文件（如image）时，会出现相同的图片（本来上传1张，但出现了2张＝＝）&lt;br&gt;
将上面的类的判断修改如下&lt;/p&gt;
&lt;p&gt;另外，针对image的上传后通过provider获取image图片时同一张图片给了2份，地址分别是&amp;quot;/storage/emulated/legacy/dcim/camera/1.jpg&amp;quot;和&amp;quot;/storage/sdcard0/DCIM/Camera/1.jpg&amp;quot;，其中legacy的属于兼容的，但获取能获取出来，所以获取时要进行过滤处理&lt;/p&gt;
&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;
&lt;p&gt;安卓系统的问题，android 4.2使用fuse技术/dev/fuse 会被挂载到/storage/emulated/0 目录，为了兼容以前的版本，同时挂载到 /storage/emulated/legacy （故名思议，传统的），还建立三个软连接 /storage/sdcard0 ，/sdcard，/mnt/sdcard ，都指向 /storage/emulated/legacy。也就是说文件夹0和legacy指向的地址是一致的，都是存储盘里的，楼主想放到哪个文件夹都可以。&lt;/p&gt;
&lt;h3 id=&#34;4&#34;&gt;4&lt;/h3&gt;
&lt;p&gt;In short: It has to do with the multi-user functionality introduced with Jelly Bean:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;/storage/emulated/0/: to my knowledge, this refers to the &amp;quot;emulated MMC&amp;quot; (&amp;quot;owner part&amp;quot;). Usually this is the internal one. The &amp;quot;0&amp;quot; stands for the user here, &amp;quot;0&amp;quot; is the first user aka device-owner. If you create additional users, this number will increment for each.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/storage/emulated/legacy/ as before, but pointing to the part of the currently working user (for the owner, this would be a symlink to /storage/emulated/0/). So this path should bring every user to his &amp;quot;part&amp;quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/sdcard/: According to a comment by Shywim, this is a symlink to...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/mnt/sdcard (Android &amp;lt; 4.0)&lt;/li&gt;
&lt;li&gt;/storage/sdcard0 (Android 4.0+)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/storage/sdcard0/: As there&#39;s no legacy pendant here (see comments below), the &amp;quot;0&amp;quot; in this case rather identifies the device (card) itself. One could, eventually, connect a card reader with another SDCard via OTG, which then would become /storage/sdcard1 (no proof for that, just a guess -- but I&#39;d say a good one)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Though one might get to the conclusion there should be a /storage/sdcard/legacy as well, there isn&#39;t (see comments) -- which completely makes sense with my assumption of the numbers here are not related to the user, but rather to possible multiple cards: &amp;quot;0&amp;quot; would always be the one in the card-slot of the device, so no need for a &amp;quot;legacy symlink&amp;quot; here.&lt;/p&gt;
">sdcard文件目录分析(含修正)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/scrollbarstyle-shu-xing-de-she-zhi-dui-scrollbar-wei-zhi-de-ying-xiang/"" data-c="
          &lt;p&gt;ScrollbarStyl总共有四个属性：insideoverlay， insideInset， outsideinset， outsideoverlay 。 借助这个属性，可以控制scrollbar的风格和位置。scrollbar可以被插入到一个视图里，也可以被置于一个视图的上层。同样，scrollbar可以被置于view的padding的区域，也可以置于view的padding之外的区域。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;分别具体说明四个属性对scrollbar的影响。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;insideoverlay: 以覆盖的方式将scrollbar置于padding区域内。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.insideInset:以插入的方式将scrollbar置于padding区域内。&lt;/p&gt;
&lt;p&gt;3.outsideoverlay:以覆盖的方式将scrollbar置于padding区域之外的view之上。&lt;/p&gt;
&lt;p&gt;4.outsideinset:以插入的方式将scrollbar置于padding区域之外view的边缘。&lt;/p&gt;
&lt;p&gt;下面是四个属性值具体应用情况：&lt;/p&gt;
&lt;p&gt;其中android:paddingRight=&amp;quot;10.0dp&amp;quot;.&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201516.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
"> Scrollbarstyle属性的设置对scrollbar位置的影响</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/react-native-pei-zhi-hou-yi-zhi-installing-react-native-package-from-npm/"" data-c="
          &lt;p&gt;已经进行到init项目阶段，但是一直&#39;Installing react-native package from npm...&#39; 没有反应了，没有报错等信息&lt;/p&gt;
&lt;!--more--&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201407.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;回答&#34;&gt;回答&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;http://react-native.cn/&lt;/p&gt;
&lt;p&gt;最专业的中文文档。&lt;/p&gt;
&lt;p&gt;关于楼主的问题，建议先设置npm镜像，在命令行下输入以下两条命令（很多人漏了第二条）：&lt;/p&gt;
&lt;p&gt;npm config set registry https://registry.npm.taobao.org&lt;br&gt;
npm config set disturl https://npm.taobao.org/dist&lt;br&gt;
如果还不行的话，可以尝试手动安装，看看问题到底出在哪里。&lt;/p&gt;
&lt;p&gt;手动安装第一步：建立目录&lt;/p&gt;
&lt;p&gt;mkdir MyProject&lt;br&gt;
cd MyProject&lt;br&gt;
第二步：创建package.json&lt;/p&gt;
&lt;p&gt;npm init&lt;br&gt;
然后按提示操作&lt;/p&gt;
&lt;p&gt;第三步：安装react-native依赖&lt;/p&gt;
&lt;p&gt;npm install react-native --save&lt;br&gt;
第四步： 初始化项目&lt;/p&gt;
&lt;p&gt;node -e &amp;quot;require(&#39;react-native/local-cli/cli&#39;).init(&#39;.&#39;,&#39;MyProject&#39;)&amp;quot;&lt;br&gt;
这样的话，如果某一步没有成功，你就可以看到详细的报错并提问。&lt;/p&gt;
&lt;p&gt;补充： 现在react-native-cli已经支持了--verbose参数，可以查看更多详细的过程和报错。&lt;/p&gt;
">React native配置后，一直'Installing react-native package from npm...'</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/qq-yin-le-ku-gou-yin-le-suo-ping-kong-zhi-shi-xian-yuan-li/"" data-c="
          &lt;p&gt;实现效果&lt;/p&gt;
&lt;!--more--&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;混乱的锁屏控制&#34;&gt;混乱的锁屏控制&lt;/h2&gt;
&lt;p&gt;Android自4.0版本, 也就是API level 14开始, 加入了锁屏控制的功能, 相关的类是RemoteControlClient, 这个类在API level 21中被标记为deprecated, 被新的类MediaSession所替代. 我们的音乐App中最开始使用的是原生锁屏控制API, 说实话这个API不好用, 遇到了一些小坑, 最要命的是不同品牌的手机, 锁屏界面长的还不一样, 就连我自己都没见过原生4.0的锁屏控制界面是什么样的. 国内的手机厂商都自以为自己的审美很强, 设计了千奇百怪的锁屏控制界面, MIUI更奇怪, MIUI 6是在原生4.4.4的基础上改的, 竟然有一段时间都没有锁屏控制界面, 后来更新才有. 而原生Android在5.0时, 将锁屏和通知栏控制合并, 整个逻辑非常混乱. 我们还是决定像QQ音乐/酷狗音乐那样, 自己做一个锁屏控制页面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题外话: 给RemoteControlClient设置封面时, 参数是一个Bitmap, 这个参数传入后, 千万不要在其他地方使用这个Bitmap, 也不要持有它的引用, 更不要自作聪明调用它的recycle方法.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实现思路&#34;&gt;实现思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;锁屏应用-大炮打蚊子&#34;&gt;锁屏应用: 大炮打蚊子&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先想到的因该是做一个锁屏, 也就是使用Android的API, 做一个锁屏应用, 和输入法等应用一样, 但这个方法成本很高. 国内的那些锁屏应用, 首先要做的就是引导用户设置锁屏应用, 步骤相当繁杂, 只是为了一个播放控制就用一个锁屏应用, 没有哪个用户会这么有耐心.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;悬浮窗-黑魔法&#34;&gt;悬浮窗: 黑魔法&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;得益于我国程序员的脑洞, 我们有了第二种思路: 悬浮窗.&lt;br&gt;
悬浮窗的一个比较严谨的名字叫系统警告窗口, 国内外的一些流氓厂商, 经常用悬浮窗弹一些广告, 这个悬浮窗是浮在正常的app的上面的, 所以如果它不消失, 很可能你连正常使用手机都有问题.&lt;br&gt;
这是一个比较打扰用户的东西, 而且也有一定的安全风险. MIUI的权限管理默认是将悬浮窗关闭的, 而有道词典的复制查词功能, 就是用悬浮窗做的, 如果你没给有道词典打开这个权限, 复制查词这个功能就废了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;普通activity伪造锁屏&#34;&gt;普通Activity伪造锁屏&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章开头的GIF图片展示的效果, 就是用一个普通Activity做的.&lt;br&gt;
国内的app们, 最终都选择了这条道路, 不知道他们是谁抄的谁, 第一个想到使用普通Activity伪造一个锁屏的开发者, 我只能说非常有创造力.&lt;/p&gt;
&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;
&lt;h3 id=&#34;监听锁屏事件&#34;&gt;监听锁屏事件&lt;/h3&gt;
&lt;p&gt;准确来说我们监听的是屏幕熄灭事件, 关屏事件的Intent是Intent.ACTION_SCREEN_OFF, 不需要任何权限就可以监听, 但是必须使用代码注册, 也就是说我们必须有一个Service在后台监听才行, 对音乐类app来说, 这不是问题, 音乐app本身就是使用Service来控制MediaPlayer的. 只需要在Service中注册监听Intent.ACTION_SCREEN_OFF就行. 监听到这个事件, 我们就启动一个Activity, 这就是我们的锁屏Activity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        Intent lockscreen = new Intent(PlaybackService.this, LockScreenActivity.class);
        lockscreen.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivity(lockscreen);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意我们在Service中启动一个Activity, 需要加上Intent.FLAG_ACTIVITY_NEW_TASK这个flag才行.&lt;/p&gt;
&lt;h3 id=&#34;透明背景&#34;&gt;透明背景&lt;/h3&gt;
&lt;p&gt;要想做到锁屏那样滑动解锁, 比如像图中的样子, 我们除了要根据手势移动View以外, 还要让Activity的背景透明, 比如将theme设置成下面这样.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;style name=&amp;quot;LockScreenBase&amp;quot; parent=&amp;quot;AppBaseTheme&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowIsTranslucent&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowBackground&amp;quot;&amp;gt;@android:color/transparent&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:colorBackgroundCacheHint&amp;quot;&amp;gt;@null&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowNoTitle&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:backgroundDimEnabled&amp;quot;&amp;gt;false&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowAnimationStyle&amp;quot;&amp;gt;@null&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowContentOverlay&amp;quot;&amp;gt;@null&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个style其实做了很多东西, 大家根据自己的需要可以删减一部分, 比如状态栏透明, 不使用TitleBar之类的.&lt;/p&gt;
&lt;h3 id=&#34;解锁屏幕与显示在锁屏之上&#34;&gt;解锁屏幕与显示在锁屏之上&lt;/h3&gt;
&lt;p&gt;在显示我们的假锁屏的时候, 我们应当帮用户解锁, 这样我们才能冒充锁屏, 而不会出现用户”解锁”两次的情况, 但我们只能要求系统解锁没有密码的锁屏, 有密码的情况下, 我们是不能解锁屏幕的, 这时我们应该覆盖在锁屏界面上, 幸好, 在API level 5中就引入了两个Flag, FLAG_DISMISS_KEYGUARD和FLAG_SHOW_WHEN_LOCKED&lt;br&gt;
在锁屏Activity的onCreate方法中给Activity加上两个Flag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一定要两个一起用, 否则效果不大好, 当时测试了好久, 后来看了一下QQ音乐的实现, 才发现两个一起用效果才好, 否则会有一些奇怪的问题.&lt;/p&gt;
&lt;h3 id=&#34;隐藏踪迹与独立的task&#34;&gt;隐藏踪迹与独立的Task&lt;/h3&gt;
&lt;p&gt;作为一个锁屏界面, 应当是独立的, 也就是说, 我们这个Activity应当独立于我们的App存在, 至少看起来是这样. 从Android的角度来看, 我们app的主界面里的所有Activity, 应当在一个Task里, 而锁屏Activity, 应当在一个独立的Task里, 因此我们需要给锁屏Activity一个独立的Task, 而且无论何时, 都只有一个锁屏Activity实例存在.&lt;br&gt;
另外, Android有查看近期任务的功能, 我们不希望锁屏界面这个独立的Task显示在里面, 所以锁屏Activity不能显示在近期任务中.&lt;br&gt;
说了这么多, 要做很简单, 只需要在Manifest里面声明Activity时加入几个属性即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;activity android:excludeFromRecents=&amp;quot;true&amp;quot;
    android:exported=&amp;quot;false&amp;quot;
    android:launchMode=&amp;quot;singleInstance&amp;quot;
    android:name=&amp;quot;.view.lockscreen.LockScreenActivity&amp;quot;
    android:screenOrientation=&amp;quot;portrait&amp;quot;
    android:taskAffinity=&amp;quot;com.package.name.lockscreen&amp;quot;
    android:theme=&amp;quot;@style/LockScreenTheme&amp;quot;&amp;gt;
&amp;lt;/activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的属性中android:excludeFromRecents=&amp;quot;true&amp;quot;让锁屏Activity不显示在近期任务中, android:launchMode=&amp;quot;singleInstance&amp;quot;和android:taskAffinity=&amp;quot;com.package.name.lockscreen&amp;quot;保证锁屏Activity有一个单独的Task, 且这个Task里永远只有它一个实例.&lt;/p&gt;
&lt;h3 id=&#34;不响应back按键&#34;&gt;不响应Back按键&lt;/h3&gt;
&lt;p&gt;锁屏界面当然不响应Back按键, 只需要重写Activity的onBackPressed方法即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onBackPressed() {
    // do nothing
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对home按键的处理&#34;&gt;对Home按键的处理&lt;/h3&gt;
&lt;p&gt;我们无法监听Home按键, 但是可以改变因Home进入后台时的处理, 比如在Manifest的activity声明中加上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;android:noHistory=&amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样如果用户通过Home按键让我们的应用进入后台, 我们会让这个activity销毁, 就像我们被滑动关闭一样.&lt;br&gt;
如果不加, 最好重写Activity的onNewIntent来应对因Home进入后台, 然后Service再次启动锁屏Activity的情况.&lt;/p&gt;
&lt;h3 id=&#34;处理黑色闪屏&#34;&gt;处理黑色闪屏&lt;/h3&gt;
&lt;p&gt;我们的锁屏Activity在滑动”解锁”之后, 理论上是直接进入下面的界面, 但有时如果下面不是launcher, 而是一个app, 有可能会闪一下黑屏, 这个其实是底下activity的入场动画导致的, 某些Android版本会对顶部activity透明时处理有些奇怪, 我们不能保证其他的应用不闪黑屏, 但是对自己的的应用还是可以的, 只需要在我们的主体activity的style中加上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;item name=&amp;quot;android:windowAnimationStyle&amp;quot;&amp;gt;@null&amp;lt;/item&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就不会有这种情况发生了, 但是这样的话入场动画也没了, 总之如何取舍看大家了.&lt;/p&gt;
">QQ音乐-酷狗音乐锁屏控制实现原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/intellij-idea-zi-dong-sheng-cheng-serialversionuid/"" data-c="
          &lt;p&gt;Setting-&amp;gt;Inspections-&amp;gt;Serialization issues-&amp;gt;Serializable class without ’serialVersionUID’&lt;br&gt;
选上以后，在你的class中：Alt+Enter就会提示自动创建serialVersionUID了。&lt;/p&gt;
&lt;!--more--&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201231.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Intellij IDEA 自动生成 serialVersionUID</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/hexo-mian-shu-ru-mi-ma-bu-shu-dao-github/"" data-c="
          &lt;p&gt;在使用(hexo d)命令部署hexo到github时，每次都要输入用户名和密码，这会使得你预览你博客的修改显得更加繁琐。下面的方法将使你摆脱这种痛苦。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;首先，在系统环境变量中设置一个环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HOME
%USERPROFILE%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下图：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201203.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接着在你的用户目录（C:\Users\username）下新建一个叫 _netrc的文件&lt;br&gt;
编辑这个文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;machine github.com
login username
password password
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置好这些后，当你再次部署时，就不用输入用户名和密码了。&lt;/p&gt;
">Hexo免输入密码部署到github</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/gradle-yi-lai-de-tong-yi-guan-li/"" data-c="
          &lt;p&gt;我想大部分人应该都在使用Gradle来依赖管理，还没有使用的去面壁思过，Gradle使用起来简直太好用了，举个例子，我们想依赖个support-v4包，直接一句话：&lt;/p&gt;
&lt;!--more--&gt;
&lt;pre&gt;&lt;code&gt;compile &#39;com.android.support:support-v4:23.1.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要太方便好么？&lt;/p&gt;
&lt;p&gt;但是不知道你们发现一些问题没有？比如以后v4版本号如果升级了怎么办？你可能会说直接手动改下版本号就好了，又不费多少精力。是的，只有这一个地方当然很简单，假设你项目里引用了三四个module，而这些module里也引用了v4包，那就要把所有依赖v4的包全部手动更改，这是一个项目，而如果你又是多个项目呢？这还只是一个v4包，假设又有多处地方依赖okhttp呢？而且下次所有的compileSdkVersion跟buildToolsVersion都要跟着升级呢？每次版本更新都要手动更改简直太麻烦了，而且还容易遗漏某些地方。那么今天就来给大家提供一种解决方案完全解决这种问题。&lt;/p&gt;
&lt;p&gt;我们如果根本性的解决这个问题肯定会想有没有一种通过一个配置文件来管理所有的Gradle依赖呢？哈哈，聪明，还真有这种方法，就不绕弯了，直接告诉你终极解决方案。&lt;/p&gt;
&lt;p&gt;我们以我在GitHub开源的项目9GAG为例，首先我们在项目的根目录创建一个gradle配置文件config.gradle，内容如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到这里包含了一些android和依赖的基本配置，以上都是gradle支持的语法，也许这里包含了所有你觉得好用的库，但是项目中只用到3、4个库也没关系，有了这个配置文件，以后所有的buildToolsVersion的升级还是依赖库的版本升级都在这里统一进行配置管理，所有的module以及主项目都从这里统一读取就ok了，那么接下来项目中怎么依赖这里的配置文件呢？&lt;/p&gt;
&lt;p&gt;其次看下项目根目录的build.gradle文件内容：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201100.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;只需在最顶部加上上面一行代码，意思就是所有的子项目或者所有的modules都可以从这个配置文件里读取内容。&lt;/p&gt;
&lt;p&gt;最后在到app目录下的build.gradle文件里看下具体如何读取的呢？&lt;/p&gt;
&lt;p&gt;android节点下的读取：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201111.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;denpendencies节点下的读取：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119201121.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;是不是很简单方便呢？以后所有的版本号或者配置的更改直接更改这个文件就好了，而且可以把所有项目中使用到或者可能使用到的第三方库都塞到这里管理，用到了就依赖，用不到就放里面就好了。&lt;/p&gt;
&lt;p&gt;所谓配置在手，天下我有！&lt;/p&gt;
">Gradle依赖的统一管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/google-guan-fang-android-mvp-jia-gou-shi-jian/"" data-c="
          &lt;h3 id=&#34;一-google-官方mvp介绍&#34;&gt;一、Google 官方MVP介绍&lt;/h3&gt;
&lt;p&gt;近期，关于Android开发架构的讨论沸沸扬扬，各大技术平台随处可见关于Android架构的技术文章。MVC、MVP、MVVM等等，就目前的形式来看，MVP模式在Android开发领域界逐渐流行了起来。前段时间，Google也忍耐不住Android MVP架构的火热程度，给广大Android程序员带来了福利，推出了Google官方MVP架构例子。源码见： https://github.com/googlesamples/android-architecture&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;官方给出了四种MVP架构模式：&lt;/p&gt;
&lt;p&gt;1、todo-mvp：MVP基础架构&lt;/p&gt;
&lt;p&gt;2、todo-mvp-loaders：基于MVP基础架构，获取数据部分使用了Loaders架构&lt;/p&gt;
&lt;p&gt;3、todo-mvp-databinding：基于MVP基础架构，使用了数据绑定组件&lt;/p&gt;
&lt;p&gt;4、todo-mvp-clean：基于MVP基础架构，引入Clean架构概念&lt;/p&gt;
&lt;p&gt;官方正在进行的MVP架构模式：&lt;/p&gt;
&lt;p&gt;1、todo-mvp-contentproviders：基于MVP基础架构，使用了Content Provider&lt;/p&gt;
&lt;p&gt;2、todo-mvp-dragger：基于MVP基础架构，使用dragger2依赖注入&lt;/p&gt;
&lt;p&gt;3、todo-mvp-rxjava：基于MVP基础架构，使用RxJava解决数据并发&lt;/p&gt;
&lt;h3 id=&#34;二-mvp架构模式介绍&#34;&gt;二、MVP架构模式介绍&lt;/h3&gt;
&lt;p&gt;MVP中的M代表Model，即数据层，V代表View，即界面层，P代表Presenter，负责关联Model和View，把Model层的数据显示到View。&lt;/p&gt;
&lt;h3 id=&#34;三-mvp架构实践&#34;&gt;三、MVP架构实践&lt;/h3&gt;
&lt;p&gt;这里，我从todo-mvp基础架构入手，模仿一下官方MVP源码，跟大家详细介绍一下Google官方MVP架构模式。官方的MVP示例源码展示的是一个简易便签，数据提供者是Sqlite数据库。我的项目里面数据提供者是网络，使用okhttp网络请求框架从服务器获取数据。一起来看看神奇的MVP架构模式是怎样把数据显示到手机界面的吧。&lt;/p&gt;
&lt;p&gt;google官方todo-mvp模式架构图(结合todo-mvp源码可以好好感受一下mvp的魅力)&lt;/p&gt;
&lt;p&gt;Presente基础接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BasePresenter {  
    void start();  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;View基础接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BaseView&amp;lt;T&amp;gt; {  
    void setPresenter(T presenter);  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体任务的Presener和View接口，Presenter接口里面封装的是数据获取的方法，需要数据提供者具体实现；View里面封装的方法是界面层(Fragment/Activity)要实现的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface TaskDetailContract {  
  
    //http://www.diandidaxue.com:8080/apiServer.do?opcode=getBeauty&amp;amp;pageNum=1&amp;amp;numPerPage=5  
    interface Presenter extends BasePresenter{  
        void loadBeauty(int pageIndex, int pageSize);  
    }  
  
    interface View extends BaseView&amp;lt;Presenter&amp;gt;{  
        void showProgress();  
        void hideProgress();  
        void showBeauty(List&amp;lt;Beauty&amp;gt; beautyList);  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据提供者，基于Okhttp请求，我这里使用的鸿洋大神封装好的Okhttp请求库。提供一个接口，将数据共享出去，提供给具体Presenter。&lt;/p&gt;
&lt;p&gt;Okhttp封装具体使用方法见：http://blog.csdn.net/lmj623565791/article/details/47911083&lt;/p&gt;
&lt;p&gt;数据提供的服务器是我自己搭建的一个阿里云服务器，为了平时开发方便，写了一个数据接口，可以获取大量的美女图片和文字信息，get和post请求都支持，便于开发时候做数据测试。数据接口地址：http://www.diandidaxue.com:8080/apiServer.do?opcode=getBeauty&amp;amp;pageNum=1&amp;amp;numPerPage=50&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ServerHelper {  
  
    private DataLoadListener listener;  
  
    public void getBeautyList(int pageIndex, int pageSize){  
        String url = &amp;quot;http://www.diandidaxue.com:8080/apiServer.do&amp;quot;;  
        Map&amp;lt;String, String&amp;gt; params = new HashMap&amp;lt;String, String&amp;gt;();  
        params.put(&amp;quot;opcode&amp;quot;, &amp;quot;getBeauty&amp;quot;);  
        params.put(&amp;quot;pageNum&amp;quot;, String.valueOf(pageIndex));  
        params.put(&amp;quot;numPerPage&amp;quot;, String.valueOf(pageSize));  
        OkHttpUtils.post().url(url).params(params).build().execute(new ListBeautyCallBack() {  
            @Override  
            public void onError(Call call, Exception e) {  
                listener.failure(e);  
            }  
  
            @Override  
            public void onResponse(List&amp;lt;Beauty&amp;gt; response) {  
                listener.success(response);  
            }  
        });  
    }  
  
    public interface DataLoadListener{  
        void failure(Exception e);  
        void success(List&amp;lt;Beauty&amp;gt; beautyList);  
    }  
  
    public void setListener(DataLoadListener listener) {  
        this.listener = listener;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体Presenter，实现了TaskDetailContract.Presenter和ServerHelper.DataLoadListener接口，关联了TaskDetailContract.View接口，把网络请求到的数据提供给View。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TaskPresenter implements TaskDetailContract.Presenter,ServerHelper.DataLoadListener {  
  
    private TaskDetailContract.View view;  
    private ServerHelper serverHelper;  
  
    //数据提供者 这里应该封装网络数据请求  
  
    public TaskPresenter(TaskDetailContract.View view) {  
        this.view = view;  
        view.setPresenter(this);  
        serverHelper = new ServerHelper();  
        serverHelper.setListener(this);  
    }  
  
    /** 
     * 请求网络数据 
     * @param pageIndex 页码 
     * @param pageSize 一页显示的数量 
     */  
    @Override  
    public void loadBeauty(final int pageIndex, int pageSize) {  
        serverHelper.getBeautyList(pageIndex,pageSize);  
    }  
  
    @Override  
    public void start() {  
  
    }  
  
    @Override  
    public void failure(Exception e) {  
        view.hideProgress();  
    }  
  
    @Override  
    public void success(List&amp;lt;Beauty&amp;gt; beautyList) {  
        view.hideProgress();  
        view.showBeauty(beautyList);  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体的View，这里的BeautyFragment实现了TaskDetailContract.View，使用TaskDetailContract.Presenter进行数据请求，View如果接受到数据，则对数据进行界面展示操作。这样保证了界面层只负责数据的显示，减少了界面层的数据逻辑处理，使得界面更加流畅。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BeautyFragment extends Fragment implements TaskDetailContract.View, SwipeRefreshLayout.OnRefreshListener {  
  
    private TaskDetailContract.Presenter presenter;  
    private SwipeRefreshLayout refreshLayout;  
    private RecyclerView recyclerView;  
    private BeautyAdapter adapter;  
    private List&amp;lt;Beauty&amp;gt; beautyList;  
    private int pageIndex = 1;  
    private int pageSize = 8;  
    private boolean isLastPage = false;  
    private int lastVisibleItem = 0;  
    private LinearLayoutManager linearLayoutManager;  
  
    public static BeautyFragment newInstance(){  
        return new BeautyFragment();  
    }  
  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        presenter = new TaskPresenter(this);  
        beautyList = new ArrayList&amp;lt;&amp;gt;();  
    }  
  
    @Override  
    public void onActivityCreated(Bundle savedInstanceState) {  
        super.onActivityCreated(savedInstanceState);  
    }  
  
    @Nullable  
    @Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {  
        View view = inflater.inflate(R.layout.fragment_beauty,container,false);  
        recyclerView = (RecyclerView) view.findViewById(R.id.tabRecyler);  
        refreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.tabSwipeRefresh);  
  
        linearLayoutManager = new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL,false);  
  
        //设置下拉刷新  
        refreshLayout.setColorSchemeColors(R.color.colorAccent);  
        refreshLayout.setOnRefreshListener(this);  
        //第一次进入界面时候加载进度条  
        refreshLayout.setProgressViewOffset(false, 0, (int) TypedValue  
                .applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24, getResources()  
                        .getDisplayMetrics()));  
        recyclerView.setLayoutManager(linearLayoutManager);  
        adapter = new BeautyAdapter(beautyList,getActivity());  
        recyclerView.setAdapter(adapter);  
  
        presenter.loadBeauty(1,8);  
  
  
        recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {  
            @Override  
            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {  
                super.onScrolled(recyclerView, dx, dy);  
                lastVisibleItem = linearLayoutManager.findLastVisibleItemPosition();  
            }  
  
            @Override  
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {  
                super.onScrollStateChanged(recyclerView, newState);  
                if (newState == RecyclerView.SCROLL_STATE_IDLE  
                        &amp;amp;&amp;amp; lastVisibleItem + 1 == adapter.getItemCount()) {  
                    Log.i(&amp;quot;pageIndex&amp;quot;,pageIndex+&amp;quot;&amp;quot;);  
                    //根据类目网络请求数据  
                    if(!isLastPage){  
                        presenter.loadBeauty(pageIndex,pageSize);  
                    }  
                }  
            }  
        });  
  
        return view;  
    }  
  
    @Override  
    public void showProgress() {  
        refreshLayout.setRefreshing(true);  
    }  
  
    @Override  
    public void hideProgress() {  
        refreshLayout.setRefreshing(false);  
    }  
  
    @Override  
    public void showBeauty(List&amp;lt;Beauty&amp;gt; list) {  
        ActivityUtils.checkNotNull(list);  
        if(list != null){  
            if(pageIndex == 1){  
                beautyList.clear();  
                beautyList.addAll(list);  
                isLastPage = false;  
                pageIndex ++;  
            }else if(list                                                                                                                                                                                                                   .size() == pageSize){  
                beautyList.addAll(list);  
                isLastPage = false;  
                pageIndex ++;  
            }else {  
                beautyList.addAll(list);  
                isLastPage = true;  
            }  
        }  
        adapter.notifyDataSetChanged();  
  
  
    }  
  
  
    @Override  
    public void setPresenter(TaskDetailContract.Presenter presenter) {  
        this.presenter = presenter;  
    }  
  
    @Override  
    public void onRefresh() {  
        pageIndex = 1;  
        presenter.loadBeauty(pageIndex,pageSize);  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BeautyActivity extends AppCompatActivity {  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_beauty);  
  
        BeautyFragment fragment = new BeautyFragment();  
        if(fragment == null){  
            fragment = BeautyFragment.newInstance();  
        }  
        ActivityUtils.addFragmentToActivity(getSupportFragmentManager(),fragment,R.id.container);  
  
    }  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，Google 官方MVP架构实践介绍完毕，希望对大家有收获。上述代码是实现MVP架构模式的关键代码，中间还涉及到的ActivityUtils等类都在源码中哦，欢迎大家下载。&lt;/p&gt;
&lt;p&gt;源码下载地址：https://github.com/xiaomanzijia/mvp&lt;/p&gt;
">Google 官方Android MVP架构实践</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/google-play-cong-fu-wu-qi-jian-suo-xin-xi-shi-chu-cuo-rh-01/"" data-c="
          &lt;p&gt;现象，安装google 服务框架后，用心版本google play出现：google play 从服务器检索信息时出错[RH-01]&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;root机器,安装 数据库编辑器_SQLite_Editor_2.0.1已付费版.apk,安装 Root_Explorer&lt;/li&gt;
&lt;li&gt;用root explorer打开&lt;code&gt;/data/data/com.google.android.gsf/databases/gservices.db&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个路径下的文件，点击gservices.db然后就能打开该文件，打开后能看到&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;main和其他一些东西，点击main&lt;/li&gt;
&lt;li&gt;然后点击右上角的“+”号，&lt;/li&gt;
&lt;li&gt;然后出来让输入name，和value&lt;/li&gt;
&lt;li&gt;name中输入 android_id&lt;/li&gt;
&lt;li&gt;value 中输入 16位（理论应该是19位，。。。）的数字比如，3456876923148734&lt;/li&gt;
&lt;li&gt;然后点击save保存，然后重启机器 google play就好了，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不要乱修改别的东西，会把系统搞死的,这种解决办法其实还是有问题的，但是可以让你的google play正常使用.&lt;/p&gt;
">google play 从服务器检索信息时出错[RH-01]</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/coordinatorlayout-de-shi-yong-ru-ci-jian-dan/"" data-c="
          &lt;p&gt;曾在网上找了一些关于CoordinatorLayout的教程，大部分文章都是把CoordinatorLayout、AppbarLayout、CollapsingToolbarLayout 以及Toolbar等一起使用来介绍，这让我不知不觉在心中认为把这几个布局要一起使用，而且只是用于那种场景中。其实CoordinatorLayout的功能并不是局限于与AppBarLayout一起使用，它的功能强大着呢，本文主要对CoordinatorLayout的使用进行介绍，后面再写一篇文章将AppBarLayout和CollapsingToolBarLayout整合CoordinatorLayout一起。那么到底CoordinatorLayout有多好用，请往下感受吧~&lt;/p&gt;
&lt;p&gt;转自:&lt;a href=&#34;http://blog.csdn.net/huachao1001/article/details/51554608&#34;&gt;http://blog.csdn.net/huachao1001/article/details/51554608&lt;/a&gt;&lt;/p&gt;
">CoordinatorLayout的使用如此简单</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/constraintlayout-wan-quan-jie-xi/"" data-c="
          &lt;p&gt;以前每次新建as项目都看到ConstraintLayout,一直也没学习过,今天特意看了看,学习了一下.&lt;/p&gt;
&lt;p&gt;总结要点:可视化,拖拽控件,调整控件.&lt;/p&gt;
&lt;p&gt;转自郭霖大神.&lt;a href=&#34;http://blog.csdn.net/guolin_blog/article/details/53122387&#34; title=&#34;ConstraintLayout完全解析&#34;&gt;ConstraintLayout完全解析&lt;/a&gt;&lt;/p&gt;
">ConstraintLayout完全解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/cmd-he-git-zhong-de-dai-li-she-zhi/"" data-c="
          &lt;h3 id=&#34;cmd-设置代理&#34;&gt;CMD 设置代理&lt;/h3&gt;
&lt;p&gt;在 cmd 环境下设置代理可能不是很常用，但是某些情况下还是可能会用到，比如公司的电脑只能通过设置代理访问外网，而你需要在 cmd 环境下使用 gem 命令更新文件时。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;当然，如果你使用某些代理软件为所有通讯设置了代理，那就不需要这些设置了。&lt;/p&gt;
&lt;p&gt;为 cmd 设置代理很简单，首先打开 cmd （win + R，输入 cmd，然后按 enter 键），然后输入如下命令：&lt;br&gt;
set http_proxy=http://proxy.yourname.com:8080&lt;/p&gt;
&lt;p&gt;其中 http://proxy.yourname.com 是你的代理服务器地址，而 8080 是端口号，如果有则设置。另外，如果你的代理服务器要求用户名和密码的话，那么还需要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set http_proxy_user=
set http_proxy_pass=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置完成后，就可以在 cmd 下正常使用网络了。&lt;/p&gt;
&lt;h3 id=&#34;git-设置代理&#34;&gt;Git 设置代理&lt;/h3&gt;
&lt;p&gt;Git 的代理设置也非常简单，一句话就搞定了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global http.proxy http://10.10.10.10:8080 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要用户名密码的话，则设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config –global http.proxy http://user:password@http://10.10.10.10:8080 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 user 和 password 分别为你的用户名和密码。&lt;/p&gt;
&lt;p&gt;设置完成后，可以通过如下命令来查看设置是否生效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config –get –global http.proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果某一天你不喜欢她了，需要删除代理设置，那么可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --system (或 --global 或 --local) --unset http.proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来删除设置。&lt;/p&gt;
&lt;p&gt;PS：有些同学可能使用的 Git 的客户端，比如界面很上流的 Github for Windows，里面可能并没有代理设置的选项，不过别着急，这些客户端一般在底层都是调用的命令行工具，所以同样按照上述步骤进行设置即可。&lt;/p&gt;
">CMD 和 Git 中的代理设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/attrstyle-he-theme-xiang-jie/"" data-c="
          &lt;p&gt;转自:&lt;a href=&#34;http://www.jianshu.com/p/dd79220b47dd&#34;&gt;http://www.jianshu.com/p/dd79220b47dd&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;这三个概念贯穿Android框架的方方面面，是Android程序设计中很重要的一环，理解它们，并能学以致用，不但可以让你的代码变得简洁明了，还可以让你的应用更加灵活。但目前网上资料对这块介绍的知识点往往比较散，不是很系统全面，在此特以自己开发经验总结此文一篇，希望可以帮助初学者把这三个概念彻底搞明白，开发出高质量的Android代码。&lt;/p&gt;
&lt;h3 id=&#34;概念说明&#34;&gt;概念说明&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Attr&lt;/strong&gt;：属性，风格样式的最小单元；&lt;br&gt;
&lt;strong&gt;Style&lt;/strong&gt;：风格，它是一系列Attr的集合用以定义一个View的样式，比如height、width、padding等；&lt;br&gt;
&lt;strong&gt;Theme&lt;/strong&gt;：主题，它与Style作用一样，不同于Style作用于个一个单独View，而它是作用于Activity上或是整个应用。&lt;/p&gt;
&lt;h3 id=&#34;attr的定义&#34;&gt;Attr的定义&lt;/h3&gt;
&lt;p&gt;我们先举一个框架中的源码例子，用来介绍下Android中是如何定义一个Attr的，比如以下创建一个简单的TextView布局&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119192328.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其中layout_width对应到框架中的attr信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;declare-styleable name=&amp;quot;ViewGroup_Layout&amp;quot;&amp;gt;
    &amp;lt;attr name=&amp;quot;layout_width&amp;quot; format=&amp;quot;dimension&amp;quot;&amp;gt;
        &amp;lt;enum name=&amp;quot;fill_parent&amp;quot; value=&amp;quot;-1&amp;quot; /&amp;gt;
        &amp;lt;enum name=&amp;quot;match_parent&amp;quot; value=&amp;quot;-1&amp;quot; /&amp;gt;
        &amp;lt;enum name=&amp;quot;wrap_content&amp;quot; value=&amp;quot;-2&amp;quot; /&amp;gt;
    &amp;lt;/attr&amp;gt;
    ...
&amp;lt;/declare-styleable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上可以看到layout_width可以使用三个枚举值，并且其中fill_parent和match_parent的value值都为-1。做过Android开发的童鞋肯定知道，从2.2开始Android框架就推荐用match_parent代替fill_parent，而以上代码正实现了兼容，因为它们对应的值都为-1。&lt;/p&gt;
&lt;p&gt;以上的textStyle的属性信息在源码中如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;attr name=&amp;quot;textStyle&amp;quot;&amp;gt;
    &amp;lt;flag name=&amp;quot;normal&amp;quot; value=&amp;quot;0&amp;quot; /&amp;gt;
    &amp;lt;flag name=&amp;quot;bold&amp;quot; value=&amp;quot;1&amp;quot; /&amp;gt;
    &amp;lt;flag name=&amp;quot;italic&amp;quot; value=&amp;quot;2&amp;quot; /&amp;gt;
&amp;lt;/attr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它也对应了三个值，但这里却使用了flag标签。细心的童鞋可能已经明白了flag与enum的差别，flag表示这几个值可以做或运算，比如上面的textStyle，你可以叠加使用，如用bold|italic表示既加粗也变成斜体，而enum只能让你选择其中一个值。&lt;/p&gt;
&lt;p&gt;看完上例后，我们来试着自己自定义一个自己的属性，在values目录下创建一个attrs.xml文件，在&lt;resources&gt;元素里面首先申明一个自己的&lt;declare-styleable&gt;表示一个属性组，再在里面加上属性就行。如下我们定义一个DogStyle的属性组，其中有三个属性一个是dogSex，一个是dogName，dogName的格式我们设置为string，最后一个是dogColor，这样一个属于我们自己的属性就定义成功了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119192344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;attr的format根据字面意思也挺容易理解的，这里我解释下reference的用法。它用在一些可以设置引用值的情况，比如@drawable/myImage、@color/myColor等。当然format也可以进行或运算，一般我们定义color类型的属性时，也一般会把format写成format=&amp;quot;reference|color&amp;quot;，这样我们不但可以设置颜色值，如#FFFFFF，还可以使用我们自己定义的狗图片，如@drawable/dog_pic。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TIPS：format即使用错，只要你自定义的View中获取对应类型值也是可以的，只是在布局中写代码时，IDE就不会根据你定义的format给出相应的提示了，所以最好在自定义View时还是仔细斟酌下类型。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;style的使用&#34;&gt;Style的使用&lt;/h3&gt;
&lt;p&gt;如下我们在styles.xml中定义一个雪纳瑞风格&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;style name=&amp;quot;SchnauzerStyle&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;dogName&amp;quot;&amp;gt;雪纳瑞&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;dogColor&amp;quot;&amp;gt;@drawable/schnauzer&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;dogSex&amp;quot;&amp;gt;boy&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们看下如何让一个Style作用在一个View上的。&lt;br&gt;
首先我们自定义了一个View命名为DogView，然后创建一个布局文件中加入该DogView视图，并让该View使用SchnauzerStyle风格。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;cn.hadcn.test.DogView
    style=&amp;quot;@style/SchnauzerStyle&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移步到DogView的Java代码中，我们可以通过theme的obtainStyledAttributes方法来获得我们刚刚定义的几个Attr属性在Style中的内容，如下我们举一个获得dogName的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Resources.Theme theme = context.getTheme();
TypedArray dogArray = theme.obtainStyledAttributes(attrs, R.styleable.DogStyle, defStyleAttr, defStyleRes);

String name = dogArray.getString(R.styleable.DogStyle_dogName);
Log.e(&amp;quot;dog&amp;quot;, &amp;quot;name = &amp;quot; + name);

dogArray.recycle();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上obtainStyledAttributes有四个入参，前两个比较容易理解，后两个用作指定默认的Style，表示如果attrs中没有你想获得的属性，但如果你指定了默认Style，它会去从该默认的Style里面找你想要的属性。defStyleAttr和defStyleRes功能一样，指定的资源形式不同，前者表示一个默认的指向一个style风格的attr属性，而后者你可以直接传入一个style风格的id。注意以上定义的Style只能在这个DogView中被使用，如果你想在其他View使用，就需要再在需要使用的View中增加这个Style。这就是先前我们说的Style只能作用于一个View。&lt;/p&gt;
&lt;h3 id=&#34;theme的使用&#34;&gt;Theme的使用&lt;/h3&gt;
&lt;p&gt;Theme与Style使用同一个元素标签&amp;lt;style&amp;gt;，区别在于所包含的属性不同，并且使用的地方也不一样。Theme你需要设置到AndroidManifest.xml的&lt;application&gt;或者&lt;activity&gt;标签下，设置后，被设置的Activity或整个应用下所有的View都可以使用该&amp;lt;style&amp;gt;里面的属性了。&lt;/p&gt;
&lt;p&gt;比如在上例中，我们直接把SchnauzerStyle设置到&lt;activity&gt;标签中，并把布局文件中DogView元素的style=&amp;quot;@style/SchnauzerStyle&amp;quot;栏位删除，以此来测试下，这个Activity下的所有View是不是可以直接使用theme中声明的这些属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;activity
    android:name=&amp;quot;.MainActivity&amp;quot;
    android:theme=&amp;quot;@style/SchnauzerStyle&amp;quot;&amp;gt;
    ...
&amp;lt;/activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上理论上是可行的，不过运行后，程序却出现奔溃，出现以下错误提示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有些同学一眼可能就看出，因为在这里Activity或Application的需要很多属性才能工作的，而此处我们只给它传一个SchnauzerStyle，这当然不行，所以我们需要对这个Style做下处理，让SchnauzerStyle继承一个系统主题，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;style name=&amp;quot;SchnauzerStyle&amp;quot; parent=&amp;quot;Theme.AppCompat&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;dogName&amp;quot;&amp;gt;雪纳瑞&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;dogColor&amp;quot;&amp;gt;@drawable/schnauzer&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;dogSex&amp;quot;&amp;gt;boy&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一个雪纳瑞主题就诞生了，而在这个Activity下的所有View都可以用雪纳瑞的信息了。Application中定义theme的原理一样，这里就不多说了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TIPS：框架使用Attr的顺序是：View中的Style会优先于Activity中的Theme，Activity中的Theme会优先于Application中的Theme，所以说你可以定义整个应用的总体风格，但局部风格你也可以做出自己的调整。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;attr的获得方法&#34;&gt;Attr的获得方法&lt;/h3&gt;
&lt;p&gt;有些情况下，我们可能需要使用theme中的属性值，比如下面我们想让一个TextView直接显示dogName这个属性的内容，并且使用系统字体的颜色，则可以如下做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;TextView
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:textColor=&amp;quot;?android:textColorSecondary&amp;quot;
    android:text=&amp;quot;?attr/dogName&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获得一个Attr的方法，不同于普通资源使用@符号获得的方式，而是需要使用?符号来获得属性，整体的表达方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?[*&amp;lt;package_name&amp;gt;*:][*&amp;lt;resource_type&amp;gt;*/]*&amp;lt;resource_name&amp;gt;*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是本应用中的attr使用，则可以省去&amp;lt;package_name&amp;gt;部分。&lt;/p&gt;
&lt;p&gt;此处的textColor使用当前主题的android:textColorSecondary属性内容。因为资源工具知道此处是一个属性，所以省去了attr （完整写法：?android:attr/textColorSecondary）。&lt;/p&gt;
">Attr、Style和Theme详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/anroid-dong-tai-jia-zai-ji-zhu-xi-lie-suo-yin/"" data-c="
          &lt;p&gt;转载自:&lt;a href=&#34;https://link.zhihu.com/?target=https://github.com/kaedea&#34;&gt;https://link.zhihu.com/?target=https://github.com/kaedea&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;动态加载介绍&#34;&gt;动态加载介绍&lt;/h2&gt;
&lt;p&gt;说到动态加载，我们经常使用“插件化”、“热修复”、“热部署”等词汇，所以大家应该不会陌生。本系列的文章的主要目的是分析一下整个动态加载的过程，重点分析其中的关键技术点，并且开发一个比较灵活的动态加载框架，用于满足不同程度的业务需求。&lt;/p&gt;
&lt;p&gt;在Android开发中采用动态加载技术，可以达到不安装新的APK就升级APP功能的目的，可以用来到达快速发版的目的，也可以用来修复一些紧急BUG。&lt;/p&gt;
&lt;p&gt;现在使用得比较广泛的动态加载技术的核心一般都是使用 ClassLoader ，后者能够加载程序外部的类（已编译好的），从而达到升级代码逻辑的目的。虽然动态加载的核心原理比较简单，但是根据功能的复杂程度，实际在Android项目中使用的时候还要涉及许多其他方面的知识，这里分为几个篇幅分别进行介绍。&lt;/p&gt;
&lt;h3 id=&#34;1-简单易懂的介绍&#34;&gt;1. 简单易懂的介绍&lt;/h3&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态加载技术在Android中的使用背景；&lt;/li&gt;
&lt;li&gt;Android的动态的加载大致可以分为“加载SO库”和“加载DEX/JAR/APK”两种；&lt;/li&gt;
&lt;li&gt;动态加载的基础是类加载器ClassLoader；&lt;/li&gt;
&lt;li&gt;使用动态加载的三种模式；&lt;/li&gt;
&lt;li&gt;采用动态加载的作用与代价；&lt;/li&gt;
&lt;li&gt;除了ClassLoader之外的动态修改代码的技术（HotFix）；&lt;/li&gt;
&lt;li&gt;一些动态加载的开源项目；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20515156&#34;&gt;简单易懂的介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-动态加载的分类&#34;&gt;2. 动态加载的分类&lt;/h3&gt;
&lt;p&gt;内容：介绍一下动态加载的类型，理清一下动态加载、插件化、热部署、热修复等技术之间的关系。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20893580&#34;&gt;动态加载的分类&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-类加载器classloader的工作机制&#34;&gt;3. 类加载器ClassLoader的工作机制&lt;/h3&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类加载器ClassLoader的创建过程和加载类的过程；&lt;/li&gt;
&lt;li&gt;ClassLoader的双亲代理模式；&lt;/li&gt;
&lt;li&gt;DexClassLoader和PathClassLoader之间的区别；&lt;/li&gt;
&lt;li&gt;使用ClassLoader加载外部类需要注意的一些问题；&lt;/li&gt;
&lt;li&gt;自定义ClassLoader（Hack开发）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20524252&#34;&gt;ClassLoader的工作机制&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-加载sd卡的so库&#34;&gt;4. 加载SD卡的SO库&lt;/h3&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何编译和使用SO库；&lt;/li&gt;
&lt;li&gt;分析Android中加载SO库相关的源码；&lt;/li&gt;
&lt;li&gt;如何加载SD卡中的SO库（也是动态加载APK需要解决的问题）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/21303038&#34;&gt;加载SD卡的SO库&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-使用so库时需要注意的一些问题&#34;&gt;5. 使用SO库时需要注意的一些问题&lt;/h3&gt;
&lt;p&gt;内容：介绍使用SO库开发时的一些坑，提供从网络下载并加载SO库的策略。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/21302804&#34;&gt;加载SD卡的SO库&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-简单的动态加载模式&#34;&gt;6. 简单的动态加载模式&lt;/h3&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何创建我们需要的dex文件；&lt;/li&gt;
&lt;li&gt;如何加载dex文件里面的类；&lt;/li&gt;
&lt;li&gt;动态加载dex文件在ART虚拟机的兼容性问题；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://link.zhihu.com/?target=http://segmentfault.com/a/1190000004062952&#34;&gt;简单加载模式&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-代理activity的模式&#34;&gt;7. 代理Activity的模式&lt;/h3&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何启动插件APK中没有注册的Activity&lt;/li&gt;
&lt;li&gt;代理Activity模式开源项目“dynamic-load-apk”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/21335594&#34;&gt;代理Activity模式&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;8-动态创建activity的模式&#34;&gt;8. 动态创建Activity的模式&lt;/h3&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何在运行时动态创建一个Activity；&lt;/li&gt;
&lt;li&gt;自定义ClassLoader并偷梁换柱替换想要加载的类；&lt;/li&gt;
&lt;li&gt;动态创建Activity模式开源项目“android-pluginmgr”&lt;/li&gt;
&lt;li&gt;代理模式与动态创建类模式的区别；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/21348609&#34;&gt;动态创建Activity模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还未发布的内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用“环境注入”的模式；&lt;/li&gt;
&lt;li&gt;使用动态加载技术的情形；&lt;/li&gt;
&lt;li&gt;使用动态加载方式项目的项目结构调整和开发调试方式；&lt;/li&gt;
&lt;li&gt;开源项目“Android-Frontia”，动态加载框架的项目，特点是专注于“插件化”和“宿主与插件之间的通讯”、灵活的扩展和使用方式，并提供完整的插件更新、安装和管理策略；&lt;/li&gt;
&lt;/ol&gt;
">ANROID动态加载技术 系列索引</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-huo-qu-view-gao-du-de-san-chong-fang-shi/"" data-c="
          &lt;p&gt;这篇文章主要为大家详细介绍了Android获取view高度的三种方式,感兴趣的小伙伴们可以参考一下&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;getmeasuredheight与getheight的区别&#34;&gt;getMeasuredHeight()与getHeight的区别&lt;/h3&gt;
&lt;p&gt;实际上在当屏幕可以包裹内容的时候，他们的值相等，只有当view超出屏幕后，才能看出他们的区别：&lt;br&gt;
getMeasuredHeight()是实际View的大小，与屏幕无关，而getHeight的大小此时则是屏幕的大小。&lt;br&gt;
当超出屏幕后，getMeasuredHeight()等于getHeight()加上屏幕之外没有显示的大小.&lt;/p&gt;
&lt;h3 id=&#34;具体方法&#34;&gt;具体方法&lt;/h3&gt;
&lt;p&gt;我们知道在oncreate中View.getWidth和View.getHeight无法获得一个view的高度和宽度，这是因为View组件 布局要在onResume回调后完成。&lt;br&gt;
下面说三种方式&lt;/p&gt;
&lt;h4 id=&#34;getviewtreeobserver&#34;&gt;getViewTreeObserver&lt;/h4&gt;
&lt;p&gt;使用 getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度。OnGlobalLayoutListener 是ViewTreeObserver的内部类，当一个视图树的布局发生改变时，可以被ViewTreeObserver监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。ViewTreeObserver不能直接实例化，而是通过getViewTreeObserver()获得。&lt;/p&gt;
&lt;p&gt;除了OnGlobalLayoutListener ，ViewTreeObserver还有如下内部类：&lt;br&gt;
interfaceViewTreeObserver.OnGlobalFocusChangeListener&lt;/p&gt;
&lt;p&gt;当在一个视图树中的焦点状态发生改变时，所要调用的回调函数的接口类&lt;br&gt;
interfaceViewTreeObserver.OnGlobalLayoutListener&lt;br&gt;
当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类&lt;br&gt;
interfaceViewTreeObserver.OnPreDrawListener&lt;br&gt;
当一个视图树将要绘制时，所要调用的回调函数的接口类&lt;br&gt;
interfaceViewTreeObserver.OnScrollChangedListener&lt;br&gt;
当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类&lt;br&gt;
interfaceViewTreeObserver.OnTouchModeChangeListener&lt;br&gt;
当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类&lt;br&gt;
其中，我们可以利用OnGlobalLayoutListener来获得一个视图的真实高度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private int mHeaderViewHeight; 
private View mHeaderView; 
 
..... 
 
mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener( 
 	new OnGlobalLayoutListener() { 
  	@Override 
  	public void onGlobalLayout() { 
		   mHeaderViewHeight = mHeaderView.getHeight(); 
		   mHeaderView.getViewTreeObserver().removeGlobalOnLayoutListener(this); 
  	} 
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是需要注意的是OnGlobalLayoutListener可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener注销掉。&lt;/p&gt;
&lt;h4 id=&#34;view-post事件中获取&#34;&gt;View post事件中获取&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;还可以在VIew的post方法中获取&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestHeight extends Activity { 
	 TextView tv; 
	 
	 @Override 
	 protected void onCreate(Bundle savedInstanceState) { 
		  super.onCreate(savedInstanceState); 
		  setContentView(R.layout.activity_activity_b); 
		  tv = (TextView) findViewById(R.id.textView); 
		  tv.post(new Runnable() { 
			   @Override 
			   public void run() { 
			    int height= tv.getHeight(); 
			   } 
		  }); 
	 } 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;直接测量计算&#34;&gt;直接测量计算&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int intw=View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED); 
int inth=View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED); 
textView.measure(intw, inth); 
int intwidth = textView.getMeasuredWidth(); 
int intheight = textView.getMeasuredHeight();
&lt;/code&gt;&lt;/pre&gt;
">Android获取view高度的三种方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-xi-tong-biao-zhun-yin-le-jie-kou/"" data-c="
          &lt;p&gt;在自己写完音乐软件之后,可以实现安卓标准播放接口,把控制权交给第三方软件使用.&lt;/p&gt;
&lt;p&gt;实现思路要分版本,一种是在安卓5.0以下,基于RemoteControlClient实现,另一种是在5.0以上,基于MediaSession实现.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;1-基于remotecontrolclient实现&#34;&gt;1 . 基于RemoteControlClient实现.&lt;/h1&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SuppressWarnings(&amp;quot;deprecation&amp;quot;)
public class RemoteControlResponse {

	private final static String TAG = &amp;quot;MediaSessonResponse&amp;quot;;
	private static RemoteControlResponse remoteControlResponse = null;
	private static RemoteControlClient remoteClient = null;
	public static RemoteControlResponse getInstance() {
		if (remoteControlResponse == null) {
			remoteControlResponse = new RemoteControlResponse();
		}
		return remoteControlResponse;
	}
	
	public void init(){
		if (remoteClient==null) {
			 AudioManager myAudioManager = (AudioManager) App.getInstance().getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
			 Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
			 PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(App.getInstance().getApplicationContext(), 0, mediaButtonIntent, 0);
			 remoteClient = new RemoteControlClient(mediaPendingIntent);
			 myAudioManager.registerRemoteControlClient(remoteClient);
		}
		MessageManager.getInstance().attachMessage(MessageID.OBSERVER_PLAYCONTROL, playControlObserver);
		MessageManager.getInstance().attachMessage(MessageID.OBSERVER_APP, appObserver);
		MessageManager.getInstance().attachMessage(MessageID.OBSERVER_LYRICS, mLyricsObserver);
		
	}
	
	private void release(){
		MessageManager.getInstance().detachMessage(MessageID.OBSERVER_PLAYCONTROL, playControlObserver);
		MessageManager.getInstance().detachMessage(MessageID.OBSERVER_APP, appObserver);
		MessageManager.getInstance().detachMessage(MessageID.OBSERVER_LYRICS, mLyricsObserver);
	}
	
	private void setPlayState(int state){
		remoteClient.setPlaybackState(state);
	}
	
	@SuppressLint(&amp;quot;InlinedApi&amp;quot;)
	private void setMusicData(){
		
		RemoteControlClient.MetadataEditor ed = remoteClient.editMetadata(true);
		Music music = ModMgr.getPlayControl().getNowPlayingMusic();
		if (music==null) {
			return;
		}
		ed.putString(MediaMetadataRetriever.METADATA_KEY_TITLE,music.name);
		ed.putString(MediaMetadataRetriever.METADATA_KEY_ARTIST,music.artist);
		ed.putString(MediaMetadataRetriever.METADATA_KEY_ALBUM,music.album);
		ed.putLong(MediaMetadataRetriever.METADATA_KEY_DURATION, music.duration);
		Bitmap b = ModMgr.getLyricsMgr().getHeadPic();
		if (b != null) {
			Bitmap.Config config = b.getConfig();
			if (config == null) {
				config = Bitmap.Config.ARGB_8888;
			}
			b = b.copy(config, false);
			ed.putBitmap(MetadataEditor.BITMAP_KEY_ARTWORK, b);
		}
		ed.apply();
		
	}
	
	//设置音乐播放状态
	private PlayControlObserver playControlObserver = new PlayControlObserver(){
		@Override
		public void IPlayControlObserver_RealPlay(Music music) {
			setPlayState((int)RemoteControlClient.PLAYSTATE_PLAYING);
		}

		@Override
		public void IPlayControlObserver_Pause() {
			setPlayState((int)RemoteControlClient.PLAYSTATE_PAUSED);
		}
		
		@Override
		public void IPlayControlObserver_Continue() {
			setPlayState((int)RemoteControlClient.PLAYSTATE_PLAYING);
		}
		@Override
		public void IPlayControlObserver_PlayStop(boolean end) {
			setPlayState((int)RemoteControlClient.PLAYSTATE_STOPPED );
		}
	};
	
	//程序退出的时候释放资
	private AppObserver appObserver = new AppObserver() {
		@Override
		public void IAppObserver_PrepareExitApp() {
			release();
		}
	};
	
	//在播放歌曲的时候设置音乐资源到系统
	private ILyricsObserver mLyricsObserver = new ILyricsObserver(){

		@Override
		public void ILyricObserver_Lyrics(DownloadStatus status, ILyrics lyrics, ILyrics extLyrics, boolean isManually) {
			
		}

		@Override
		public void ILyricObserver_SearchList(DownloadStatus status, List&amp;lt;LyricsListItem&amp;gt; lyricsList) {
			
		}

		@Override
		public void ILyricObserver_HeadPic(DownloadStatus status, Bitmap bitmap) {
			if (!DownloadStatus.BEGIN.equals(status)) {
				setMusicData();
			}
			
		}

		@Override
		public void ILyricObserver_BackgroundPic(DownloadStatus status, Bitmap bitmap, boolean isManually) {
			
		}

		@Override
		public void ILyricObserver_AutoDownloadFinished(Music m) {
			
		}

		@Override
		public void ILyricObserver_AutoDownloadNotify(int alreadyDownloadCout, int sumDownloadCount) {
			
		}	
	};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-使用mediasession实现&#34;&gt;2  .使用MediaSession实现&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MediaSessonResponse {
	
	private final static String TAG = &amp;quot;MediaSessonResponse&amp;quot;;
	private static MediaSessonResponse mediaSessonResponse = null;
	private static MediaSession mediaSession = null;
	public static MediaSessonResponse getInstance() {
		if (mediaSessonResponse == null) {
			mediaSessonResponse = new MediaSessonResponse();
		}
		return mediaSessonResponse;
	}

	public void init(){
		if (mediaSession==null) {
			mediaSession = new MediaSession(App.getInstance().getApplicationContext(), TAG);
			mediaSession.setActive(true);
			Intent openintent = new Intent(App.getInstance().getApplicationContext(), HeadsetControlReceiver.class);
			PendingIntent pi = PendingIntent.getBroadcast(App.getInstance().getApplicationContext(), 0, openintent, PendingIntent.FLAG_CANCEL_CURRENT);
			mediaSession.setMediaButtonReceiver(pi);
			
		}
		MessageManager.getInstance().attachMessage(MessageID.OBSERVER_PLAYCONTROL, playControlObserver);
		MessageManager.getInstance().attachMessage(MessageID.OBSERVER_APP, appObserver);
		MessageManager.getInstance().attachMessage(MessageID.OBSERVER_LYRICS, mLyricsObserver);
	}
	private void release(){
		mediaSession.release();
		MessageManager.getInstance().detachMessage(MessageID.OBSERVER_PLAYCONTROL, playControlObserver);
		MessageManager.getInstance().detachMessage(MessageID.OBSERVER_APP, appObserver);
		MessageManager.getInstance().detachMessage(MessageID.OBSERVER_LYRICS, mLyricsObserver);
	}
	
	private Callback callback = new Callback() {
		@Override
		public void onPlay() {
			ModMgr.getPlayControl().continuePlay();
        }
		@Override
		public void onPause() {
			ModMgr.getPlayControl().pause();
		}
		@Override
		public void onSkipToNext() {
			ModMgr.getPlayControl().playNext();
		}
		@Override
		public void onSkipToPrevious() {
			ModMgr.getPlayControl().playPre();
		}
	};
	
	
	private void setMusicData(){
		Builder builder = new Builder();
		Music music = ModMgr.getPlayControl().getNowPlayingMusic();
		if (music==null) {
			return;
		}
		builder.putBitmap(MediaMetadata.METADATA_KEY_DISPLAY_ICON, ModMgr.getLyricsMgr().getHeadPic());
		builder.putString(MediaMetadata.METADATA_KEY_ALBUM_ARTIST, music.artist);
		builder.putString(MediaMetadata.METADATA_KEY_TITLE, music.name);
		MediaMetadata mediaMetadata = builder.build();
		mediaSession.setMetadata(mediaMetadata);
	}
	
	private void setPlayState(int state){
		PlaybackState.Builder builder = new PlaybackState.Builder();
		builder.setState(state, 0, 0);
		PlaybackState playbackState = builder.build();
		mediaSession.setPlaybackState(playbackState);
	}
	
	
	private PlayControlObserver playControlObserver = new PlayControlObserver(){
		@Override
		public void IPlayControlObserver_RealPlay(Music music) {
			setPlayState((int)PlaybackState.STATE_PLAYING);
		}

		@Override
		public void IPlayControlObserver_Pause() {
			setPlayState((int)PlaybackState.STATE_PAUSED);
		}
		
		@Override
		public void IPlayControlObserver_Continue() {
			setPlayState((int)PlaybackState.STATE_PLAYING);
		}
		@Override
		public void IPlayControlObserver_PlayStop(boolean end) {
			setPlayState((int)PlaybackState.STATE_STOPPED);
		}
	};

	private AppObserver appObserver = new AppObserver() {
		@Override
		public void IAppObserver_PrepareExitApp() {
			release();
		}
	};
	
	private ILyricsObserver mLyricsObserver = new ILyricsObserver(){

		@Override
		public void ILyricObserver_Lyrics(DownloadStatus status, ILyrics lyrics, ILyrics extLyrics, boolean isManually) {
			
		}

		@Override
		public void ILyricObserver_SearchList(DownloadStatus status, List&amp;lt;LyricsListItem&amp;gt; lyricsList) {
			
		}

		@Override
		public void ILyricObserver_HeadPic(DownloadStatus status, Bitmap bitmap) {
			if (!DownloadStatus.BEGIN.equals(status)) {
				setMusicData();
			}
			
		}

		@Override
		public void ILyricObserver_BackgroundPic(DownloadStatus status, Bitmap bitmap, boolean isManually) {
			
		}

		@Override
		public void ILyricObserver_AutoDownloadFinished(Music m) {
			
		}

		@Override
		public void ILyricObserver_AutoDownloadNotify(int alreadyDownloadCout, int sumDownloadCount) {
			
		}
		
	};
};
&lt;/code&gt;&lt;/pre&gt;
"> android系统标准音乐接口</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-xi-tong-zhong-parcelable-he-serializable-de-qu-bie/"" data-c="
          &lt;p&gt;进行Android开发的时候，我们都知道不能将对象的引用传给Activities或者Fragments，我们需要将这些对象放到一个Intent或者Bundle里面，然后再传递。&lt;/p&gt;
&lt;p&gt;通过Android的API，我们知道有两种选择，即在传递对象时，需要对我们的对象进行 Parcelable 或者Serializable化。作为Java开发者，相信大家对Serializable 机制有一定了解，那为什么还需要 Parcelable呢？&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;为了回答这个问题，让我们分别来看看这两者的差异。&lt;/p&gt;
&lt;h3 id=&#34;serializable-简单易用&#34;&gt;Serializable, 简单易用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// access modifiers, accessors and constructors omitted for brevity
public class SerializableDeveloper implements Serializable
    String name;
    int yearsOfExperience;
    List&amp;lt;Skill&amp;gt; skillSet;
    float favoriteFloat;
 
    static class Skill implements Serializable {
        String name;
        boolean programmingRelated;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;serializable的迷人之处在于你只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。&lt;/p&gt;
&lt;p&gt;这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。&lt;/p&gt;
&lt;h3 id=&#34;parcelable-速度至上&#34;&gt;Parcelable, 速度至上&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// access modifiers, accessors and regular constructors ommited for brevity
class ParcelableDeveloper implements Parcelable {
    String name;
    int yearsOfExperience;
    List&amp;lt;Skill&amp;gt; skillSet;
    float favoriteFloat;
 
    ParcelableDeveloper(Parcel in) {
        this.name = in.readString();
        this.yearsOfExperience = in.readInt();
        this.skillSet = new ArrayList&amp;lt;Skill&amp;gt;();
        in.readTypedList(skillSet, Skill.CREATOR);
        this.favoriteFloat = in.readFloat();
    }
 
    void writeToParcel(Parcel dest, int flags) {
        dest.writeString(name);
        dest.writeInt(yearsOfExperience);
        dest.writeTypedList(skillSet);
        dest.writeFloat(favoriteFloat);
    }
 
    int describeContents() {
        return 0;
    }
 
 
    static final Parcelable.Creator&amp;lt;ParcelableDeveloper&amp;gt; CREATOR
            = new Parcelable.Creator&amp;lt;ParcelableDeveloper&amp;gt;() {
 
        ParcelableDeveloper createFromParcel(Parcel in) {
            return new ParcelableDeveloper(in);
        }
 
        ParcelableDeveloper[] newArray(int size) {
            return new ParcelableDeveloper[size];
        }
    };
 
    static class Skill implements Parcelable {
        String name;
        boolean programmingRelated;
 
        Skill(Parcel in) {
            this.name = in.readString();
            this.programmingRelated = (in.readInt() == 1);
        }
 
        @Override
        void writeToParcel(Parcel dest, int flags) {
            dest.writeString(name);
            dest.writeInt(programmingRelated ? 1 : 0);
        }
 
        static final Parcelable.Creator&amp;lt;Skill&amp;gt; CREATOR
            = new Parcelable.Creator&amp;lt;Skill&amp;gt;() {
 
            Skill createFromParcel(Parcel in) {
                return new Skill(in);
            }
 
            Skill[] newArray(int size) {
                return new Skill[size];
            }
        };
 
        @Override
        int describeContents() {
            return 0;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据 google 工程师的说法，这些代码将会运行地特别快。原因之一就是我们已经清楚地知道了序列化的过程，而不需要使用反射来推断。同时为了更快地进行序列化，对象的代码也需要高度优化。&lt;/p&gt;
&lt;p&gt;因此，很明显实现Parcelable并不容易。实现Parcelable接口需要写大量的模板代码，这使得对象代码变得难以阅读和维护。&lt;/p&gt;
&lt;h3 id=&#34;速度测试&#34;&gt;速度测试&lt;/h3&gt;
&lt;p&gt;当然，我们还是想知道到底Parcelable相对于Serializable要快多少。&lt;/p&gt;
&lt;h3 id=&#34;测试方法&#34;&gt;测试方法&lt;/h3&gt;
&lt;p&gt;通过将一个对象放到一个bundle里面然后调用Bundle#writeToParcel(Parcel, int)方法来模拟传递对象给一个activity的过程，然后再把这个对象取出来。&lt;br&gt;
在一个循环里面运行1000 次。&lt;br&gt;
两种方法分别运行10次来减少内存整理，cpu被其他应用占用等情况的干扰。&lt;br&gt;
参与测试的对象就是上面代码中的SerializableDeveloper 和 ParcelableDeveloper。&lt;br&gt;
在多种Android软硬件环境上进行测试&lt;br&gt;
LG Nexus 4 – Android 4.2.2&lt;br&gt;
Samsung Nexus 10 – Android 4.2.2&lt;br&gt;
HTC Desire Z – Android 2.3.3&lt;/p&gt;
&lt;h3 id=&#34;结果&#34;&gt;结果&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119192129.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;parcelable-vs-serializable&lt;br&gt;
Nexus 10&lt;br&gt;
Serializable: 1.0004ms,  Parcelable: 0.0850ms – 提升10.16倍。&lt;/p&gt;
&lt;p&gt;Nexus 4&lt;br&gt;
Serializable: 1.8539ms – Parcelable: 0.1824ms – 提升11.80倍。&lt;/p&gt;
&lt;p&gt;Desire Z&lt;br&gt;
Serializable: 5.1224ms – Parcelable: 0.2938ms – 提升17.36倍。&lt;/p&gt;
&lt;p&gt;由此可以得出: Parcelable 比 Serializable快了10多倍。有趣的是，即使在Nexus 10这样性能强悍的硬件上，一个相当简单的对象的序列化和反序列化的过程要花将近一毫秒。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;如果你想成为一个优秀的软件工程师，你需要多花点时间来实现 Parcelable ，因为这将会为你对象的序列化过程快10多倍，而且占用较少的资源。&lt;/p&gt;
&lt;p&gt;但是大多数情况下， Serializable 的龟速不会太引人注目。你想偷点懒就用它吧，不过要记得serialization是一个比较耗资源的操作，尽量少使用。&lt;/p&gt;
&lt;p&gt;如果你想要传递一个包含许多对象的列表，那么整个序列化的过程的时间开销可能会超过一秒，这会让屏幕转向的时候变得很卡顿。&lt;/p&gt;
">Android系统中Parcelable和Serializable的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-de-xing-neng-you-hua/"" data-c="
          &lt;p&gt;转自:&lt;a href=&#34;http://blog.csdn.net/MeloDev/article/details/51038694&#34;&gt;http://blog.csdn.net/MeloDev/article/details/51038694&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;零性能指标&#34;&gt;零：性能指标&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;布局复杂度：布局复杂会导致布局需要更长的时间，从而导致进入应用慢、页面切换慢；&lt;/li&gt;
&lt;li&gt;耗电量：耗电量大会导致机器发热、缩短机器的有效使用时长；&lt;/li&gt;
&lt;li&gt;内存：内存消耗大会导致频繁GC，GC时会暂停其它工作，导致页面卡顿；内存泄露会导致剩余可用内存越来越小；内存不足会导致应用异常；&lt;/li&gt;
&lt;li&gt;网络：频繁的网络访问会导致耗电和影响应用的性能；网络交互数据大小会影响网络传输的效率；&lt;/li&gt;
&lt;li&gt;程序执行效率：糟糕的代码会严重影响程序的运行效率，UI线程过多的任务会阻塞应用的正常运行，长时间持有某个对象会导致潜在的内存泄露，频繁的IO操作、网络操作而不用缓存会严重影响程序的运行效率。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;一布局复杂度的优化&#34;&gt;一：布局复杂度的优化&lt;/h3&gt;
&lt;p&gt;关于布局的优化，主要分两个大方向&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 实现相同界面效果并且层级结构相同时，选用何种Layout最好&lt;/strong&gt;&lt;br&gt;
在Android中单独的布局性能：FrameLayout&amp;gt;LinearLayout&amp;gt;RelativeLayout&lt;/p&gt;
&lt;p&gt;可供参考的网址：&lt;a href=&#34;http://www.jianshu.com/p/8a7d059da746&#34;&gt;LinearLayout与RelativeLayout的性能比较&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure;&lt;/li&gt;
&lt;li&gt;RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin;&lt;/li&gt;
&lt;li&gt;在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout;&lt;/li&gt;
&lt;li&gt;使用组合控件性能要好于两个独立控件，比如一个文本旁边有一个图片，这中情况最好要用DrawableLeft的这种属性设置图片;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;2. 减少布局的层级结构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HierarchyViewer—可查看布局层次结构，View绘制时耗时。&lt;br&gt;
&lt;a href=&#34;http://blog.csdn.net/xyz_lmn/article/details/14222975&#34;&gt;HierarchyViewer的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;无线UIViewer—强烈推荐App工具，可在手机端直接实现HierarchyViewer的功能，查看任意界面的UI布局。&lt;br&gt;
&lt;a href=&#34;http://download.csdn.net/detail/duantihi/9448886&#34;&gt;无线UIViewer下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些复用性很高的布局文件，比如一个App的标题栏，建议使用布局重用include标签，方便引入和共同管理。&lt;/li&gt;
&lt;li&gt;观察上图第三个层级和第四个层级，无论是Layout类型，还是所覆盖的坐标点，都是重合的，因为父FrameLayout作为一个Container，子FrameLayout作为一个子View的跟布局，这种情况，可使用merge标签进行布局层级的优化。&lt;/li&gt;
&lt;li&gt;有些在特定情况下才会出现的界面，比如联网之后，或者未必百分之百出现的界面，可用ViewStub标签进行懒加载，性能明显要优于加载出这个界面然后gone掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;布局优化相关网址：&lt;br&gt;
&lt;a href=&#34;http://blog.csdn.net/xyz_lmn/article/details/14524567&#34;&gt;三种优化标签的使用情景和优势—张业兴 &lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.it165.net/pro/html/201409/22192.html&#34;&gt;布局优化标签的源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有关布局优化的一些基础知识准备(郭霖老师的两篇博客)：&lt;br&gt;
&lt;a href=&#34;http://blog.csdn.net/guolin_blog/article/details/12921889&#34;&gt;Android LayoutInflater原理分析，带你一步步深入了解View(一)&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://blog.csdn.net/guolin_blog/article/details/16330267&#34;&gt;Android视图绘制流程完全解析，带你一步步深入了解View(二)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;二android开发者模式gpu过渡绘制&#34;&gt;二：Android开发者模式—GPU过渡绘制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GPU过度绘制定义：&lt;/strong&gt;&lt;br&gt;
如果你粉刷过一个房间或一所房子，就会知道给墙壁涂上颜色需要做大量的工作。假如你还要重新粉刷一次的话，第二次粉刷的颜色会覆盖住第一次的颜色，第一次的颜色就永远不可见了，等于你第一次粉刷做的大量工作就完全被浪费掉。这太可怕了。&lt;/p&gt;
&lt;p&gt;同样的道理，如果在你的应用程序中浪费精力去绘制一些东西同样会产生性能问题。过度绘制这个名词就是用来描述屏幕上一个像素在单个帧中被重绘了多少次。&lt;/p&gt;
&lt;p&gt;GPU过度绘制就指的是在屏幕一个像素上绘制多次(超过一次)，GPU过度绘制或多或少对性能有些影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPU过度绘制分析：&lt;/strong&gt;&lt;br&gt;
过度绘制其实是一个性能和设计的交叉点。我们在设计上追求很华丽的视觉效果，但一般来说这种视觉效果会采用非常多的层叠组件来实现，这时候就会带来过度绘制的问题。我们再来看看具体显示在Android界面层级关系：&lt;/p&gt;
&lt;p&gt;当我们来绘制一个界面时，会有一个windows，然后是建立Activity，在Activity里可以建立多个view，或view group，view也可以嵌套view。这些组件从上到下分布，上面的组件是可以被用户看见的，而在下面的组件是不可见的，但是我们依然要花很多时间去绘制那些不可见的组件，因为在某些时候，它也可能会显示出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测过度绘制：&lt;/strong&gt;&lt;br&gt;
设置-开发者选项-调试GPU过度绘制-显示过度绘制区域(过度渲染等，不同机器可能不同)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;测试的颜色标识含义：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;项目测试截图：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119192004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到项目中并不存在太大问题，有关减少过度绘制的一些建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;太多重叠的背景&lt;br&gt;
这个问题其实最容易解决，建议前期在设计时尽量保持整体背景统一，另外开发可以检查你在布局和代码中设置的背景，有些背景是被隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;太多重叠的view&lt;br&gt;
第一个建议是：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认不可见的视图，可以动态的加载一个布局，只有你用到这个重叠着的view的时候才加载，推迟加载的时间。第二个建议是：如果使用了类似viewpager+Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态地Inflation view，它的性能要比SetVisiblity好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复杂的Layout层级&lt;br&gt;
这里的建议比较多一些，首先推荐用Android提供的布局工具Hierarchy&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三android中耗电量的测试&#34;&gt;三：Android中耗电量的测试&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/hyddd/p/4402621.html&#34;&gt;深入浅出Android App耗电量统计&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;四内存-cpu-gpu&#34;&gt;四：内存、CPU、GPU&lt;/h3&gt;
&lt;p&gt;应用运行时内存使用情况查看：Android Studio—Memory/CPU/GPU&lt;br&gt;
通常这种测试应该使用一个自动化工具（monkey）去不停的点击App，或者切换界面，来观察内存、cpu的情况。&lt;br&gt;
&lt;strong&gt;内存&lt;/strong&gt;&lt;br&gt;
测试截图：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119192015.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在地图界面不断地刷新，正常的内存成锯齿状分布。&lt;br&gt;
需要注意的情况：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119192025.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
出现了针状分布，说明内存发生了突变，如果内存峰值不能降下来，就说明出现了内存溢出，就值得引起我们的关注了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;GPU&lt;/strong&gt;&lt;br&gt;
Android Studio 1.4增加一项新功能：分析GPU渲染功能。作者详细讲解这一新功能的分析方法。&lt;br&gt;
在GPU选项卡下，可以在屏幕上看到图形化显示的渲染每帧所花费的时间。图形中每条都表示被渲染的一帧。颜色表示进程的不同周期：&lt;/p&gt;
&lt;p&gt;绘画（蓝色）&lt;br&gt;
表示View#onDraw()方法。那部分建立/更改DisplayList对象，然后转换成GPU能够理解的OpenGL命令。高的条形可能是视图复杂，而要求更多的时间绘制它们的显示列表，而许多视图在短时间内就失效了。&lt;/p&gt;
&lt;p&gt;准备（紫色）&lt;br&gt;
在Lollipop中，加入另一个线程，以帮助UI线程渲染更快。这个线程叫：RenderThread。它的责任是转换显示列表为OpenGL命令，再发送给GPU。这样在渲染过程中，UI线程可以开始处理下一个帧。这时UI线程将所有资源传送给RenderThread。如果有许多资源要传递（如许多/繁重显示列表），这一步可能需要较长时间。&lt;/p&gt;
&lt;p&gt;处理（红色）&lt;br&gt;
执行显示列表产生OpenGL命令。由于需要视图重绘，如果有许多/复杂显示列表要执行转换，这一步可能需要较长时间。当视图无效或是移动时，都要要重绘视图。&lt;/p&gt;
&lt;p&gt;执行（黄色）&lt;br&gt;
发送OpenGL命令到GPU。由于CPU发送这些缓存的命令到GPU，并期待收回干净缓存，这就阻塞调用了。缓存数量有限，并且GPU也很忙&lt;br&gt;
——&lt;br&gt;
CPU会发现自己必须先等待缓存释放。因此，如果在这一步我们见高的条形，就可能意味着GPU在绘制UI时非常忙，这个绘制在短时间内太复杂了。&lt;/p&gt;
&lt;p&gt;测试截图：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119192037.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;可以通过切换界面，看图形的峰值和颜色去判断绘制View每个阶段所花费的时间，然后根据你的需求进行优化。&lt;/p&gt;
&lt;h3 id=&#34;五程序的执行效率&#34;&gt;五：程序的执行效率&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;静态代码检查工具：Android studio—Analyze—Inspect Code…/Code cleanup… ，用于检测代码中潜在的问题、存在效率问题的代码段并提供改善方案；&lt;/li&gt;
&lt;li&gt;DDMS—TraceView，用于查找程序运行时具体耗时在哪；&lt;/li&gt;
&lt;li&gt;StrictMode：用于查找程序运行时具体耗时在哪，需要集成到代码中；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;六知名的三方性能优化工具&#34;&gt;六：知名的三方性能优化工具&lt;/h3&gt;
&lt;p&gt;eakCanary&lt;br&gt;
LeakCanary是一个检测内存泄露的开源类库。你可以在 debug&lt;br&gt;
包种轻松检测内存泄露。强烈推荐LeakCanary，大多数公司都在使用它进行内存泄漏的测试。&lt;/p&gt;
&lt;p&gt;以下是我找到的学习资料，写的非常棒：&lt;br&gt;
&lt;a href=&#34;http://www.liaohuqiu.net/cn/posts/leak-canary/&#34;&gt;LeakCanary:让内存泄露无所遁形&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/&#34;&gt;LeakCanary中文使用说明&lt;/a&gt;&lt;/p&gt;
">Android的性能优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-huan-fu-gong-neng-zhong-ru-he-dong-tai-huo-qu-kong-jian-zhong-bei-jing-tu-pian-de-zi-yuan-id/"" data-c="
          &lt;p&gt;这个是在在做一个换肤功能时遇到的问题。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;对于换肤，网上都有示例，可以从别的皮肤安装包中读取所要的资源，前提是你必须先持有这个资源的引用名称，像R.drawable.background（喂，这不是废话嘛）。这个换肤的方案原理就是，自身应用的资源名称是R.drawable.background，那皮肤包中应该也是这个名称，然后通过这个名称获取该资源在皮肤包中的具体id，代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//先获取本地资源引用名称，type name是R.drawable.background中的&amp;quot;drawable&amp;quot;，entry name是&amp;quot;background&amp;quot;  
String resTypeName = getContext().getResources().getResourceTypeName(id);  
String resEntryName = getContext().getResources().getResourceEntryName(id);  
//然后创建皮肤包所在应用的Context  
Context apk = getContext().createPackageContext(packageName,  
        Context.CONTEXT_IGNORE_SECURITY)  
//然后就是获取皮肤包中的资源id了  
int drawavleId = apk.getResources().getIdentifier(resEntryName, resTypeName,  
        apk.getPackageName());  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个换肤方案中，每个Activity在切换皮肤时，需要遍历整个layout，判断控件如果id中包含“skin”的字符，意味这个控件是需要换肤的控件，这个控件的id可以先保存下来。遍历视图的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void scanViewGroup(ViewGroup group, List&amp;lt;Integer&amp;gt; skinViewList, Resources res) {  
    //first we need check if this ViewGroup have a background  
    if(group.getId() != View.NO_ID  
            &amp;amp;&amp;amp; res.getResourceEntryName(group.getId()).contains(SKIN_PATTERN)  
            &amp;amp;&amp;amp; !skinViewList.contains(group)) {  
        skinViewList.add(group.getId());  
    }  
  
    //second check its child view  
    View child;  
  
    for(int i = 0; i &amp;lt; group.getChildCount(); i++) {  
        child = group.getChildAt(i);  
  
        if(child instanceof ViewGroup) {  
            scanViewGroup((ViewGroup)child, skinViewList, res);  
        } else if(child.getId() == View.NO_ID) {  
            return;  
        } else {  
            int viewId = child.getId();  
            String entryName = res.getResourceEntryName(viewId);  
  
            Log(&amp;quot;scanViewGroup(), entryName of this childView : &amp;quot; + entryName);  
  
            if(entryName.contains(SKIN_PATTERN) &amp;amp;&amp;amp; !skinViewList.contains(child))  
                skinViewList.add(child.getId());  
        }  
    }  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题来了，本地应用中，你持有一个控件，比如Button，它的id可以直接调用button.getId()方法获取，但是它的背景图片background呢，我们可以调用button.getBackground()方法获取其对象，但是却没有方法可以获取这个资源图片的引用名称，也就无法得到它的具体id了。后面想到的方案就是，在每次Activity初始化的时候，我们事先遍历每一个控件的属性集AttributeSet，有需要换肤的控件，将其android:background这个属性的值保存下来，为此，需要重载Activity的onCreateView(String name, Context context, AttributeSet attrs)方法，这个方法我的理解是在Activity中每个控件（包括LinearLayout、TextView、Button等等）初始化前会调用，我也打了log，进行了验证，其中attrs参数就是该控件的属性集，这就是我们需要的，代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//先判断前面扫描的skinViewList是否为空，不为空意味着有控件需要换肤  
if(skinViewList != null &amp;amp;&amp;amp; skinViewList.size() &amp;gt; 0) {  
    int viewId = -1, backgroundId = -1;  
    for(int i = 0; i &amp;lt; attrs.getAttributeCount(); i++) {  
        if(attrs.getAttributeName(i).equals(&amp;quot;id&amp;quot;)) {  
            viewId = attrs.getAttributeResourceValue(i, -1);  
        }  
  
        if(attrs.getAttributeName(i).equals(&amp;quot;background&amp;quot;)) {  
            backgroundId = attrs.getAttributeResourceValue(i, -1);  
        }  
    }  
  
    //check if background drawable need save  
    if(viewId != -1 &amp;amp;&amp;amp; backgroundId != -1 &amp;amp;&amp;amp;  
            drawableIdList != null &amp;amp;&amp;amp; !drawableIdList.containsKey(viewId)) {  
        drawableIdList.put(viewId, backgroundId);  
  
        Log(&amp;quot;add to drawableIdList, viewId = &amp;quot; + viewId  
                + &amp;quot;, backgroundId = &amp;quot; + backgroundId);  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这个backgroundId，就能获取该资源的引用名称R.drawable.background，然后我们就能通过名称从其他包获取对应的资源文件了，从而可以执行换肤操作。而且，通过这个方法，不只可以获取图片资源的id，也能获取字符串如R.string.title，字体颜色如R.color.red，字体大小如R.dimens.text_size_small等等属性，从而扩大换肤的范围。&lt;/p&gt;
">android换肤功能中，如何动态获取控件中背景图片的资源id？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-sao-miao-duo-mei-ti-wen-jian-pou-xi/"" data-c="
          &lt;p&gt;这篇文章从系统源代码分析，讲述如何将程序创建的多媒体文件加入系统的媒体库，如何从媒体库删除，以及大多数程序开发者经常遇到的无法添加到媒体库的问题等。本人将通过对源代码的分析，一一解释这些问题。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;android中的多媒体文件扫描机制&#34;&gt;Android中的多媒体文件扫描机制&lt;/h3&gt;
&lt;p&gt;Android提供了一个很棒的程序来处理将多媒体文件加入的媒体库中。这个程序就是MediaProvider，现在我们简单看以下这个程序。首先看一下它的Receiver&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;receiver android:name=&amp;quot;MediaScannerReceiver&amp;quot;&amp;gt;
        &amp;lt;intent-filter&amp;gt;
            &amp;lt;action android:name=&amp;quot;android.intent.action.BOOT_COMPLETED&amp;quot; /&amp;gt;
        &amp;lt;/intent-filter&amp;gt;
        &amp;lt;intent-filter&amp;gt;
            &amp;lt;action android:name=&amp;quot;android.intent.action.MEDIA_MOUNTED&amp;quot; /&amp;gt;
            &amp;lt;data android:scheme=&amp;quot;file&amp;quot; /&amp;gt;
        &amp;lt;/intent-filter&amp;gt;
        &amp;lt;intent-filter&amp;gt;
            &amp;lt;action android:name=&amp;quot;android.intent.action.MEDIA_UNMOUNTED&amp;quot; /&amp;gt;
            &amp;lt;data android:scheme=&amp;quot;file&amp;quot; /&amp;gt;
        &amp;lt;/intent-filter&amp;gt;
        &amp;lt;intent-filter&amp;gt;
            &amp;lt;action android:name=&amp;quot;android.intent.action.MEDIA_SCANNER_SCAN_FILE&amp;quot; /&amp;gt;
            &amp;lt;data android:scheme=&amp;quot;file&amp;quot; /&amp;gt;
        &amp;lt;/intent-filter&amp;gt;
    &amp;lt;/receiver&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MediaScannerReceiver只接收符合action和数据规则正确的intent。&lt;/p&gt;
&lt;h3 id=&#34;mediascannerreciever如何处理intent&#34;&gt;MediaScannerReciever如何处理Intent&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当且仅当接收到action android.intent.action.BOOT_COMPLETED才扫描内部存储（非内置和外置sdcard）&lt;/li&gt;
&lt;li&gt;除了action为android.intent.action.BOOT_COMPLETED 的以外的intent都必须要有数据传递。&lt;/li&gt;
&lt;li&gt;当收到 Intent.ACTION_MEDIA_MOUNTED intent，扫描Sdcard&lt;/li&gt;
&lt;li&gt;当收到 Intent.ACTION_MEDIA_SCANNER_SCAN_FILE intent，检测没有问题，将扫描单个文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mediascannerservice如何工作&#34;&gt;MediaScannerService如何工作&lt;/h3&gt;
&lt;p&gt;实际上MediaScannerReceiver并不是真正处理扫描工作，它会启动一个叫做MediaScannerService的服务。我们继续看MediaProvider的manifest中关于service的部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;service android:name=&amp;quot;MediaScannerService&amp;quot; android:exported=&amp;quot;true&amp;quot;&amp;gt;
        &amp;lt;intent-filter&amp;gt;
            &amp;lt;action android:name=&amp;quot;android.media.IMediaScannerService&amp;quot; /&amp;gt;
        &amp;lt;/intent-filter&amp;gt;
    &amp;lt;/service&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MediaScannerService中的scanFile方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Uri scanFile(String path, String mimeType) {
    String volumeName = MediaProvider.EXTERNAL_VOLUME;
    openDatabase(volumeName);
    MediaScanner scanner = createMediaScanner();
    return scanner.scanSingleFile(path, volumeName, mimeType);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MediaScannerService中的scan方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void scan(String[] directories, String volumeName) {
    // don&#39;t sleep while scanning
    mWakeLock.acquire();

    ContentValues values = new ContentValues();
    values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
    Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

    Uri uri = Uri.parse(&amp;quot;file://&amp;quot; + directories[0]);
    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

    try {
        if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
            openDatabase(volumeName);
        }

        MediaScanner scanner = createMediaScanner();
        scanner.scanDirectories(directories, volumeName);
    } catch (Exception e) {
        Log.e(TAG, &amp;quot;exception in MediaScanner.scan()&amp;quot;, e);
    }

    getContentResolver().delete(scanUri, null, null);

    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
    mWakeLock.release();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MediaScannerService中的createMediaScanner方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private MediaScanner createMediaScanner() {
        MediaScanner scanner = new MediaScanner(this);
        Locale locale = getResources().getConfiguration().locale;
        if (locale != null) {
            String language = locale.getLanguage();
            String country = locale.getCountry();
            String localeString = null;
            if (language != null) {
                if (country != null) {
                    scanner.setLocale(language + &amp;quot;_&amp;quot; + country);
                } else {
                    scanner.setLocale(language);
                }
            }
        }

        return scanner;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面可以发现，真正工作的其实是android.media.MediaScanner.java 具体扫描过程就请点击链接查看。&lt;a href=&#34;https://android.googlesource.com/platform/frameworks/base/+/cd92588/media/java/android/media/MediaScanner.java&#34;&gt;https://android.googlesource.com/platform/frameworks/base/+/cd92588/media/java/android/media/MediaScanner.java&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何扫描一个刚创建的文件&#34;&gt;如何扫描一个刚创建的文件&lt;/h3&gt;
&lt;p&gt;这里介绍两种方式来实现将新创建的文件加入媒体库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最简单的方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要发送一个正确的intent广播到MediaScannerReceiver即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String saveAs = &amp;quot;Your_Created_File_Path&amp;quot;
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的极简方法大多数情况下正常工作，但是有些情况下是不会工作的，稍后的部分会介绍。即使你使用上述方法成功了，还是建议你继续阅读稍后的为什么发广播不成功的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用MediaScannerConnection&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void mediaScan(File file) {
    MediaScannerConnection.scanFile(getActivity(),
            new String[] { file.getAbsolutePath() }, null,
            new OnScanCompletedListener() {
                @Override
                public void onScanCompleted(String path, Uri uri) {
                    Log.v(&amp;quot;MediaScanWork&amp;quot;, &amp;quot;file &amp;quot; + path
                            + &amp;quot; was scanned seccessfully: &amp;quot; + uri);
                }
            });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MediaScannerConnection的scanFile方法从2.2（API 8）开始引入。&lt;/p&gt;
&lt;p&gt;创建一个MediaScannerConnection对象然后调用scanFile方法&lt;/p&gt;
&lt;p&gt;很简单，参考&lt;a href=&#34;http://developer.android.com/reference/android/media/MediaScannerConnection.html&#34;&gt;http://developer.android.com/reference/android/media/MediaScannerConnection.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何扫描多个文件&#34;&gt;如何扫描多个文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;发送多个Intent.ACTION_MEDIA_SCANNER_SCAN_FILE广播&lt;/li&gt;
&lt;li&gt;使用MediaScannerConnection，传入要加入的路径的数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么发送media_scanner_scan_file广播不生效&#34;&gt;为什么发送MEDIA_SCANNER_SCAN_FILE广播不生效&lt;/h3&gt;
&lt;p&gt;关于为什么有些设备上不生效，很多人认为是API原因，其实不是的，这其实和你传入的文件路径有关系。看一下接收者Receiver的onReceive代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    Uri uri = intent.getData();
    if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        // scan internal storage
        scan(context, MediaProvider.INTERNAL_VOLUME);
    } else {
        if (uri.getScheme().equals(&amp;quot;file&amp;quot;)) {
            // handle intents related to external storage
            String path = uri.getPath();
            String externalStoragePath = Environment.getExternalStorageDirectory().getPath();

            Log.d(TAG, &amp;quot;action: &amp;quot; + action + &amp;quot; path: &amp;quot; + path);
            if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                // scan whenever any volume is mounted
                scan(context, MediaProvider.EXTERNAL_VOLUME);
            } else if (action.equals(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) &amp;amp;&amp;amp;
                    path != null &amp;amp;&amp;amp; path.startsWith(externalStoragePath + &amp;quot;/&amp;quot;)) {
                scanFile(context, path);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的部分都正确除了传入的路径。因为你可能硬编码了文件路径。因为有一个这样的判断path.startsWith(externalStoragePath + &amp;quot;/&amp;quot;),这里我举一个简单的小例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final String saveAs = &amp;quot;/sdcard/&amp;quot; + System.currentTimeMillis() + &amp;quot;_add.png&amp;quot;;
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);
Uri uri = mediaScanIntent.getData();
String path = uri.getPath();
String externalStoragePath = Environment.getExternalStorageDirectory().getPath();
Log.i(&amp;quot;LOGTAG&amp;quot;, &amp;quot;Androidyue onReceive intent= &amp;quot; + mediaScanIntent
                        + &amp;quot;;path=&amp;quot; + path + &amp;quot;;externalStoragePath=&amp;quot; +
                        externalStoragePath);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看一下输出日志，分析原因。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;LOGTAG Androidyue onReceive intent= Intent { act=android.intent.action.MEDIA_SCANNER_SCAN_FILE dat=file:///sdcard/1390136305831_add.png };path=/sdcard/1390136305831_add.png;externalStoragePath=/mnt/sdcard
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述输出分析，你发送的广播，action是正确的，数据规则也是正确的，而且你的文件路径也是存在的，但是，文件的路径/sdcard/1390136305831_add.png并不是以外部存储根路径/mnt/sdcard/开头。所以扫描操作没有开始，导致文件没有加入到媒体库。所以，请检查文件的路径。&lt;/p&gt;
&lt;h3 id=&#34;如何从多媒体库中移除&#34;&gt;如何从多媒体库中移除&lt;/h3&gt;
&lt;p&gt;如果我们删除一个多媒体文件的话，也就意味我们还需要将这个文件从媒体库中删除掉。&lt;/p&gt;
&lt;p&gt;能不能简简单单发广播？&lt;/p&gt;
&lt;p&gt;仅仅发一个广播能解决问题么？我倒是希望可以，但是实际上是不工作的，查看如下代码即可明白。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// this function is used to scan a single file
public Uri scanSingleFile(String path, String volumeName, String mimeType) {
    try {
        initialize(volumeName);
        prescan(path, true);

        File file = new File(path);
        if (!file.exists()) {
            return null;
        }

        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;

        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(),
                false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, &amp;quot;RemoteException in MediaScanner.scanFile()&amp;quot;, e);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如上述代码，会对文件是否存在进行检查，如果文件不存在，直接停止向下执行。所以这样是不行的。那怎么办呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void testDeleteFile() {
    String existingFilePath = &amp;quot;/mnt/sdcard/1390116362913_add.png&amp;quot;;
    File  existingFile = new File(existingFilePath);
    existingFile.delete();
    ContentResolver resolver = getActivity().getContentResolver();
    resolver.delete(Images.Media.EXTERNAL_CONTENT_URI, Images.Media.DATA + &amp;quot;=?&amp;quot;, new String[]{existingFilePath});

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码是可以工作的，直接从MediaProvider删除即可。 具体的删除代码请参考&lt;a href=&#34;http://droidyue.com/blog/2014/02/09/code-snippet-for-media-on-android/&#34; title=&#34;Code Snippet for Media on Android&#34;&gt;http://droidyue.com/blog/2014/02/09/code-snippet-for-media-on-android/&lt;/a&gt;&lt;/p&gt;
">Android扫描多媒体文件剖析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-kai-fa-chang-jian-de-activity-zhong-nei-cun-xie-lou-ji-jie-jue-ban-fa/"" data-c="
          &lt;p&gt;在这一篇文章里，我们来谈谈Android开发中常见的Activity内存泄漏及解决办法。本文将会以“为什么”“怎么解决”的方式来介绍这几种内存泄漏。&lt;br&gt;
在开篇之前，先来了解一下什么是内存泄漏。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;什么是内存泄漏？&lt;/p&gt;
&lt;p&gt;内存泄漏是当程序不再使用到的内存时，释放内存失败而产生了无用的内存消耗。内存泄漏并不是指物理上的内存消失，这里的内存泄漏是值由程序分配的内存但是由于程序逻辑错误而导致程序失去了对该内存的控制，使得内存浪费。&lt;br&gt;
怎样会导致内存泄漏？&lt;/p&gt;
&lt;p&gt;资源对象没关闭造成的内存泄漏，如查询数据库后没有关闭游标cursor&lt;br&gt;
构造Adapter时，没有使用 convertView 重用&lt;br&gt;
Bitmap对象不在使用时调用recycle()释放内存&lt;br&gt;
对象被生命周期长的对象引用，如activity被静态集合引用导致activity不能释放&lt;br&gt;
在接下来的篇幅里，我们重点讲有关Activity常见的内存泄漏。&lt;/p&gt;
&lt;p&gt;内存泄漏1：静态Activities（static Activities）&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;
MainActivity.Java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MainActivity extends AppCompatActivity {private static MainActivity activity;
    TextView saButton;
    @Overrideprotected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        saButton = (TextView) findViewById(R.id.text);
        saButton.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                setStaticActivity();
                nextActivity();
            }
        });
    }
    void setStaticActivity() {
        activity = this;
    }

    void nextActivity(){
        startActivity(new Intent(this,RegisterActivity.class));
        SystemClock.sleep(1000);
        finish();
    }

    @Overrideprotected void onDestroy() {
        super.onDestroy();
        //使用LeakCanary观察是否有内存泄漏
        MyApplication.getRefWatcher().watch(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LeakCanary检测出的内存泄漏：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为什么？&lt;br&gt;
在上面代码中，我们声明了一个静态的Activity变量并且在TextView的OnClick事件里引用了当前正在运行的Activity实例，所以如果在activity的生命周期结束之前没有清除这个引用，则会引起内存泄漏。因为声明的activity是静态的，会常驻内存，如果该对象不清除，则垃圾回收器无法回收变量。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
最简单的方法是在onDestory方法中将静态变量activity置空，这样垃圾回收器就可以将静态变量回收。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onDestroy() {
        super.onDestroy();
        activity = null;
        //使用LeakCanary观察是否有内存泄漏
        MyApplication.getRefWatcher().watch(this);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内存泄漏2：静态View&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;
MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    ...
    private static View view;
    TextView saButton;
    @Overrideprotected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        saButton = (TextView) findViewById(R.id.text);
        saButton.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                setStaticView();
                nextActivity();
            }
        });
    }
    void setStaticView() {
        view = findViewById(R.id.sv_view);
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LeakCanary检测到的内存泄漏&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191721.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为什么？&lt;br&gt;
上面代码看似没有问题，在Activity里声明一个静态变量view，然后初始化，当Activity生命周期结束了内存也释放了，但是LeakCanary却显示出现了内存泄漏，为什么？问题出在这里，View一旦被加载到界面中将会持有一个Context对象的引用，在这个例子中，这个context对象是我们的Activity，声明一个静态变量引用这个View，也就引用了activity，所以当activity生命周期结束了，静态View没有清除掉，还持有activity的引用，因此内存泄漏了。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
在onDestroy方法里将静态变量置空。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Overrideprotected void onDestroy() {
    super.onDestroy();
    view = null;
    MyApplication.getRefWatcher().watch(this);
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内存泄漏3：内部类&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;
MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static Object inner;
void createInnerClass() {
    class InnerClass {
    }
    inner = new InnerClass();
}

View icButton = findViewById(R.id.ic_button);
icButton.setOnClickListener(new View.OnClickListener() {
    @Override public void onClick(View v) {
        createInnerClass();
        nextActivity();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用LeakCanary检测到的内存泄漏：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为什么？&lt;br&gt;
非静态内部类会持有外部类的引用，在上面代码中内部类持有Activity的引用，因此inner会一直持有Activity，如果Activity生命周期结束没有清除这个引用，这样就发生了内存泄漏。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
因为非静态内部类隐式持有外部类的强引用，所以我们将内部类声明成静态的就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void createInnerClass() {
    static class InnerClass {
    }
    inner = new InnerClass();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内存泄漏4：匿名类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void startAsyncTask() {
    new AsyncTask&amp;lt;Void, Void, Void&amp;gt;() {
        @Override protected Void doInBackground(Void... params) {
            while(true);
        }
    }.execute();
}

super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
View aicButton = findViewById(R.id.at_button);
aicButton.setOnClickListener(new View.OnClickListener() {
    @Override public void onClick(View v) {
        startAsyncTask();
        nextActivity();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用LeakCanary检测到的内存泄漏：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191751.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为什么？&lt;br&gt;
上面代码在activity中创建了一个匿名类AsyncTask，匿名类和非静态内部类相同，会持有外部类对象，这里也就是activity，因此如果你在Activity里声明且实例化一个匿名的AsyncTask对象，则可能会发生内存泄漏，如果这个线程在Activity销毁后还一直在后台执行，那这个线程会继续持有这个Activity的引用从而不会被GC回收，直到线程执行完成。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
自定义静态AsyncTask类，并且让AsyncTask的周期和Activity周期保持一致，也就是在Activity生命周期结束时要将AsyncTask cancel掉。&lt;/p&gt;
&lt;p&gt;内存泄漏5：Handler&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;
MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
void createHandler() {
    new Handler() {
        @Override public void handleMessage(Message message) {
            super.handleMessage(message);
        }
    }.postDelayed(new Runnable() {
        @Override public void run() {
            while(true);
        }
    }, 1000);
}

...
View hButton = findViewById(R.id.h_button);
hButton.setOnClickListener(new View.OnClickListener() {
    @Override public void onClick(View v) {
        createHandler();
        nextActivity();
    }
});
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么？&lt;br&gt;
当Android Application启动以后，framework会首先帮助我们完成UI线程的消息循环，也就是在UI线程中，Loop、MessageQueue、Message等等这些实例已经由framework帮我们实现了。所有的Application主要事件，比如Activity的生命周期方法、Button的点击事件都包含在这个Message里面，这些Message都会加入到MessageQueue中去，所以，UI线程的消息循环贯穿于整个Application生命周期，所以当你在UI线程中生成Handler的实例，就会持有Loop以及MessageQueue的引用。并且在Java中非静态内部类和匿名内持有外部类的引用，而静态内部类则不会持有外部类的引用。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
可以由上面的结论看出，产生泄漏的根源在于匿名类持有Activity的引用，因此可以自定义Handler和Runnable类并声明成静态的内部类，来解除和Activity的引用。&lt;/p&gt;
&lt;p&gt;内存泄漏6：Thread&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;
MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void spawnThread() {
    new Thread() {
        @Override public void run() {
            while(true);
        }
    }.start();
}

View tButton = findViewById(R.id.t_button);
tButton.setOnClickListener(new View.OnClickListener() {
  @Override public void onClick(View v) {
      spawnThread();
      nextActivity();
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么？&lt;br&gt;
同AsyncTask一样，这里就不过多赘述。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
那我们自定义Thread并声明成static这样可以吗？其实这样的做法并不推荐，因为Thread位于GC根部，DVM会和所有的活动线程保持hard references关系，所以运行中的Thread绝不会被GC无端回收了，所以正确的解决办法是在自定义静态内部类的基础上给线程加上取消机制，因此我们可以在Activity的onDestroy方法中将thread关闭掉。&lt;/p&gt;
&lt;p&gt;内存泄漏7：Timer Tasks&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;
MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void scheduleTimer() {
    new Timer().schedule(new TimerTask() {
        @Overridepublic void run() {
            while(true);
        }
    },1000);
}

View ttButton = findViewById(R.id.tt_button);
ttButton.setOnClickListener(new View.OnClickListener() {
    @Override public void onClick(View v) {
        scheduleTimer();
        nextActivity();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么？&lt;br&gt;
这里内存泄漏在于Timer和TimerTask没有进行Cancel，从而导致Timer和TimerTask一直引用外部类Activity。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
在适当的时机进行Cancel。&lt;/p&gt;
&lt;p&gt;内存泄漏8：Sensor Manager&lt;/p&gt;
&lt;p&gt;代码如下：&lt;br&gt;
MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void registerListener() {
       SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
       Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);
       sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_FASTEST);
}

View smButton = findViewById(R.id.sm_button);
smButton.setOnClickListener(new View.OnClickListener() {
    @Override public void onClick(View v) {
        registerListener();
        nextActivity();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么？&lt;br&gt;
通过Context调用getSystemService获取系统服务，这些服务运行在他们自己的进程执行一系列后台工作或者提供和硬件交互的接口，如果Context对象需要在一个Service内部事件发生时随时收到通知，则需要把自己作为一个监听器注册进去，这样服务就会持有一个Activity，如果开发者忘记了在Activity被销毁前注销这个监听器，这样就导致内存泄漏。&lt;/p&gt;
&lt;p&gt;怎么解决？&lt;br&gt;
在onDestroy方法里注销监听器。&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;在开发中，内存泄漏最坏的情况是app耗尽内存导致崩溃，但是往往真实情况不是这样的，相反它只会耗尽大量内存但不至于闪退，可分配的内存少了，GC便会更多的工作释放内存，GC是非常耗时的操作，因此会使得页面卡顿.&lt;/p&gt;
">Android开发常见的Activity中内存泄漏及解决办法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-kai-fa-zhi-mediaplayer-zhuang-tai-zhuan-huan-tu-ji-yin-pin-jiao-dian/"" data-c="
          &lt;p&gt;本篇博客主要内容如下：&lt;/p&gt;
&lt;p&gt;MediaPlayer的状态变换&lt;br&gt;
MediaPlayer的唤醒锁&lt;br&gt;
MediaPlayer的音频焦点&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;mediaplayer的状态变换&#34;&gt;MediaPlayer的状态变换&lt;/h3&gt;
&lt;p&gt;之前讲到，使用MediaPlayer播放音频，主要使用的是start()、pause()、stop()等方法操作MediaPlayer。但是除了开始、暂停、停止等，MediaPlayer还涉及到一些其他的状态切换，有些状态是可以双向转换的，有些只能单向环形转换。如果在某状态下，强行转换状态，会应发程序错误，例如在Preparing状态下切换到Started状态，是准备中强行开始播放，会出错。下图是官方文档上的图例，可以很清晰的表名MediaPlayer各个状态的转换情况。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图已经对MediaPlayer的各种状态转换有的清晰的介绍，这里不再详细讲解了，只是提一下需要注意的地方：&lt;/p&gt;
&lt;p&gt;Started（开始）/Paused（暂停）到Stopped（停止）是单向转换，无法再从Stopped直接转换到Started，需要经历Prepared重新装载才可以重新播放。&lt;br&gt;
Initialized（初始化）状态需要装载数据才可以进行start()播放，但是如果使用prepareAsync()方法异步准备，需要等待准备完成再开始播放，这里需要使用一个回调方法：setOnPreparedListener()，它会在异步装载完成后调用。&lt;br&gt;
End（结束）状态是游离在其他状态之外的，在任何状态皆可切换，一般在不需要继续使用MediaPlayer的时候，才会使用release()回收资源。&lt;br&gt;
Error（错误）状态是游离在其他状态之外的，只有在MediaPlayer发生错误的时候才会转换。为了保持应用的用户体验，一般我们回监听setOnErrorListener()回调方法，它会在MediaPlayer发生错误的时候被回调。&lt;/p&gt;
&lt;h3 id=&#34;mediaplayer的唤醒锁&#34;&gt;MediaPlayer的唤醒锁&lt;/h3&gt;
&lt;p&gt;一般使用MediaPlayer播放音频流，推荐使用一个Service来承载MediaPlayer，而不是直接在Activity里使用。但是Android系统的功耗设计里，为了节约电池消耗，如果设备处于睡眠状态，系统将试图降低或者关闭一些没设备必须的特性，包括CUP和Wifi硬件，然后，如果是一个后台播放音乐的应用，降低CUP可能导致在后台运行的时候干扰音频的正常播放，关闭Wifi将可能导致网络音频流的获取出现错误。&lt;/p&gt;
&lt;p&gt;为了确保MediaPlayer的承载的服务在系统睡眠的时候继续正常运行下去，Android为我们提供了一种唤醒锁(wake locks)的机制。它可以在系统睡眠的，依然保持锁定硬件的正常工作。&lt;/p&gt;
&lt;p&gt;确保在MediaPlayer运行的时候，哪怕系统睡眠了CUP也能正常运行，需要使用MediaPlayer.setWakeMode()为MediaPlayer设定唤醒锁。下面是setWakMode()的签名：&lt;/p&gt;
&lt;p&gt;setWakeMode(Context context, int mode)&lt;/p&gt;
&lt;p&gt;第一个参数是当前上下文，第二个参数为需要加锁的状态，被设定为int类型的常量，定义在PowerManager这个final类中。PowerManager是专门用来管理Android功率消耗的锁定状态，与锁定CUP相关的，有四种，分别设定CUP、屏幕、键盘等的各种保持唤醒的状态，在这里只需要设定为PARTIAL_WAKE_LOCK即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mediaPlayer = new MediaPlayer();
// 设定CUP锁定
mediaPlayer.setWakeMode(getApplicationContext(), PowerManager.PARTIAL_WAKE_LOCK);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般对于锁而言，锁定了通常需要解锁，但是这里的唤醒说与MediaPlayer关联，所以只需要在使用完之后release()释放MediaPlayer即可，无需显式的为其解锁。在使用setWakeMode设定唤醒锁的时候，还必须为应用赋予相应的权限：&lt;/p&gt;
&lt;p&gt;再来说说如何锁定wifi硬件在系统睡眠的时候保持正常运行。wifi锁通过WifiLock进行操作，而WifiLock通过WifiManager进行管理，通过WifiManager.createWifiLock()进行Wifi锁定。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WifiManager.WifiLock createWifiLock(int lockType, String tag)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法有多个重载，这里介绍的这个，第一个参数设定锁的状态，为一个int类型的常量，定义在Context类中，这里的应用场景一般设定为WIFI_MODE_FULL即可。第二个参数为WifiLock的标志，用于确定wifiLock的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wifiLock= ((WifiManager) getSystemService(this.WIFI_SERVICE)).createWifiLock(WifiManager.WIFI_MODE_FULL, &amp;quot;mylock&amp;quot;);
 wifiLock.acquire();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，在应用中把Wifi锁定之后，还需要在MediaPlayer.release()的时候为wifi硬件解锁，为避免意外关闭的情况，最好在Android组件的onDestory()里对其进行释放，释放Wifi锁使用WifiLock.release()。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//停止播放
protected void stop() {
	if (mediaPlayer != null &amp;amp;&amp;amp; mediaPlayer.isPlaying()) {
		mediaPlayer.stop();
		mediaPlayer.release();
		mediaPlayer = null;
		// 释放wifi锁
		wifiLock.acquire();
		btn_play.setEnabled(true);
		Toast.makeText(this, &amp;quot;停止播放&amp;quot;, 0).show();
	}
}

@Override
protected void onDestroy() {
	// 在activity结束的时候回收资源
	if (mediaPlayer != null &amp;amp;&amp;amp; mediaPlayer.isPlaying()) {
		mediaPlayer.stop();
		mediaPlayer.release();
		mediaPlayer = null;
		// 释放wifi锁
		wifiLock.acquire();
	}
	super.onDestroy();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mediaplayer的音频焦点&#34;&gt;MediaPlayer的音频焦点&lt;/h3&gt;
&lt;p&gt;众所周知，Android是一个多任务的操作系统，所以对于音频的播放，也许有几个不同的媒体服务会同时播放，这样可能导致一个比较杂乱的声音环境，而错过一些重要的声音提醒。在Android2.2之后，Android提供了一种应用协商使用设备音频输出的机制，这种机制称为音频焦点。&lt;/p&gt;
&lt;p&gt;当应用程序需要输出音频或通知的时候，需要请求音频焦点，当请求得到音频焦点之后，监听音频焦点的变换，当音频焦点变换了，根据返回回来的音频焦点码进行相应的处理。音频焦点的注册使用音频管理器的AudioManager.requestAudioFocus()方法设定。它的签名如下：&lt;/p&gt;
&lt;p&gt;int requestAudioFocus(AudioManager.OnAudioFocusChangeListener l, int streamType, int durationHint)&lt;/p&gt;
&lt;p&gt;这个方法的返回值是int类型，其含义被定义在AudioManager中以常量表示AUDIOFOCUS_REQUEST_FAILED（获取音频焦点成功）、AUDIOFOCUS_REQUEST_GRANTED（获取音频焦点失败）。其中重要的是第一个参数，为音频焦点变化的回调函数，在其中可以设定如果音频焦点变换了，当前应用如何管理MediaPlayer，第二个参数为媒体流的类型，第三个参数为持续的状态。&lt;/p&gt;
&lt;p&gt;AudioManager.OnAudioFocusChangeListener为音频焦点变换的监听器，其中需要实现一个方法：onAudioFocusChange(int focusChange)在音频焦点变换的时候回调。它有一个参数，为当前表示音频焦点对于当前应用的状态码，通过这个状态码指定对应的操作，有些时候音频状态改变了，并不一定需要停止音频的播放。&lt;/p&gt;
&lt;p&gt;focusChange有一下几种状态码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AUDIOFOCUS_GAIN：获得音频焦点。&lt;/li&gt;
&lt;li&gt;AUDIOFOCUS_LOSS：失去音频焦点，并且会持续很长时间。这是我们需要停止MediaPlayer的播放。&lt;/li&gt;
&lt;li&gt;AUDIOFOCUS_LOSS_TRANSIENT：失去音频焦点，但并不会持续很长时间，需要暂停MediaPlayer的播放，等待重新获得音频焦点。&lt;/li&gt;
&lt;li&gt;AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK：暂时失去音频焦点，但是无需停止播放，只需降低声音方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	audioManager =(AudioManager)getSystemService(this.AUDIO_SERVICE);

	int result = audioManager.requestAudioFocus(
			new OnAudioFocusChangeListener() {

				@Override
				public void onAudioFocusChange(int focusChange) {
					switch (focusChange) {
						case AudioManager.AUDIOFOCUS_GAIN:
							// 获得音频焦点
							if (!mediaPlayer.isPlaying()) {
								mediaPlayer.start();
							}
							// 还原音量
							mediaPlayer.setVolume(1.0f, 1.0f);
							break;

						case AudioManager.AUDIOFOCUS_LOSS:
							// 长久的失去音频焦点，释放MediaPlayer
							if (mediaPlayer.isPlaying())
								mediaPlayer.stop();
							mediaPlayer.release();
							mediaPlayer = null;
							break;

						case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
							// 展示失去音频焦点，暂停播放等待重新获得音频焦点
							if (mediaPlayer.isPlaying())
								mediaPlayer.pause();
							break;
						case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
							// 失去音频焦点，无需停止播放，降低声音即可
							if (mediaPlayer.isPlaying()) {
								mediaPlayer.setVolume(0.1f, 0.1f);
							}
							break;
					}
				}
			}, AudioManager.STREAM_MUSIC,
			AudioManager.AUDIOFOCUS_GAIN);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;以上就讲解了MediaPlayer的一些高级的内容，在掌握了MediaPlayer的使用之后，开发有关音乐播放类的应用的时候就可以得心应手了。从用户体验的方面出发，如果真实开发一款播放器类的软件，需要监听AUDIO_BECOMING_NOISY的广播，它会在音频输出源从其他输出源变换到设备扬声器的时候发出此广播，监听广播在音频输出源改变到设备扬声器的时候，停止播放，这样确保在耳机或额外的音频输出硬件与设备断开连接的时候，不至于重新从扬声器继续输出音频播放。&lt;/p&gt;
">Android开发之Mediaplayer状态转换图及音频焦点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-cun-chu-wa-keng-ji/"" data-c="
          &lt;p&gt;最近在搞Android存储相关的业务，什么Internal/External/Primary/Secondary搞得我都看懵了，国内也没什么好的文章系统的讲这个，我就挖挖各类资料，整理一下。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;1-internal-vs-external&#34;&gt;1. Internal vs External&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;对于Internal Storage 与 External Storage，官方文档上有这么一段话，描述得很详细了，我翻译了一段下来：&lt;/p&gt;
&lt;p&gt;所有的Android设备都有两块存储区域：Internal Storage和External Storage。它们的名称来源于早期的Android系统，那时候大家的手机都内置(Permanent)一块较小存储板（即Internal Storage），并配上一个的外置的(Removable)储存卡（即External Storage）。后来部分手机开始将最初定义的“Internal Storage”，即内置存储，分成Internal和External两部分。这样一来就算没有外置储存，手机也有Internal和External两块存储区域。这两块存储区域的区别是：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; &lt;/th&gt;
&lt;th&gt;Internal Storage&lt;/th&gt;
&lt;th&gt;External Storage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;可信度&lt;/td&gt;
&lt;td&gt;永远可用(Permanent)&lt;/td&gt;
&lt;td&gt;可能不可用，最典型的当设备作为USB存储被mount时不可用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问权限&lt;/td&gt;
&lt;td&gt;App存储内容仅App本身（或共享uid的App）可访问（Root除外）&lt;/td&gt;
&lt;td&gt;App存储内容全局可读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容持久&lt;/td&gt;
&lt;td&gt;App存储内容随App卸载而消失&lt;/td&gt;
&lt;td&gt;当App卸载时，只有存在getExternalFilesDir()路径下的文件会消失&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适应情况&lt;/td&gt;
&lt;td&gt;存储内容仅App自己访问时的最佳选择&lt;/td&gt;
&lt;td&gt;存储内容希望与其他App共享或传到电脑上，但是不想申请任何权限时的最佳选择&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：此处讨论的访问权限是应用路径下的权限。&lt;/p&gt;
&lt;p&gt;总结下来，External存储区域有几个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以传到电脑上；&lt;/li&gt;
&lt;li&gt;可以与其他app共享；&lt;/li&gt;
&lt;li&gt;在4.4之后的App路径(Android/data/包名)下读写不需任何权限；&lt;/li&gt;
&lt;li&gt;存在App路径之外的文件不会随App卸载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相应的，也有几个缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可能不可用；&lt;/li&gt;
&lt;li&gt;会被其他应用读到;&lt;/li&gt;
&lt;li&gt;在非App路径下写、修改文件需要权限。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;11-external-storage的权限&#34;&gt;1.1 External Storage的权限&lt;/h3&gt;
&lt;p&gt;在Internal Storage的App路径下（/data/data/包名下)，App的读写操作无需任何权限，我们只需要总结一下External Storage的情况：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Android版本&lt;/th&gt;
&lt;th&gt;读&lt;/th&gt;
&lt;th&gt;写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4.4以下&lt;/td&gt;
&lt;td&gt;无需权限&lt;/td&gt;
&lt;td&gt;需要申请WRITE_EXTERNAL_STORAGE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.4及以上&lt;/td&gt;
&lt;td&gt;无需权限&lt;/td&gt;
&lt;td&gt;在App目录之外写，需要申请WRITE_EXTERNAL_STORAGE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于读External的权限，在Android Developer上有这样一段话:&lt;/p&gt;
&lt;p&gt;目前，所有App都可以读External存储而不需要任何权限，这一点可能会在未来做出改变。如果你希望读External存储，那最好申请一下READ_EXTERNAL_STORAGE权限。另外，写权限已经默认包含了读权限了。&lt;/p&gt;
&lt;p&gt;正常情况下，你用任何文件管理器，点开的根目录就是你的External存储。你可以到它下面的应用目录，你会发现，就算是各个包名下的文件，你也是看得到的。&lt;/p&gt;
&lt;h3 id=&#34;12-多用户&#34;&gt;1.2 多用户&lt;/h3&gt;
&lt;p&gt;在4.2及以上的Android系统中引入了多用户机制。你可能会发现在存储路径后面有’0’/‘1’的字样（如/storage/emulated/0/），这后面的数字表示用户。主用户后面为0。&lt;/p&gt;
&lt;h3 id=&#34;2-primary-vs-secondary&#34;&gt;2. Primary vs Secondary&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;这个Primary和Secondary是怎么来的呢？实际上最开始Android也没有考虑这个区分，但是后来有一个情况发生了，就是上面所说到的：&lt;/p&gt;
&lt;p&gt;后来部分手机开始将最初定义的“Internal Storage”，即内置存储，分成Internal和External两部分。&lt;/p&gt;
&lt;p&gt;那么如果这个时候手机再插入sd卡，那不是有多个External Storage了吗？&lt;/p&gt;
&lt;p&gt;这个时候，从Internal Storage里面分出来的那块“External Storage”我们称之为主存储(Primary Storage)，插入的外置储存称之为副存储(Secondary Storage)。&lt;/p&gt;
&lt;p&gt;主存储路径的获取方式非常简单，可以通过Environment.getExternalStorageDirectory()或者Context.getExternalFilesDir(null)来获取。&lt;/p&gt;
&lt;p&gt;副存储路径在4.4及以上的Android系统中，可以使用Context.getExternalFilesDirs(null)(注意最后多了一个’s’)，它返回的是一个字符串数组。第0个就是主存储路径，第1个是副存储路径（如果有的话）。&lt;/p&gt;
&lt;p&gt;在4.4及以下系统中，的副存储的获取方式就是一个大坑了，一个一个介绍一下笔者看到过的方法。&lt;/p&gt;
&lt;h3 id=&#34;21-副储存路径-storagemanager&#34;&gt;2.1 副储存路径-StorageManager&lt;/h3&gt;
&lt;p&gt;在Android中可以通过context.getSystemService(STORAGE_SERVICE)来获取到StorageManager，但是很可惜的是，它里面有价值的方法都是hide的。&lt;/p&gt;
&lt;p&gt;庆幸的是还有反射。我们可以调用getVolumeList()函数，这个返回的List里面，主存储是第0个，副存储（如果有的话）是第1个。&lt;/p&gt;
&lt;p&gt;你可以看到Environment.getExternalStorageDirectory()里面就是用它实现的，可以说这个方法是目前最稳妥的。它通过系统的MountService来获取已mount上来的设备，并且能够通过StorageVolume知道该存储是否removable、是否是emulated、mount状态等等。&lt;/p&gt;
&lt;p&gt;涉及到存储，由于Android rom千奇百怪，不可能是万全的。如果反射出来的方法缺少变量、方法，或者有别的什么坑，那只能试一下其他方法来保底。&lt;/p&gt;
&lt;p&gt;靠谱程度：99%&lt;/p&gt;
&lt;h3 id=&#34;22-副存储路径-读配置xml&#34;&gt;2.2 副存储路径-读配置xml&lt;/h3&gt;
&lt;p&gt;读com.android.internal.R.xml.storage_list.xml可以获取到系统的VolumeList，但是这种方法是行不通的，我们可以从源码中看看。&lt;/p&gt;
&lt;p&gt;在6.0以前的MountService上面看到readStorageList()这个函数，它在构造函数里面就会被调用，就是在读取这个xml文件。但是我们可以看到它并没有在Volume改变的时候被动态写入。&lt;/p&gt;
&lt;p&gt;并且参考AOSP Document,这个xml文件里面存储的就是厂商配置的分区，它根本无法更新removable存储的热插拔信息。&lt;/p&gt;
&lt;p&gt;注意：这个xml在6.0被移除了(参考AOSP Document)&lt;/p&gt;
&lt;p&gt;靠谱程度：0%&lt;/p&gt;
&lt;h3 id=&#34;23-副存储路径-mount命令&#34;&gt;2.3 副存储路径-mount命令&lt;/h3&gt;
&lt;p&gt;执行Linux shell下的mount命令，遍历每个mount点，从中找到副存储。&lt;/p&gt;
&lt;p&gt;目前，它确实能够列出副存储。但是同时会列出很多很多mount点，包括系统mount点，目前好像没有已知的靠谱方法能够从中准确找出副存储。副存储的命名是没有规律的，枚举排除系统mount点的方法不能够100%确保准确性。&lt;/p&gt;
&lt;p&gt;靠谱程度：10%&lt;/p&gt;
&lt;h3 id=&#34;24-副存储路径-读voldfstab文件&#34;&gt;2.4 副存储路径-读vold.fstab文件&lt;/h3&gt;
&lt;p&gt;解析/etc/void.fstab，从中找到副存储位置。&lt;/p&gt;
&lt;p&gt;Vold(Volume Daemon)是ServiceManager与kernel层之间的桥梁，它对于Volume的信息维护在/etc/vold.fstab中。&lt;/p&gt;
&lt;p&gt;一听就是一个奇怪的方法，文件位置、信息也可能被各类厂商篡改，还可能存在瞬时不一致的情况，不要考虑它。有兴趣的同学可以研究一下android-storage-vold。&lt;/p&gt;
&lt;p&gt;靠谱程度：0%&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;总结出Android手机目前的几种存储方式：&lt;/p&gt;
&lt;h3 id=&#34;在60之前&#34;&gt;在6.0之前&lt;/h3&gt;
&lt;p&gt;6.0之前，所有的存储类型都是Traditional Storage。它支持多用户、模拟External存储。由于是MBR分区，存储上线为2TB。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Physical Primary 最原始的样子是只有机身自带的Internal存储和以External存在的外置存储，这时候只有一个主存储，并且它是Physical的。&lt;/li&gt;
&lt;li&gt;Emulated Primary (Optional Physical Secondary) 之前所说，从Internal Storage分出一块来给External Storage。这块存储空间就是在Permanent存储版中”模拟“上去的。所以你可以看到主存储经常有emulated字样。 如果这时候还能再插SD卡，则会多一个Physical的Secondary存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;在60之后&#34;&gt;在6.0之后&lt;/h3&gt;
&lt;p&gt;正常情况下，它的存储方式与之前的两种相同，不过多了一种新的存储方式：Adoptable Storage&lt;/p&gt;
&lt;h3 id=&#34;adoptable-storage&#34;&gt;Adoptable Storage&lt;/h3&gt;
&lt;p&gt;由于External Storage的缺点（有时不可用，存储内容没有被保护），在6.0之后多出了Adoptable存储方式。&lt;/p&gt;
&lt;p&gt;当Android系统Adopt了一块External存储区域的时候，它会被视为Internal Storage，同时会被格式化与加密。格式化之后是GPT分区，存储上线为9ZB。&lt;/p&gt;
&lt;p&gt;当你在一个支持Adoptable Storage的手机上插入一个sd卡，它会提示你是否将这个sd卡格式化并用作Internal Storage，或者正常作为External Storage使用。&lt;/p&gt;
&lt;p&gt;推荐一篇文章：&lt;br&gt;
CommonsWare’s post，从不同角度诠释了Internal&amp;amp;External Storage， 非常不错！&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://commonsware.com/blog/2014/04/07/storage-situation-internal-storage.html&#34;&gt;https://commonsware.com/blog/2014/04/07/storage-situation-internal-storage.html&lt;/a&gt;&lt;/p&gt;
">Android存储挖坑记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/androidstudio-guan-lian-zi-ji-xia-zai-de-android-source-fang-fa/"" data-c="
          &lt;p&gt;最近一直在使用AndroidStudio进行程序开发，从0.5一直使用到现在的0.8.2，突然今天想关联一下自己下载的CM11的androidsource，突然发现我们基于Gradle的工程怎么也无法关联自己下载的androidsource，只能关联SDK中下载的source，翻遍了AndroidStudio的设置也没有找到设置soucepath的地方，问了同事也没有解决，上网搜索结果人家的截图是这样的：&lt;/p&gt;
&lt;!--more--&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191457.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是我的截图是这样的：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;你妹的，根本就找不到SDKs这个选项啊。&lt;/p&gt;
&lt;p&gt;有人建议我把下载的源代码放到sdk中对应的source目录下，这我也想到了，但是这个太不方便了，也太low了，我们是程序猿啊。&lt;/p&gt;
&lt;p&gt;于是各种stackoverflow和google，终于皇天不负我啊。&lt;/p&gt;
&lt;p&gt;有下面两个方法：&lt;/p&gt;
&lt;p&gt;1、关掉你所有的工程，进入AndroidStudio的欢迎界面，依次进入Configure&amp;gt;Project Defaults&amp;gt;Project Structure&amp;gt;SDKs，如果你能看到SDKs选项，基本上选中你想修改的SDK API，找到对应的sourcepath面板就能修改或者增加你的source目录了。&lt;/p&gt;
&lt;p&gt;2、如果你和我一样悲剧，在1方法中的Project Structure中看不到SDKs这个选项，那我们就自己动手进入androidstudio的配置目录&lt;/p&gt;
&lt;p&gt;windows下：系统盘:\Users\username.AndroidStudioBeta&lt;/p&gt;
&lt;p&gt;Mac下：~/Library/Preferences/AndroidStudioBeta&lt;/p&gt;
&lt;p&gt;在这个目录下搜索jdk.table.xml，用记事本打开，修改了里面对应的SDK API的sourcePath就行了，点击保存，完事！&lt;/p&gt;
">AndroidStudio关联自己下载的android source方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/androidm-yi-shang-huo-qu-mac-di-zhi-bu-zhun-que-de-jie-jue-fang-an/"" data-c="
          &lt;p&gt;在android5.0上使用以前通用的获取mac地址的方法,会固定返回02:00:00:00:00:00,谷歌为了保护用户隐私,也是煞费苦心.但是怎能防得住我国众开发者.嘿嘿嘿&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;50以下手机获取方案&#34;&gt;5.0以下手机获取方案&lt;/h2&gt;
&lt;p&gt;5.0以下手机获取MAC地址使用如下方案:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		MAC_ADDR = &amp;quot;&amp;quot;;
		try {
			WifiManager mgr = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
			MAC_ADDR = mgr.getConnectionInfo().getMacAddress();
		} catch (Exception e) {
			e.printStackTrace();
			MAC_ADDR = &amp;quot;&amp;quot;;
		}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在5.0以上此方法固定返回02:00:00:00:00:00.&lt;/p&gt;
&lt;h2 id=&#34;50以上手机获取方案&#34;&gt;5.0以上手机获取方案&lt;/h2&gt;
&lt;p&gt;5.0以上手机获取MAC地址使用如下方案:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//修复在6.0以上获取虚假mac的问题.固定返回02:00:00:00:00:00
public static String getMacAdressOverAndroidM() {
	String address = &amp;quot;&amp;quot;;
	Enumeration&amp;lt;NetworkInterface&amp;gt; interfaces;
	try {
		interfaces = NetworkInterface.getNetworkInterfaces();
		while (interfaces.hasMoreElements()) {
			NetworkInterface netWork = interfaces.nextElement();
			byte[] by = netWork.getHardwareAddress();
			if (by == null || by.length == 0) {
				continue;
			}
			StringBuilder builder = new StringBuilder();
			for (byte b : by) {
				builder.append(String.format(&amp;quot;%02X:&amp;quot;, b));
			}
			if (builder.length() &amp;gt; 0) {
				builder.deleteCharAt(builder.length() - 1);
			}
			String mac = builder.toString();
			LogMgr.d(&amp;quot;mac&amp;quot;, &amp;quot;interfaceName=&amp;quot; + netWork.getName() + &amp;quot;, mac=&amp;quot; + mac);
			if (netWork.getName().equals(&amp;quot;wlan0&amp;quot;)) {
				address = mac;
			}
		}
	} catch (SocketException e) {
		e.printStackTrace();
	}
	return address;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原理:读取网络信息,匹配出wlan0字段的硬件信息.&lt;/p&gt;
&lt;p&gt;恩,完事儿.&lt;/p&gt;
">androidM以上获取MAC地址不准确的解决方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android60-xi-tong-gua-pei-zhuo-mian-ge-ci-xiao-guo/"" data-c="
          &lt;p&gt;在360手机助手及各家的音乐播放器软件上，都使用了桌面浮动窗功能，桌面歌词都是在音乐客户端显示在前台时隐藏，在用户把软件切换到后台后显示出来，此效果在Android 6.0以前，大部分都是使用系统的ActivityManager系统类的getRunningAppProcesses或getRunningTasks（Android5.0需要多判断一步）来进行软件前后台状态的判断，然后使用WindowManager进行浮动窗控件的增加和删除实现桌面歌词的显示与隐藏。但在Android6.0后，如果是使用SDK中6.0的编译工具编译的App，ActivityManager的方法和WindowManager的方法都有权限问题，不能简单直接的使用了。下面通过一个模仿桌面歌词效果的例子，来说明6.0上的实现。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;首先讲一下6.0以前版本判断前后台状态方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void UpdateForgroundState() {
        boolean isForground = IS_FORGROUND;
        Context ctx = App.getInstance().getApplicationContext();
        ActivityManager activityManager = (ActivityManager)ctx.getSystemService(Context.ACTIVITY_SERVICE);
        String packageName = ctx.getPackageName();
        List&amp;lt;RunningAppProcessInfo&amp;gt; appProcesses = activityManager.getRunningAppProcesses();
        if (appProcesses == null) {         
            return;
        }
        for (RunningAppProcessInfo appProcess : appProcesses) {
            if (!appProcess.processName.equals(packageName)) {
                continue; //不是本程序的包名，跳过
            }
            isForground = CompatibleCheckAppState(ctx,activityManager,appProcess);
            break;
        }       
        if (IS_FORGROUND == isForground) {
            return;
        }
        IS_FORGROUND = isForground;
        if (isForground) {
            //通知程序桌面歌词类，当前是前台状态，你要隐藏起来
        } else {
            //通知桌面歌词类，当前是后台运行中，你要出来显示了
        }
    }

    private static boolean CompatibleCheckAppState(Context ctx,ActivityManager am,RunningAppProcessInfo pInfo){
        if (android.os.Build.VERSION.SDK_INT &amp;gt; android.os.Build.VERSION_CODES.KITKAT){  //Android5.0的判断前后台和以前版本不一样。要通过topActivity找包名判断，
            if(am==null){
                return false;
            }
            List&amp;lt;RunningTaskInfo&amp;gt; tasks = am.getRunningTasks(1);
            if (!tasks.isEmpty()) {
                ComponentName topActivity = tasks.get(0).topActivity;
                if (topActivity!=null&amp;amp;&amp;amp;ctx!=null&amp;amp;&amp;amp;topActivity.getPackageName().equals(ctx.getPackageName())) {
                    return true;
                }
            }
            return false;
        }else{
            //5.0以前的系统，可以直接通过RunningAppProcessInfo类的importance属性判断前后台状态
            return pInfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Android4.0–Android6.0可通用的判断前台后的方法&lt;/p&gt;
&lt;p&gt;首先要自定义Application类，在类中进行ActivityLifecycleCallbacks的接口实现类进行注册与反注册&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
    public void onCreate() {
        super.onCreate();
        this.registerActivityLifecycleCallbacks(callbacks);
    }

    @Override
    public void onTerminate() {
        this.unregisterActivityLifecycleCallbacks(callbacks);
        super.onTerminate();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在接口实现类中，实现如下代码，在全局进行状态标识更新&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Application.ActivityLifecycleCallbacks callbacks = new ActivityLifecycleCallbacks() {
        @Override
        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
        }

        @Override
        public void onActivityStarted(Activity activity) {
            activityShowingCount++;
            changeActivityFlag(activity,activityShowingCount&amp;gt;0);
        }

        @Override
        public void onActivityResumed(Activity activity) {         
        }

        @Override
        public void onActivityPaused(Activity activity) {
        }

        @Override
        public void onActivityStopped(Activity activity) {
            activityShowingCount--;
            changeActivityFlag(activity,activityShowingCount&amp;gt;0);            
        }

        @Override
        public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
        }

        @Override
        public void onActivityDestroyed(Activity activity) {
        }
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面需要注意的是，一定要把判断逻辑放到started和stopped回调事件中，而不能放到Resumed和paused事件中，因为这二个事件在应用有多个Activity进行交替打开时，桌面歌词会显一下。&lt;br&gt;
上面这种方法不需要申请权限，简单安全。&lt;/p&gt;
">Android6.0系统适配桌面歌词效果</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-suo-ping-yan-jiu/"" data-c="
          &lt;h2 id=&#34;一-为什么需要自定义锁屏页&#34;&gt;一、为什么需要自定义锁屏页&lt;/h2&gt;
&lt;p&gt;锁屏作为一种黑白屏时代就存在的手机功能，至今仍发挥着巨大作用，特别是触屏时代的到来，锁屏的功用被发挥到了极致。多少人曾经在无聊的时候每隔几分钟划开锁屏再关上，孜孜不倦，其酸爽程度不亚于捏气泡膜。确实，一款漂亮的锁屏能为手机增色不少，但锁屏存在的核心目的主要是三个：保护自己手机的隐私，防止误操作，在不关闭系统软件的情况下节省电量。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;当下，各个款式的手机自带的系统锁屏完全能够满足这些需求，而且美观程度非凡，那么开发者为什么仍然需要构建自定义锁屏呢？让我们试想一个场景，一位正在使用音乐播放器听歌的美女用户，在没有播放器自定义锁屏的情况下，切换一首歌需要几步（参考自同类文章）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点亮手机屏幕&lt;/li&gt;
&lt;li&gt;解开系统锁屏&lt;/li&gt;
&lt;li&gt;打开音乐播放器&lt;/li&gt;
&lt;li&gt;切歌再熄灭屏幕&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时的她估计已经被广场舞的歌曲骚扰了有10秒，续了10次命，这是我们程序员不愿意看到的，所以有必要依靠我们灵活的双手构建出自定义的音乐锁屏页，将切歌过程被压缩为两步：点亮屏幕和切歌，顺便可以看看歌词。如果再加个开启和关闭自定义锁屏的开关，就能完美解决用户的痛点。&lt;/p&gt;
&lt;h2 id=&#34;二-自定义锁屏页的基本原理&#34;&gt;二、自定义锁屏页的基本原理&lt;/h2&gt;
&lt;p&gt;然而，要实现一个自定义锁屏是一件繁琐的事情，因为系统有100种方法让这个非本地的锁屏待不下去。但是，人类的智慧是无限的，程序员需要逆流而上。&lt;/p&gt;
&lt;p&gt;Android系统实现自定义锁屏页的思路很简单，即在App启动时开启一个service，在Service中时刻监听系统SCREEN_OFF的广播，当屏幕熄灭时，Service监听到广播，开启一个锁屏页Activity在屏幕最上层显示，该Activity创建的同时会去掉系统锁屏（当然如果有密码是禁不掉的）。示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqywUVMx5v6v1alqHLmIkESxVaaX15RXjNj4sfpBVDicpLCjLExCPTVOIxQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
道理很简单，我们这里需要讨论的是细节。&lt;/p&gt;
&lt;h3 id=&#34;1-广播注册&#34;&gt;1. 广播注册&lt;/h3&gt;
&lt;p&gt;Service是普通的Service，在应用启动时直接startService，与应用同一个进程即可。此外，SCREEN_OFF广播监听必须是动态注册的，如果在AndroidManifest.xml中静态注册将无法接收到SCREEN_OFF广播，这点在Android官方文档中有明确说明，即需要通过如下代码注册：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IntentFilter mScreenOffFilter = new IntentFilter();
mScreenOffFilter.addAction(Intent.ACTION_SCREEN_OFF);
registerReceiver(mScreenOffReceiver, mScreenOffFilter);  
　　对应的BroadcastReceiver定义如下：private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver() {    @SuppressWarnings(&amp;quot;deprecation&amp;quot;)    @Override
    public void onReceive(Context context, Intent intent) {        if (intent.getAction().equals(NOTIFY_SCREEN_OFF)) {
            Intent mLockIntent = new Intent(context, LockScreenActivity.class);
            mLockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                    | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            startActivity(mLockIntent);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于启动Activity时Intent的Flag问题，如果不添加FLAG_ACTIVITY_NEW_TASK的标志位，会出现“Calling startActivity() from outside of an Activity”的运行时异常，毕竟我们是从Service启动的Activity。Activity要存在于activity的栈中，而Service在启动activity时必然不存在一个activity的栈，所以要新起一个栈，并装入启动的activity。使用该标志位时，也需要在AndroidManifest中声明taskAffinity，即新task的名称，否则锁屏Activity实质上还是在建立在原来App的task栈中。&lt;/p&gt;
&lt;p&gt;标志位FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，是为了避免在最近使用程序列表出现Service所启动的Activity,但这个标志位不是必须的，其使用依情况而定。&lt;/p&gt;
&lt;h3 id=&#34;2-activity设置&#34;&gt;2. Activity设置&lt;/h3&gt;
&lt;p&gt;锁屏的activity内部也要做相应的配置，让activity在锁屏时也能够显示，同时去掉系统锁屏。当然如果设置了系统锁屏密码，系统锁屏是没有办法去掉的，这里考虑没有设置密码的情况。&lt;/p&gt;
&lt;p&gt;典型的去掉系统锁屏页的方法是使用KeyguardManager，具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KeyguardManager mKeyguardManager = (KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE);
KeyguardManager.KeyguardLock mKeyguardLock = mKeyguardManager.newKeyguardLock(&amp;quot;CustomLockScreen&amp;quot;);
mKeyguardLock.disableKeyguard();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，KeyguardManager是锁屏管理类，我们通过getSystemService()的方式获取实例对象mKeyguardManager，调用该对象的newKeyguardLock()方法获取KeyguardManager的内部类KeyguardLock的实例mKeyguardLock，该方法传入的字符串参数用于标识是谁隐藏了系统锁屏，最后调用mKeyguardLock的disableKeyguard()方法可以取消系统锁屏。&lt;/p&gt;
&lt;p&gt;上述方法已经不推荐使用，可以使用更好的方法来替代。我们在自定义锁屏Activity的onCreate()方法里设定以下标志位就能完全实现相同的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FLAG_DISMISS_KEYGUARD用于去掉系统锁屏页，FLAG_SHOW_WHEN_LOCKED使Activity在锁屏时仍然能够显示。当然，不要忘记在Manifest中加入适当的权限：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.DISABLE_KEYGUARD&amp;quot;/&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-屏蔽按键&#34;&gt;3. 屏蔽按键&lt;/h3&gt;
&lt;p&gt;当自定义锁屏页最终出现在手机上时，我们总希望它像系统锁屏页那样屹立不倒，所有的按键都不能触动它，只有通过划瓶或者指纹才能解锁，因此有必要对按键进行一定程度上的屏蔽。针对只有虚拟按键的手机，我们可以通过隐藏虚拟按键的方式部分解决这个问题，具体方法在后文会介绍。但是当用户在锁屏页底部滑动，隐藏后的虚拟按键还是会滑出，而且如果用户是物理按键的话就必须进行屏蔽了。&lt;/p&gt;
&lt;p&gt;Back键和Menu键可以通过重写onKeyDown()方法进行屏蔽：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean onKeyDown(int keyCode, KeyEvent event) {    int key = event.getKeyCode();    switch (key) {        case KeyEvent.KEYCODE_BACK: {            return true;
        }        case KeyEvent.KEYCODE_MENU:{            return true;
        }
    }    return super.onKeyDown(keyCode, event);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Home键与Recent键（调出最近打开应用的按键）的点击事件是在framework层进行处理的，因此onKeyDown与dispatchKeyEvent都捕获不到点击事件。关于这两个按键的屏蔽方法，网上相关的资料有很多，有的用到了反射，有的通过改变Window的标志位和Type等，总的来说这些方法只对部分android版本有效，有的则完全无法编译通过。其实，这么做的目的无非是为了实现一个纯粹的锁屏页，但是这种做法有些画蛇添足，容易造成锁屏页的异常崩溃，我们要满足的是用户在锁屏页的快捷操作，Home键和Recent键无关痛痒，完全可以不管,少一些套路，多一点真诚嘛。&lt;/p&gt;
&lt;h3 id=&#34;4-划屏解锁&#34;&gt;4. 划屏解锁&lt;/h3&gt;
&lt;p&gt;做完以上几步，当屏幕熄灭后，再打开屏幕就能够看到我们的自定义锁屏页了，但是这时候，就算划破手指也无法解锁。所以，接下来要实现划屏解锁。&lt;/p&gt;
&lt;p&gt;划瓶解锁的基本思路很简单，当手指在屏幕上滑动时，拦截并处理滑动事件，使锁屏页面随着手指运动，当运动到达一定的阀值时，用户手指松开手指，锁屏页自动滑动到屏幕边界消失，如果没有达到运动阀值，就会自动滑动到起始位置，重新覆盖屏幕。&lt;/p&gt;
&lt;p&gt;为了将划屏逻辑与页面内容隔离开来，我们在锁屏页面布局中添加一个自定义的UnderView，这个UnderView填充整个屏幕，位于锁屏内容View（将其引用称之为mMoveView,并传入到UnderView中）的下方，所有划屏相关的事件都在这里拦截并处理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqywcbDrN8gmNLABwh3stOG4jQImxrMibVp9OVlPL1tMrVH8eITVibVpeQMg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;mMoveView是锁屏页的显示内容，除了处理一些简单的点击事件，其他非点击事件序列都由底层的UnderView进行处理。只需要重写UnderView的onTouchEvent方法就能够实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Overridepublic boolean onTouchEvent(MotionEvent event) {    final int action = event.getAction();    final float nx = event.getX();    switch (action) {    case MotionEvent.ACTION_DOWN:
        mStartX = nx;
        onAnimationEnd();    case MotionEvent.ACTION_MOVE:
        handleMoveView(nx);        break;    case MotionEvent.ACTION_UP:    case MotionEvent.ACTION_CANCEL:
        doTriggerEvent(nx);        break;
    }    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，mStartX记录滑动操作起始的x坐标，handleMoveView方法控制mMoveView随手指的移动，doTriggerEvent处理手指离开后mMoveView的移动动画。两个方法的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void handleMoveView(float x) {    float movex = x - mStartX;    if (movex &amp;lt; 0)
        movex = 0;
    mMoveView.setTranslationX(movex);    float mWidthFloat = (float) mWidth;//屏幕显示宽度
    if(getBackground()!=null){
        getBackground().setAlpha((int) ((mWidthFloat - mMoveView.getTranslationX()) / mWidthFloat * 200));//初始透明度的值为200
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在handleMoveView()中，首先计算当前触点x坐标与初始x坐标mStartX的差值movex，然后调用mMoveView的setTranslationX方法移动。值得注意的是，目前setTranslationX方法只能在Android 3.0以上版本使用，如果采用动画兼容库nineoldandroid中ViewHelper类提供的setTranslation方法，则没有这个问题。scrollTo与scrollBy也可以实现移动，但是只是移动View的内容，并不能移动View本身。另外就是通过修改布局参数LayoutParams实现移动，虽然没有版本的限制，用起来相对复杂。这里我们采用setTranslationX，为了简洁，也是为了能够与后续使用的属性动画相统一。&lt;/p&gt;
&lt;p&gt;此外，我们可以通过getBackground()获取UnderView的背景，并根据已划开屏幕占整个屏幕的百分比调用setAlpha方法改变背景的透明度，做出抽屉拉开时的光影变化效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void doTriggerEvent(float x) {    float movex = x - mStartX;    if (movex &amp;gt; (mWidth * 0.4)) {
        moveMoveView(mWidth-mMoveView.getLeft(),true);//自动移动到屏幕右边界之外，并finish掉

    } else {
        moveMoveView(-mMoveView.getLeft(),false);//自动移动回初始位置，重新覆盖
    }
}private void moveMoveView(float to,boolean exit){
    ObjectAnimator animator = ObjectAnimator.ofFloat(mMoveView, &amp;quot;translationX&amp;quot;, to);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {        @Override
        public void onAnimationUpdate(ValueAnimator animation) {            if(getBackground()!=null){
                getBackground().setAlpha((int) (((float) mWidth - mMoveView.getTranslationX()) / (float) mWidth * 200));
            }
        }
    });//随移动动画更新背景透明度
    animator.setDuration(250).start();    if(exit){
        animator.addListener(new AnimatorListenerAdapter() {            @Override
            public void onAnimationEnd(Animator animation) {
                mainHandler.obtainMessage(LockScreenActivity.MSG_LAUNCH_HOME).sendToTarget();                super.onAnimationEnd(animation);
            }
        });
    }//监听动画结束，利用Handler通知Activity退出}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当手指离开屏幕，doTraiggerEvent方法会对滑动的距离与阀值进行一个比较，此处的阀值为0.4*屏幕宽度，如果低于阀值，则通过ObjectAnimator在0.25s将mMoveView移动到初始位置，同时在ObjectAnimator的AnimatorUpdateListener的onAnimationUpdate方法中更新背景透明度；如果低于阀值，以同样的方式将mMoveView移出屏幕右边界，然后将Activity干掉，具体做法是为animator增加一个AnimatorListenerAdapter的监听器，在该监听器的onAnimationEnd方法中使用在Activity中定义的mHandler发送finish消息，完成解锁，效果如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqyw7haZqCLK8MrAYPNVfuBH6ff22xuRyBaIHrRxibZTTZn7fRuIjZQX3xA/0?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;三-透明栏与沉浸模式&#34;&gt;三、透明栏与沉浸模式&lt;/h2&gt;
&lt;p&gt;沉浸模式与透明栏是两个不同的概念，由于某些原因，国内一些开发或产品会把这两个概念混淆。不过没关系，在接下来的内容我们会对这两个概念进行详细的解释和区分，并应用这两种不同的模式进一步完善已经初具模样的锁屏页。&lt;/p&gt;
&lt;h3 id=&#34;1-沉浸模式&#34;&gt;1. 沉浸模式&lt;/h3&gt;
&lt;p&gt;什么是沉浸模式？从4.4开始，Android 为 “setSystemUiVisibility()”方法提供了新的标记 “SYSTEM_UI_FLAG_IMMERSIVE”以及”SYSTEM_UI_FLAG_IMMERSIVE_STIKY”，就是我们所谈的沉浸模式，全称为 “Immersive Full-Screen Mode”，它可以使你的app隐藏状态栏和导航栏，实现真正意义上的全屏体验。&lt;/p&gt;
&lt;p&gt;之前 Android 也是有全屏模式的，主要通过”setSystemUiVisibility()”添加两个Flag，即”SYSTEM_UI_FLAG_FULLSCREEN”，”SYSTEM_UI_FLAG_HIDE_NAVIGATION”（仅适用于使用导航栏的设备，即虚拟按键）。&lt;/p&gt;
&lt;p&gt;这两个标记都存在一些问题，例如使用第一个标记的时候，除非 App 提供暂时退出全屏模式的功能（例如部分电子书软件中点击一次屏幕中央位置），用户是一直都没法看见状态栏的。这样，如果用户想去看看通知中心有什么通知，那就必须点击一次屏幕，显示状态栏，然后才能调出通知中心。&lt;/p&gt;
&lt;p&gt;而第二个标记的问题在于，Google 认为导航栏对于用户来说是十分重要的，所以只会短暂隐藏导航栏。一旦用户做其他操作，例如点击一次屏幕，导航栏就会马上被重新调出。这样的设定对于看图软件，视频软件等等没什么大问题，但是对于游戏之类用户需要经常点击屏幕的 App，那就几乎是悲剧了——这也是为什么你在 Android 4.4 之前找不到什么全屏模式会自动隐藏导航栏的应用。&lt;/p&gt;
&lt;p&gt;Android 4.4 之后加入的Immersive Full-Screen Mode 允许用户在应用全屏的情况下，通过在原有的状态栏/导航栏区域内做向内滑动的手势来实现短暂调出状态栏和导航栏的操作，且不会影响应用的正常全屏，短暂调出的状态栏和导航栏会呈半透明状态，并且在一段时间内或者用户与应用内元素进行互动的情况下自动隐藏，沉浸模式的四种状态如下图。（参考&lt;a href=&#34;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0616/3047.html&#34;&gt;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0616/3047.html&lt;/a&gt;)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqywPibIIXicricrY7zfz3zXsGNgllzdtrmKmbM5ymXktqOWvH454RE3ibqjhw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;状态1代表没有进入沉浸模式时页面的状态，仍然可以看到Status Bar和Navigation Bar；状态2代表用户第一次进入沉浸模式时，系统的提示弹窗，告诉用户如何在沉浸模式下呼出Status Bar和Navigation Bar；状态3代表沉浸模式，可以看到Status Bar和Navigation Bar都被隐藏；状态4代表用户在Sticky沉浸模式下呼出Status Bar和Navigation Bar，可以看到两个Bar重新出现，但是过一段时间能够自动隐藏。&lt;/p&gt;
&lt;p&gt;一般来说，沉浸模式的标记与其他Full Screen相关的Flag搭配起来才能达到我们想要的效果，即通过沉浸模式标记规定状态栏status bar和导航栏navigation bar显示和隐藏的运转逻辑，通过其他标签设定状态栏和导航栏显示或隐藏，以及显示或隐藏的样子。这些常见的Flag及相应功能如下表：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqywBH765hxNl1fLw16iaIGLFQIftu48dUpzSUBmaq9HLb3epuZvVlYGyug/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如此多的标签，看起来非常乱，但用起来却非常简单和明确，感兴趣的开发者可以自由搭配来测试一下。下面，我们通过一个例子，将这些标签应用于锁屏页，实现对Navigation Bar的自动隐藏，同时保留Status Bar。代码非常简单，在Activity的onCreate()方法中使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getWindow().getDecorView().setSystemUiVisibility(
    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总共用到了5个Flag：SYSTEM_UI_FLAG_LAYOUT_STABLE保持整个View稳定，使View不会因为SystemUI的变化而做layout；SYSTEM_UI_FLAG_IMMERSIVE_STIKY，能够在隐藏的bar被呼出时（比如从屏幕下边缘开始向上做滑动手势），使bar在无相关操作的情况下自动再次隐藏；对于SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION，开发者容易被其中的HIDE_NAVIGATION所迷惑，其实这个Flag没有隐藏导航栏的功能，只是控制导航栏浮在屏幕上层，不占据屏幕布局空间；SYSTEM_UI_FLAG_HIDE_NAVIGATION，才是能够隐藏导航栏的Flag；SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，由上面可知，也不能隐藏状态栏，只是使状态栏浮在屏幕上层。&lt;/p&gt;
&lt;p&gt;需要注意的是，这段代码除了需要加在Activity的OnCreate()方法中，也要加在重写的onWindowFocusChanged()方法中，在窗口获取焦点时再将Flag设置一遍，否则可能导致无法达到预想的效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Overridepublic void onWindowFocusChanged(boolean hasFocus) {    super.onWindowFocusChanged(hasFocus);    if(hasFocus){
        getWindow().getDecorView().setSystemUiVisibility(
                View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，有个部份要稍微留意一下，如果不希望界面的内容被上拉到状态栏(Status bar)的话，要记得在界面(Layout)XML文件中，在最外层Layout中将fitsSystemWindows属性设置为true。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:fitsSystemWindows=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;!-- Content --&amp;gt;&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置了前文的5个Flag之后，锁屏页效果图如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqywL3fYNXVTsVqjfgCZ0RbU54TZoplP2NibfoCahPN62iaM5ibjAgXQWu1fg/0?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;手指在屏幕底端上划，Navigation Bar会弹出，悬浮于锁屏页底部，随后自动消失。Status Bar也按照我们预期的那样，悬浮在上方，没有隐藏。&lt;/p&gt;
&lt;h3 id=&#34;2-透明栏&#34;&gt;2. 透明栏&lt;/h3&gt;
&lt;p&gt;什么是透明栏？Google 在 Android 4.4 的 API 描述页面里提到了“Translucent system UI styling”，即半透明化的系统UI风格。这个“半透明化”包括了状态栏和通知栏，当开发者让应用支持这个新特性的时候，状态栏和导航栏可以单独/同时变为渐变的半透明样式，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqyw30vbbO3QRaGB26O7hPMpYoF6ZFsTvYZ56AoVB13vMK2bpgxN9qJibHw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在 Android 5.0 之后引入了 Material Design，状态栏和导航栏也玩出了更多花样。现在除了原有的“半透明”模式以外，还有“全透明”以及“变色”模式，一种会完全隐藏背景，另一种可以取色作为背景颜色，多种样式的透明栏如下图（上图为透明状态栏，下图为透明导航栏）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqyw65Enr6djzOV3kFMdlawhW6JIeFwAqU4d2wuibOkLlrAricVAr8gfxG0w/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqyw7Whgm5eUxTZib85xib48L5laiauCticUKwicPWQjicrAA4aE69Ga0Vsrp02g/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;所以，透明栏只是能够改变状态栏和导航栏的颜色，并不像沉浸模式那样隐藏状态栏和导航栏，两者是有本质区别的。&lt;/p&gt;
&lt;p&gt;对于Android 4.4以上5.0以下的版本，设置透明状态栏的方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if(Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.KITKAT){
    Window window = getWindow();
    window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于Android 5.0及以上版本，设置透明状态栏的方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.LOLLIPOP) {
    Window window = getWindow();
    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    window.getDecorView()
            .setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    window.setStatusBarColor(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了要清理掉4.4的FLAG_TRANSLUCENT_STATUS外，还要配合SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，添加标志位FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，并调用setStatusBarColor设置状态栏的颜色为透明。&lt;/p&gt;
&lt;p&gt;在综合运用了沉浸模式和透明栏之后，锁屏页效果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqyw0SOBTEEwP3AajCkzHXoLz1tpw0McxfHGaJ25PKejSKjkBmDd6lwa0Q/0?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;四-指纹解锁&#34;&gt;四、指纹解锁&lt;/h2&gt;
&lt;p&gt;到这里，我们的锁屏页已经基本完工，完全能够非常优雅地解决用户的痛点，但是跟当下App自定义锁屏页的区别并不明显。接下来对新型号手机普遍具备的指纹解锁功能的考虑，则能够为锁屏页增色不少。&lt;/p&gt;
&lt;h3 id=&#34;1-指纹识别无法解锁自定义锁屏页的问题&#34;&gt;1. 指纹识别无法解锁自定义锁屏页的问题&lt;/h3&gt;
&lt;p&gt;持有指纹解锁手机的用户在使用App自定义锁屏页时会出现一种困惑，当你点亮屏幕，能够看到自定义锁屏页，在使用指纹解锁成功之后（部分机型指纹解锁操作只能在系统锁屏页进行），自定义锁屏页依然存在，你还是需要划开自定义锁屏页，才能看到手机主界面。&lt;/p&gt;
&lt;p&gt;解决这一问题的方案是一种取巧的方法，那就是在锁屏页的service中监听ACTION_USER_PRESENT广播。ACTION_USER_PRESENT广播是系统锁屏解锁广播，当系统锁屏页解锁时就会触发。如果在接收到这一广播时，将自定义锁屏页finish掉，就能避免在指纹解锁成功后自定义锁屏页仍然显示的问题。但是细心的读者会发现这种解法在逻辑上还存在问题，因为在用户没有设置锁屏密码的情况下，前文自定义锁屏页在onCreate()时设置的FLAG_DISMISS_KEYGUARD标志位能够轻易解锁系统的锁屏页，并触发ACTION_USER_PRESENT广播，此时自定义锁屏页的Service接收到这一广播后，发finish广播给自定义锁屏页，导致自定义锁屏页刚create就finish掉了，永远不可能出现。&lt;br&gt;
　　&lt;br&gt;
因此，我们必须对场景进行区分，只在有锁屏密码的情况下，才对接收到的ACTION_USER_PRESENT广播进行处理，finish自定义锁屏页。即在BroadcastReceiver的onReceive()方法中加入如下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if(intent.getAction().equals(Intent.ACTION_USER_PRESENT)) {    if (VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.JELLY_BEAN) {        if (km.isKeyguardSecure()) {
            MLog.d(TAG, &amp;quot;KeyguardSecure!&amp;quot;);
            Intent i = new Intent(NOTIFY_USER_PRESENT);
            context.sendBroadcast(i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里KeyguardManager对象km的isKeyguardSecure()方法就是用来判断是否设置了锁屏密码。NOTIFY_USER_PRESENT是自定义广播，用来通知锁屏页Activity调用finish方法。&lt;br&gt;
　　&lt;br&gt;
这种做法是合理的，因为如果没有设置锁屏密码，FLAG_DISMISS_KEYGUARD标志位解锁系统锁屏之后，到达上述代码块，isKeyguardSecure()返回为false，不会导致自定义锁屏页Activity的finish操作。而如果设置了锁屏密码，FLAG_DISMISS_KEYGUARD必然无法解锁系统锁屏，到达不了上述代码块，也不会finish。这样就避免了自定义锁屏页刚创建出来就将自己finish掉的困境。另一方面，其他非FLAG_DISMISS_KEYGUARD方式触发的解锁，比如指纹解锁，都会使Activity消失，满足了需求。&lt;/p&gt;
&lt;h3 id=&#34;2-自定义锁屏页下指纹识别无法使用的问题&#34;&gt;2. 自定义锁屏页下指纹识别无法使用的问题&lt;/h3&gt;
&lt;p&gt;此外，有些手机型号，比如小米，在自定义锁屏页罩在系统锁屏页之上时（设置有锁屏密码），指纹解锁是无效的，也就是必须要划开自定义锁屏页，在系统锁屏页上才能进行指纹解锁。为了改善这种体验，我们可以在Activity中引入指纹解锁API，识别指纹并解锁，具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  private void startFingerPrintListening() {    if (!isFingerprintAuthAvailable()) {        return;
    } else {        if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M) {            if (checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) {
                mFingerprintManager.authenticate(null, mCancellationSignal, 0, new FingerprintManager.AuthenticationCallback() {                    @Override
                    public void onAuthenticationError(int errorCode, CharSequence errString) {                        super.onAuthenticationError(errorCode, errString);
                    }                    @Override
                    public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {                        super.onAuthenticationSucceeded(result);
                        finish();
                    }                    @Override
                    public void onAuthenticationFailed() {                        super.onAuthenticationFailed();
                    }
                }, null);                return;
            }
        }
    }
}  

public boolean isFingerprintAuthAvailable() {    
	if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M) {
        mKeyguardManager = (KeyguardManager) getSystemService(Activity.KEYGUARD_SERVICE);        if(!mKeyguardManager.isKeyguardSecure()){            return false;
        }        if (checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) {

            mFingerprintManager = (FingerprintManager) getSystemService(Activity.FINGERPRINT_SERVICE);
            mCancellationSignal = new CancellationSignal();            return  mFingerprintManager.isHardwareDetected()&amp;amp;&amp;amp;mFingerprintManager.hasEnrolledFingerprints();
        }else{            return false;
        }
    }else{        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，不要忘记在Manifest中加入适当的权限：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.USE_FINGERPRINT&amp;quot;/&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在调用指纹识别功能之前，我们需要判断指纹识别功能是否可用，以及APP是否有相应的权限。这一过程体现在isFingerprintAuthAvailable()中，第一步是获取KeyguardManager对象，调用isKeyguardSecure()判断是否设置有锁屏密码，如果有，则需进一步判断。checkSelfPermission用来判断APP是否有指纹识别的权限(SDK 23要求)，如果有则获取FingerprintManager对象，调用该对象的isHardwareDetected()方法判断指纹识别硬件是否可用，调用hasEnrolledFingerprints()判断是否有事先录入好的指纹，只有以上条件都满足，接下来才能调用指纹识别功能。&lt;/p&gt;
&lt;p&gt;指纹识别的调用体现在startFingerPrintListening()方法中，主要就是调用FingerprintManager的方法.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/tnZGrhTk4ddckBzbwicjmJ9NWxK6vzqywxCeGc5OGJr9CVyTj7cpnibtPelpsuNhIl3rpgHn5GCPlficgvNAVq9Yw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其中，crypto参数代表Android6.0中crypto objects的wrapper class，可以通过该对象使authenticate过程更加安全，也可以不使用，这里我们将其设为null；cancel用来取消anthenticate(),我们new出一个对象传入就可以；flags是标志位，设置为0；callback为指纹识别回调，包含指纹识别的核心方法：onAuthenticationError()是指纹匹配连续失败后的回调（几十秒后才能继续匹配），onAuthenticationSucceeded()是指纹匹配成功的回调，onAuthenticationFailed()是指纹匹配失败时的回调。我们在这几个方法中做相应的处理即可，在onAuthenticationSucceeded()方法中调用finish()，就能够在指纹识别成功后关闭Activity。&lt;/p&gt;
&lt;h2 id=&#34;五-总结&#34;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;通过以上内容的分享，本鹅希望能够对大家的开发有所帮助，如果内容有问题，也希望大家指点。综上所述，在Android上实现自定义锁屏页并不是一件复杂的事情，关键是对一些技术点的把握要比较清楚。Service中启动Activity的正确方法，广播静态注册与动态注册的差别，touch事件的分发传播机制，透明栏与沉浸模式的综合运用，以及指纹识别新技术的应用，都有很多值得推敲的地方。笔者当初实现自定义锁屏页时，没有太多思考，有时照搬前人的做法，有时各种flag随便添加，有时新旧API混淆，虽然实现了需求，但是代码不够简洁，可读性也差。因此，在今后的开发过程中，除了要快速实现需求，还要在随后的维护中，多多思考和研究，使代码能够达到“少一行不行，多一行难受”的境界。&lt;/p&gt;
">android 锁屏研究</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-huo-de-view-de-kuan-he-gao/"" data-c="
          &lt;p&gt;在oncreate()中利用view.getWidth()或是view.getHeiht()来获取view的宽和高，看似没有问题，其实他们去得值是0，并不是你想要的结果？&lt;/p&gt;
&lt;p&gt;这是为什么呢？&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;在调用oncreate()方法时，界面处于不可见状态，内存加载组件还没有绘制出来，你是无法获取他的尺寸。&lt;/p&gt;
&lt;p&gt;那如何在绘制组件之前能获取到该组件的尺寸大小呢？&lt;/p&gt;
&lt;p&gt;这里有三种方法，经过验证的：&lt;/p&gt;
&lt;p&gt;方法一 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//测量方法
int width =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);
int height =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);
view.measure(width,height);
int height=view.getMeasuredHeight(); 
int width=view.getMeasuredWidth();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//增加组件绘制之前的监听
ViewTreeObserver
 vto =view.getViewTreeObserver(); 
vto.addOnPreDrawListener(new
ViewTreeObserver.OnPreDrawListener() { 
   @Override
    public
booleanonPreDraw() { 
       int
height =view.getMeasuredHeight(); 
       int
width =view.getMeasuredWidth();
   }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法三 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//增加整体布局监听
ViewTreeObserver
 vto = view.getViewTreeObserver();  
vto.addOnGlobalLayoutListener(new
OnGlobalLayoutListener(){ 
    @Override 
    public
voidonGlobalLayout() { 
      view.getViewTreeObserver().removeGlobalOnLayoutListener(this);     
    int
height =view.getMeasuredHeight(); 
     int
width =view.getMeasuredWidth();  
    } 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，在activity进入运行期时，组件的尺寸获取方法就很简单了，直接getWidth()和getHeight().&lt;br&gt;
来源： http://blog.csdn.net/yangdeli888/article/details/25405263&lt;/p&gt;
">Android 获得view的宽和高</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-zhong-yu-zhi-dao-log-xian-shi-bu-quan-de-yuan-yin-liao/"" data-c="
          &lt;p&gt;一个优秀的软件系统一定会实时保存系统运行过程中产生的异常或非异常性数据，用于记录系统运行过程产生的各种行为，作为日后发现问题、跟踪问题并解决问题的一个很重要的依据。一般以输出文件的形式保存，同时也可以选择性的在控台打印。日志处理，可谓是任何软件开发过程中必不可少的一个环节。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;在Android应用开发阶段，我们常常会使用系统提供的日志打印功能选择性地在Logcat控制台上打印一些数据信息，便于更加直观地调试跟踪应用运行的一个状态，常见如客户端与服务器通讯过程中涉及到的URL链接、request请求参数和response响应结果等。&lt;/p&gt;
&lt;p&gt;但如果打印的message过长，比如接口响应结果过大，将会导致Logcat控台数据显示不全。自打使用Log以来经常遇到这个问题，之前也是没太在意，毕竟message太长的情况也是少见，偶尔遇到这种情况就通过Debug工具跟踪调试，复制对应response信息到bejson等其他辅助工具上格式化浏览，多少还是有点不方便。&lt;/p&gt;
&lt;p&gt;后来经过查询才得知，Android系统的单条日志打印长度是有限的，在底层Logger驱动程序的一个类Logger.h头文件中有如下两行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define LOGGER_ENTRY_MAX_LEN        (4*1024)  
#define LOGGER_ENTRY_MAX_PAYLOAD    \\  
    (LOGGER_ENTRY_MAX_LEN - sizeof(struct logger_entry))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，系统显示单条Log信息的长度是固定的，为4*1024个字符长度！Logcat使用的liblog资源包也提到，使用Log打印的message有可能被log内核驱动缩短：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;The message may have been truncated by the kernel log driver.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解了其中的长度限制，就好办了。我们可以对Message做个长度判断，采取分段打印的办法输出日志信息，比如这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if(xml.length() &amp;gt; 4000) {
 for(int i=0;i&amp;lt;xml.length();i+=4000){
    if(i+4000&amp;lt;xml.length())
        Log.i(&amp;quot;rescounter&amp;quot;+i,xml.substring(i, i+4000));
     else
        Log.i(&amp;quot;rescounter&amp;quot;+i,xml.substring(i, xml.length()));
    }
} else
    Log.i(&amp;quot;resinfo&amp;quot;,xml);
}
&lt;/code&gt;&lt;/pre&gt;
">Android 终于知道Log显示不全的原因了</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-onuserleavehint-he-onuserinteraction/"" data-c="
          &lt;p&gt;onUserLeaveHint 当用户的操作使一个activity准备进入后台时，此 方法会像activity的生命周期的一部分被调用。例如，当用户按下 Home键，&lt;br&gt;
Activity#onUserLeaveHint()将会被回调。但是当来电导致来电activity自动占据前台，Activity#onUserLeaveHint()将不会被回调。&lt;/p&gt;
&lt;p&gt;onUserLeaveHint() 用户手动离开当前activity，会调用该方法，比如用户主动切换任务，短按home进入桌面等。系统自动切换activity不会调用此方法，如来电，灭屏等。&lt;/p&gt;
&lt;p&gt;onUserInteraction() activity在分发各种事件的时候会调用该方法，注意：启动另一个activity,Activity#onUserInteraction()会被调用两次，一次是activity捕获到事件，另一次是调用Activity#onUserLeaveHint()之前会调用Activity#onUserInteraction()。&lt;/p&gt;
">android onUserLeaveHint和onUserInteraction</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-build-ji-xiang-guan-lei/"" data-c="
          &lt;h1 id=&#34;android-build及相关类&#34;&gt;Android Build及相关类&lt;/h1&gt;
&lt;p&gt;Build ：Information about the current build, extracted from system properties.&lt;br&gt;
官方文档有以下属性：&lt;/p&gt;
&lt;!--more--&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191058.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Build.BOARD // 主板   
Build.BRAND // Android系统定制商   
Build.CPU_ABI // cpu指令集   
Build.DEVICE // 设备参数   
Build.DISPLAY // 显示屏参数   
Build.FINGERPRINT // 硬件名称   
Build.HOST  
Build.ID // 修订版本列表   
Build.MANUFACTURER // 硬件制造商   
Build.MODEL // 版本   
Build.PRODUCT // 手机制造商   
Build.TAGS // 描述build的标签   
Build.TIME  
Build.TYPE // builder类型   
Build.USER  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build.VERSION类：&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119191114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 当前开发代号   
Build.VERSION.CODENAME  
// 源码控制版本号   
Build.VERSION.INCREMENTAL  
// 版本字符串   
Build.VERSION.RELEASE  
// 版本号   
Build.VERSION.SDK  
// 版本号   
Build.VERSION.SDK_INT  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Build.VERSION.SDK_INT可与switch搭配用   
switch (Build.VERSION.SDK_INT) {  
case Build.VERSION_CODES.BASE: // 1.0   
 break;  
   
case Build.VERSION_CODES.BASE_1_1: // 1.1   
 break;  
   
case Build.VERSION_CODES.CUPCAKE: // 1.5   
 break;  
   
case Build.VERSION_CODES.CUR_DEVELOPMENT: // current dev version   
 break;  
   
case Build.VERSION_CODES.DONUT: // 1.6   
 break;  
   
case Build.VERSION_CODES.ECLAIR: // 2.0   
 break;  
   
case Build.VERSION_CODES.ECLAIR_0_1: // 2.0.1   
 break;  
   
case Build.VERSION_CODES.ECLAIR_MR1: // 2.1   
 break;  
}  
&lt;/code&gt;&lt;/pre&gt;
">Android Build及相关类</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-50-zhi-hou-yin-shi-sheng-ming-intent-qi-dong-service-yin-fa-de-wen-ti/"" data-c="
          &lt;h3 id=&#34;一概述&#34;&gt;一.概述&lt;/h3&gt;
&lt;p&gt;Android系统升级到5.0之后做了不少的变化(5.0变化),开发人员一定要注意这些变化,要不然就有的折腾了.这次最大的变化应该是把Dalvik虚拟机改成了ART(Android Runtime),后续会专门讲解这一块.其他的都是一些零碎的问题,例如前段时间发了一篇Android 5.0之后修改了HashMap的实现(传送门).这篇主要讲一下遇到跟Service相关的问题.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;二详情&#34;&gt;二.详情&lt;/h3&gt;
&lt;p&gt;Service身为Android四大组件之一,它的使用频率还是比较高的,并且现在主要都是运用在比较关键的部位,例如升级推送等.在Android 5.0之后google出于安全的角度禁止了隐式声明Intent来启动Service.也禁止使用Intent filter.否则就会抛个异常出来.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;官方的解释如下.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么google到底是怎么限制的呢?限制的判定条件是什么呢？这些都可以从Android 4.4和Android 5.0的源码中找到区别.&lt;/p&gt;
&lt;p&gt;在Android 4.4的ContextImpl源码中,能看到如果启动service的intent的component和package都为空并且版本大于KITKAT的时候只是报出一个警报,告诉开发者隐式声明intent去启动Service是不安全的.再往下看,丫的异常都写好了只是注释掉了,看来google早就想这么干了.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void validateServiceIntent(Intent service) {  
    if (service.getComponent() == null &amp;amp;&amp;amp; service.getPackage() == null) {  
        if (true || getApplicationInfo().targetSdkVersion &amp;gt;= Build.VERSION_CODES.KITKAT) {  
            Log.w(TAG, &amp;quot;Implicit intents with startService are not safe: &amp;quot; + service  
                    + &amp;quot; &amp;quot; + Debug.getCallers(2, 3));  
            //IllegalArgumentException ex = new IllegalArgumentException(  
            //        &amp;quot;Service Intent must be explicit: &amp;quot; + service);  
            //Log.e(TAG, &amp;quot;This will become an error&amp;quot;, ex);  
            //throw ex;  
        }  
    }  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然在Android 5.0的源码中上面注释的代码已经不注释了,当targetSdkVersion版本大于LOLLIPOP直接异常抛出来,要求Service intent必须显式声明.所以如果开发的应用指定targetSdkVersion版本是小于LOLLIPOP的话还是按以前的方式给报个警报,这也就造成了如果没有做了完善的Android 5.0兼容就贸然把targetSdkVersion升到LOLLIPOP的话很有可能就会碰到这个问题.并且这个问题是很严重的,想象一下,你的app自升级的Service是隐式启动的,碰到这个问题后app就不能自升级了,这批用户有可能就一直停留在当前版本.会产生很致命的问题.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void validateServiceIntent(Intent service) {  
    if (service.getComponent() == null &amp;amp;&amp;amp; service.getPackage() == null) {  
        if (getApplicationInfo().targetSdkVersion &amp;gt;= Build.VERSION_CODES.LOLLIPOP) {  
            IllegalArgumentException ex = new IllegalArgumentException(  
                    &amp;quot;Service Intent must be explicit: &amp;quot; + service);  
            throw ex;  
        } else {  
            Log.w(TAG, &amp;quot;Implicit intents with startService are not safe: &amp;quot; + service  
                    + &amp;quot; &amp;quot; + Debug.getCallers(2, 3));  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从源码中的逻辑来看的话,判断一个intent是不是显式声明的点就是component和package,只要这两个有一个生效就不算是隐式声明的,接下来继续分析一下Intent的源码,可以看到下面三种构造方式,设置action来声明Intent是没有构建component的,所以显式声明需要用到第一和第二种构造(还有带packagename或component的拷贝构造),或者后面设置package属性.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Intent(Context packageContext, Class&amp;lt;?&amp;gt; cls) {  
    mComponent = new ComponentName(packageContext, cls);  
}  
public Intent(String action) {  
    setAction(action);  
}  
public Intent(String action, Uri uri,  
              Context packageContext, Class&amp;lt;?&amp;gt; cls) {  
    setAction(action);  
    mData = uri;  
    mComponent = new ComponentName(packageContext, cls);  
}  
public Intent setPackage(String packageName) {  
    if (packageName != null &amp;amp;&amp;amp; mSelector != null) {  
        throw new IllegalArgumentException(  
                &amp;quot;Can&#39;t set package name when selector is already set&amp;quot;);  
    }  
    mPackage = packageName;  
    return this;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;三案例分析&#34;&gt;三.案例分析&lt;/h3&gt;
&lt;p&gt;经过这么分析之后单看这个问题是很好做兼容的,但是结合实际的一些复杂情况就不一定了.之前就碰到过一个比较复杂的兼容.&lt;/p&gt;
&lt;p&gt;场景复现:&lt;/p&gt;
&lt;p&gt;将项目里的targetSdkVersion升级到22之后,针对这篇Service的问题做了兼容,so easy啊,但是万万没想到项目里用的某盟的第三方登陆分享的SDK版本太老了(一年前),开发没有去升级SDK跟check兼容性.并且经过四轮测试愣是没有测到这个点,结果在线上发现了这个Bug,泥煤啊Android 5.0设备用微博登陆就闪退,泥煤啊.幸好这个项目做了线上bug热修复,这个时候就体现出这个功能的好处了,之前又博客简单讲解了一下实现原理(传送门).&lt;/p&gt;
&lt;p&gt;接下来思路就是升级最新的某盟SDK然后打个补丁包给线上升级过去.然而升级完最新的SDK之后发现并没有什么卵用,看过热修复那篇博客的童鞋应该可以想到,那种打dex补丁的形式是不能添加新资源的,而最新的SDK新增了不少资源进来,所以这个思路是行不通的.&lt;br&gt;
既然升级最新的SDK不行,那能不能修改老的SDK自己给它做Android 5.0兼容呢?理论上来说是可行的.说干就干,先记录一下SDK崩溃的记录.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;再把SDK jar反编译一下,里面很多被混淆过,幸好崩溃的位置这个类的逻辑还有可读性都还比较完整.直接定位到崩溃的方法.果然是隐式绑定的Service,上面分析源码的时候从Intent构造源码可以看到这种声明方式既没有构造有效的component,也没有提供出packageName,崩了也无话可说.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;既然定位到了位置,那么就单独把这个类抽离出来,新开一个Android工程,建立一个library的module,里面只有接下来要修改的这一个文件,由于这个类里面会引用SDK jar包里面的资源,所以也要把jar包引入到module里面.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;包名一定要和之前一模一样.因为我们修改过之后要替换掉SDK中原有的.class文件.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;build一下每问题,OK.因为这里启动的Service是新浪微博客户端里面的一个Service,连接上之后会通过AIDL进行跨进程通讯.所以我们没办法在构造Intent的时候就显式声明.既然没有办法构建有效的component,那么给它设置一个包名也可以生效的.既然是新浪微博那么包名应该是com.sina.weibo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean a(Activity paramActivity)  
{  
    Context localContext = paramActivity.getApplicationContext();  
    Intent mIntent = new Intent(&amp;quot;com.sina.weibo.remotessoservice&amp;quot;);  
    mIntent.setPackage(&amp;quot;com.sina.weibo&amp;quot;);  
    return localContext.bindService(mIntent, this.serviceConnection, Context.BIND_AUTO_CREATE);  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reBuild一下,然后去主项目build文件夹里面的中间资源里面找到module打成的jar包,直接把编译好的.class解压出来.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;解压某盟的SDK,进入到正确的路径下直接替换刚才编译出来的.class文件.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119190914.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;回到SDK的跟目录下,运行 jar cvf sdk.jar * 命令进行重打包,将重新打好的SDK替换到项目里面.验证bug.BinGo!搞定!这样就可以打个dex补丁包给线上的版本更新过去修复5.0兼容的bug了.&lt;/p&gt;
&lt;h3 id=&#34;四总结&#34;&gt;四.总结&lt;/h3&gt;
&lt;p&gt;这里结合这个案例简单分析了一下Android 5.0之后对启动绑定Service做的变化.碰到这种问题也是因为做兼容的时候没有覆盖所有的地方,这些坑都是跑不掉的.&lt;/p&gt;
">Android 5.0之后隐式声明Intent 启动Service引发的问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/android-shi-jian-chu-li-ji-zhi-zhi-requestdisallowintercepttouchevent/"" data-c="
          &lt;p&gt;当手指触摸到屏幕时，系统就会调用相应View的onTouchEvent，并传入一系列的action。当有多个层级的View时，在父层级允许的情况下，这个action会一直向下传递直到遇到最深层的View。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;touch事件最先调用的是最底层View的onTouchEent，如果View的onTouchEvent接收到某个touch action并作了相应处理，最后有两种返回方式return true和return false；
&lt;ul&gt;
&lt;li&gt;return true会告诉系统当前的View需要处理这次的touch事件，以后的系统发出的ACTION_MOVE，ACTION_UP还是需要继续监听并接收的，而且这次的action已经被处理掉了，父层的View是不可能出发onTouchEvent了。所以每一个action最多只能有一个onTouchEvent接口返回true。&lt;/li&gt;
&lt;li&gt;return false，便会通知系统，当前View不关心这一次的touch事件，此时这个action会传向父级，调用父级View的onTouchEvent。但是这一次的touch事件之后发出的任何action，该View都不会再接受，onTouchEvent在这一次的touch事件中再也不会触发，也就是说一旦View返回false，那么之后的ACTION_MOVE，ACTION_UP等ACTION就不会在传入这个View，但是下一次touch事件的action还是会传进来的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面说了底层的View能够接收到这次的事件有一个前提条件：在父层级允许的情况下。假设不改变父层级的dispatch方法，在系统调用底层onTouchEvent之前会先调用父View的onInterceptTouchEvent方法判断，父层View是不是要截获本次touch事件之后的action。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果onInterceptTouchEvent返回了true，那么本次touch事件之后的所有action都不会再向深层的View传递，统统都会传给负层View的onTouchEvent，就是说父层已经截获了这次touch事件，之后的action也不必询问onInterceptTouchEvent，在这次的touch事件之后发出的action时onInterceptTouchEvent不会再次调用，知道下一次touch事件的来临。&lt;/li&gt;
&lt;li&gt;如果onInterceptTouchEvent返回false，那么本次action将发送给更深层的View，并且之后的每一次action都会询问父层的onInterceptTouchEvent需不需要截获本次touch事件。只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，touch事件能够传到这里已经是最后一站了，肯定会调用View的onTouchEvent。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于底层的View来说，有一种方法可以阻止父层的View截获touch事件，就是调用getParent().requestDisallowInterceptTouchEvent(true);方法。一旦底层View收到touch的action后调用这个方法那么父层View就不会再调用onInterceptTouchEvent了，也无法截获以后的action。&lt;br&gt;
用例子总结一下onInterceptTouchEvent和onTouchEvent的调用顺序：&lt;br&gt;
假设最高层View叫OuterLayout，中间层View叫InnerLayout，最底层View叫MyVIew。调用顺序是这样的（假设各个函数返回的都是false）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OuterLayout.onInterceptTouchEvent-&amp;gt;InnerLayout.onInterceptTouchEvent-&amp;gt;MyView.onTouchEvent-&amp;gt;InnerLayout.onTouchEvent-&amp;gt;OuterLayout.onTouchEvent。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句话是告诉父view，我的事件自己处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override    
    public boolean dispatchTouchEvent(MotionEvent ev) {   
        getParent().requestDisallowInterceptTouchEvent(true);  
        return super.dispatchTouchEvent(ev);    
    }  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以写成类似于下面这样，当用户按下的时候，我们告诉父组件，不要拦截我的事件（这个时候子组件是可以正常响应事件的），拿起之后就会告诉父组件可以阻止。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean onTouch(View v, MotionEvent event) {  
     switch (event.getAction()) {  
     case MotionEvent.ACTION_MOVE:   
         pager.requestDisallowInterceptTouchEvent(true);  
         break;  
     case MotionEvent.ACTION_UP:  
     case MotionEvent.ACTION_CANCEL:  
         pager.requestDisallowInterceptTouchEvent(false);  
         break;  
     }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一个关于子控件和父控件的事件响应问题&lt;br&gt;
当父控件中有子控件的时候，并且父控件和子空间都有事件处理（比如单击事件）。这时，点击子控件，父控件的单击事件就无效了。&lt;/p&gt;
&lt;p&gt;比如一个LinearLayout里面有一个子控件TextView，但是TextView的大小没有LinearLayout大&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果LinearLayout和TextView都设置了单击事件，那么点击TextView区域的时候，触发的是TextView的事件，&lt;br&gt;
点击TextView以外的区域的时候，还是触发的LinearLayout的事件。&lt;/li&gt;
&lt;li&gt;如果LinearLayout设置了单击事件，而TextView没有设置单击事件的话，那么不管单击的是TextView区域，还是TextView以外的区域，都是触发的LinearLayout的单击事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果LinearLayout的大小和TextView一样的话，那么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果LinearLayout和TextView都设置了单击事件，那么只有TextView的单击事件有效&lt;/li&gt;
&lt;li&gt;如果LinearLayout设置了单击事件，而TextView没有设置单击事件的话，那么触发的是LinearLayout的单击事件&lt;/li&gt;
&lt;/ol&gt;
">android 事件处理机制之requestDisallowInterceptTouchEvent</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/yue-wen-er-shou-yun-ying-huo-dong-ji-hua-shu/"" data-c="
          &lt;p&gt;推广乐享二手板块，让大家手中的闲置资源游起来&lt;/p&gt;
&lt;h2 id=&#34;针对对象&#34;&gt;针对对象&lt;/h2&gt;
&lt;p&gt;全体阅文同事，因交易性质为物品交易，可划分北京分区，上海分区，其他分区等&lt;/p&gt;
&lt;h2 id=&#34;活动目的&#34;&gt;活动目的&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;推广板块&lt;/li&gt;
&lt;li&gt;处理闲置资源&lt;/li&gt;
&lt;li&gt;促进员工交流&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;活动形式&#34;&gt;活动形式&lt;/h2&gt;
&lt;p&gt;整体形式为常见的积分奖励，虽然积分不能转换为人民币，但是此活动中，我们可以类比为相应数目的代金券，补贴券等&lt;/p&gt;
&lt;p&gt;活动1：签到得积分券&lt;br&gt;
目的：拉新活动，有人才有活动&lt;br&gt;
活动2：最先成交积分补贴券&lt;br&gt;
目的：小额补贴，促进活动交流&lt;br&gt;
活动3：最活跃激励积分&lt;br&gt;
目的：大额补贴，促进活动交流&lt;br&gt;
活动4：微信群创建&lt;br&gt;
目的：因活动性质为物品购买，可以创建北京微信群，上海微信群等，方便大家线下交流。&lt;/p&gt;
&lt;h2 id=&#34;活动规则&#34;&gt;活动规则&lt;/h2&gt;
&lt;p&gt;活动1：签到得积分券&lt;br&gt;
我们可以每天在乐享上开一个活动，每天10：00开启，签到得前20名同学可以获取1积分（待定），时间持续5天&lt;/p&gt;
&lt;p&gt;活动2：最先成交积分补贴券&lt;br&gt;
一共划分了5个分类，每个分类下，最先发帖并成交的5名同学，每人可以获得5积分(待定)补贴&lt;br&gt;
需要各位同学自行举证，比如截图发时间等，不然统计太难了。&lt;/p&gt;
&lt;p&gt;活动3：最活跃激励积分&lt;br&gt;
在活动1，活动2的一周时间内，成交次数最多的同学，可以获得50积分奖励，进行激励&lt;/p&gt;
&lt;h2 id=&#34;进度管理&#34;&gt;进度管理&lt;/h2&gt;
&lt;p&gt;预热期：10月12日发布推广消息&lt;br&gt;
活动期：10月14-19日进行活动&lt;br&gt;
奖品发放期：10月22日进行积分发放（视统计难度）&lt;/p&gt;
&lt;h2 id=&#34;负责人&#34;&gt;负责人&lt;/h2&gt;
&lt;p&gt;合开部门：xxx&lt;br&gt;
员工关系：xxx&lt;/p&gt;
&lt;h2 id=&#34;推广策略&#34;&gt;推广策略&lt;/h2&gt;
&lt;p&gt;前期：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;乐享推送活动细则文章&lt;/li&gt;
&lt;li&gt;乐享置顶活动细则文章&lt;/li&gt;
&lt;li&gt;邮件推送活动文章（视打扰程度，如觉得打扰程度较大，可忽略）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;中期：&lt;br&gt;
1.乐享发布断舍离文章，促进大家交易动力。&lt;br&gt;
2.乐享发布二手益处文章，促进大家交易热情。&lt;/p&gt;
&lt;p&gt;后期：&lt;br&gt;
针对活动期间的疑问，持续整理文章。&lt;/p&gt;
&lt;h2 id=&#34;成本预估&#34;&gt;成本预估&lt;/h2&gt;
&lt;p&gt;活动1：签到得积分券&lt;br&gt;
5天 * 20人 * 1积分 = 100积分&lt;br&gt;
活动2：最先成交积分补贴券&lt;br&gt;
5分类 * 5帖子 * 5积分 = 125积分&lt;br&gt;
活动3：最活跃激励积分&lt;br&gt;
50积分&lt;/p&gt;
&lt;p&gt;总计：100 + 125 + 50 = 275 积分&lt;/p&gt;
&lt;h2 id=&#34;积分发放&#34;&gt;积分发放&lt;/h2&gt;
&lt;p&gt;有两种方式。&lt;br&gt;
1.负责人统计参与情况&lt;br&gt;
2.参与人员自统计&lt;/p&gt;
&lt;p&gt;考虑到活动性质，活动2，活动3统计比较麻烦&lt;br&gt;
可考虑 活动1可采用负责人统计，活动2，活动3可由参与人员自己截图举证，负责任人评判统计。&lt;/p&gt;
">二手运营活动计划书</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/mang-shan-gong-yuan-pa-shan-gong-lue/"" data-c="
          &lt;p&gt;周六去莽山公园爬山,提前查好攻略&lt;/p&gt;
&lt;p&gt;路线:&lt;/p&gt;
&lt;p&gt;8号线--&amp;gt;昌平线--&amp;gt;886路公交车&lt;/p&gt;
&lt;p&gt;8号线:到朱辛庄下车&lt;/p&gt;
&lt;p&gt;昌平线:昌平东关站下车(D口出)&lt;/p&gt;
&lt;p&gt;886路:昌平东关站上车,北京莽山公园站下车&lt;/p&gt;
&lt;p&gt;门票价格:20元&lt;/p&gt;
">莽山公园爬山攻略</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/yun-tai-shan-su-tong-gong-lue/"" data-c="
          &lt;h2 id=&#34;第一天&#34;&gt;第一天&lt;/h2&gt;
&lt;!--more--&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先到达岸上服务区,购买门票&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一站:万寿寺&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 10:45--11:00车程
 游览时长:20分钟
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二站:茱萸峰 (子房湖换乘点换乘)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 经过叠彩洞
 11:45--12:15车程
 药王洞--&amp;gt;半山腰
 云台观--&amp;gt;山顶
 12:20--14:45结束
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三站:子房湖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 快艇票  20元
 14:45-15:35结束
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第二天&#34;&gt;第二天&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第0站:小寨沟景区(潭瀑峡,泉瀑峡,猕猴谷)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 6:30--6:40车程
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一站:泉瀑峡&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 电瓶车(车票自费)
 两个多小时游玩
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二站:潭瀑峡&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 渡仙潭--&amp;gt;情人瀑、Y字瀑--&amp;gt;翡翠潭、碧玉潭、龙凤潭
 洗砚池--&amp;gt;清漪池--&amp;gt;水帘洞--&amp;gt;不老泉
 唐王试剑石--&amp;gt;龙眼
 中午11:40结束
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三站:红石峡&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 不选择老人的路线
 黄龙瀑--&amp;gt;试心石--&amp;gt;水帘洞--&amp;gt;天然壁画
 12:00--13:30结束
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">云台山速通攻略</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/jian-shao-task-jia-kuai-gradle-bian-yi-su-du/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;android{
     tasks.whenTaskAdded { task -&amp;gt;
        if (task.name.contains(&amp;quot;lint&amp;quot;)//如果instant run不生效，把clean这行干掉
                ||task.name.equals(&amp;quot;clean&amp;quot;)//项目中有用到aidl则不可以舍弃这个任务
                ||task.name.contains(&amp;quot;Aidl&amp;quot;)//用不到测试的时候就可以先关闭
                ||task.name.contains(&amp;quot;mockableAndroidJar&amp;quot;)
                ||task.name.contains(&amp;quot;UnitTest&amp;quot;)
                ||task.name.contains(&amp;quot;AndroidTest&amp;quot;)//用不到NDK和JNI的也关闭掉
                || task.name.contains(&amp;quot;Ndk&amp;quot;)
                || task.name.contains(&amp;quot;Jni&amp;quot;)
        ) {
                     task.enabled = false
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
">减少Task加快Gradle编译速度</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/httpsrawgithubusercontentcomyeziblogpicblogpicmaster20200119185732png/"" data-c="
          &lt;h1 id=&#34;1gradle下载不了&#34;&gt;1.gradle下载不了&lt;/h1&gt;
&lt;p&gt;修改gradle/wrapper/gradle-wrapper.properties中的distributionUrl，修改为gradle官网的地址，打开&lt;a href=&#34;http://services.gradle.org/distributions/&#34;&gt;http://services.gradle.org/distributions/&lt;/a&gt;，点击下载，复制浏览器的下载链接，如https://services.gradle.org/distributions/gradle-4.4-all.zip，替换实际的链接为http://219.238.7.67/files/125100000B1BAF17/services.gradle.org/distributions/gradle-4.4-all.zip，飞速！！！&lt;/p&gt;
&lt;h1 id=&#34;2download-httpsdlgooglecomdlandroidmaven2comandroidtoolsbuildgradle310gradle-310pom失败或者缓慢&#34;&gt;2.Download https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.1.0/gradle-3.1.0.pom，失败或者缓慢&lt;/h1&gt;
&lt;p&gt;这个问题坑了我好几天，烦死了。解决方案在此。&lt;a href=&#34;https://discuss.gradle.org/t/android-studio-could-not-get-resource-https-dl-google-com-dl-android-maven2-com-android-tools-build-gradle-3-1-0-gradle-3-1-0-pom/26734&#34;&gt;https://discuss.gradle.org/t/android-studio-could-not-get-resource-https-dl-google-com-dl-android-maven2-com-android-tools-build-gradle-3-1-0-gradle-3-1-0-pom/26734&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119185732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">android项目gradle下载问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/an-zhuo-zi-ding-yi-view-jin-jie-fen-lei-he-liu-cheng/"" data-c="
          &lt;p&gt;本章节为什么要叫进阶篇？(虽然讲的是基础内容)，因为从本篇开始，将会逐渐揭开自定义View的神秘面纱，每一篇都将比上一篇内容更加深入，利用所学的知识能够制作更加炫酷自定义View，就像在台阶上一样，每一篇都更上一层，帮助大家一步步走向人生巅峰，出任CEO，迎娶白富美。 误，是帮助大家更加了解那些炫酷的自定义View是如何制作的，达到举一反三的效果。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;自定义View绘制流程函数调用链(简化版)&lt;br&gt;
&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2jw1f638wreu74j30fc0heaay.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;一自定义view分类&#34;&gt;一.自定义View分类&lt;/h1&gt;
&lt;p&gt;我将自定义View分为了两类(sloop个人分类法，非官方)：&lt;/p&gt;
&lt;h3 id=&#34;1自定义viewgroup&#34;&gt;1.自定义ViewGroup&lt;/h3&gt;
&lt;p&gt;自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或各种Layout，包含有子View。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如：应用底部导航条中的条目，一般都是上面图标(ImageView)，下面文字(TextView)，那么这两个就可以用自定义ViewGroup组合成为一个Veiw，提供两个属性分别用来设置文字和图片，使用起来会更加方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2自定义view&#34;&gt;2.自定义View&lt;/h3&gt;
&lt;p&gt;在没有现成的View，需要自己实现的时候，就使用自定义View，一般继承自View，SurfaceView或其他的View，不包含子View。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如：制作一个支持自动加载网络图片的ImageView，制作图表等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS： 自定义View在大多数情况下都有替代方案，利用图片或者组合动画来实现，但是使用后者可能会面临内存耗费过大，制作麻烦更诸多问题。&lt;/p&gt;
&lt;h1 id=&#34;二几个重要的函数&#34;&gt;二.几个重要的函数&lt;/h1&gt;
&lt;h3 id=&#34;1构造函数&#34;&gt;1.构造函数&lt;/h3&gt;
&lt;p&gt;构造函数是View的入口，可以用于初始化一些的内容，和获取自定义属性。&lt;/p&gt;
&lt;p&gt;View的构造函数有四种重载分别如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void SloopView(Context context) {}
public void SloopView(Context context, AttributeSet attrs) {}
public void SloopView(Context context, AttributeSet attrs, int defStyleAttr) {}
public void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，关于View构造函数的参数有多有少，先排除几个不常用的，留下常用的再研究。&lt;/p&gt;
&lt;p&gt;有四个参数的构造函数在API21的时候才添加上，暂不考虑。&lt;/p&gt;
&lt;p&gt;有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ImageButton(Context context, AttributeSet attrs) {
    //调用了三个参数的构造函数，明确指定第三个参数
    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);
}

public ImageButton(Context context, AttributeSet attrs, int defStyleAttr) {
    //此处调了四个参数的构造函数，无视即可
    this(context, attrs, defStyleAttr, 0); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数。&lt;/p&gt;
&lt;p&gt;由于三个参数的构造函数第三个参数一般不用，暂不考虑，第三个参数的具体用法会在以后用到的时候详细介绍。&lt;/p&gt;
&lt;p&gt;排除了两个之后，只剩下一个参数和两个参数的构造函数，他们的详情如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//一般在直接New一个View的时候调用。
public void SloopView(Context context) {}

//一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。
public void SloopView(Context context, AttributeSet attrs) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下方法调用的是一个参数的构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//在Avtivity中
SloopView view  new SloopView(this);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下方法调用的是两个参数的构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;//在layout文件中 - 格式为： 包名.View名
&amp;lt;com.sloop.study.SloopView
  android:layout_width&amp;quot;wrap_content&amp;quot;
  android:layout_height&amp;quot;wrap_content&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于构造函数先讲这么多，关于如何自定义属性和使用attrs中的内容，在后面会详细讲解，目前只需要知道这两个构造函数在何时调用即可。&lt;/p&gt;
&lt;h3 id=&#34;2测量view大小onmeasure&#34;&gt;2.测量View大小(onMeasure)&lt;/h3&gt;
&lt;p&gt;Q: 为什么要测量View大小？&lt;/p&gt;
&lt;p&gt;A: View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。&lt;/p&gt;
&lt;p&gt;测量View大小使用的是onMeasure函数，我们可以从onMeasure的两个参数中取出宽高的相关数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值
    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式
    
    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值
    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面可以看出 onMeasure 函数中有 widthMeasureSpec 和 heightMeasureSpec 这两个 int 类型的参数， 毫无疑问他们是和宽高相关的， 但它们其实不是宽和高， 而是由宽、高和各自方向上对应的测量模式来合成的一个值：&lt;/p&gt;
&lt;p&gt;测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;二进制数值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;UNSPECIFIED&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;默认值，父控件没有给子view任何限制，子View可以设置为任意大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXACTLY&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;表示父控件已经确切的指定了子View的大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AT_MOST&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在int类型的32位二进制位中，31-30这两位表示测量模式,29~0这三十位表示宽和高的实际值，实际上如下：&lt;/p&gt;
&lt;p&gt;以数值1080(二进制为: 1111011000)为例(其中模式和实际数值是连在一起的，为了展示我将他们分开了)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式名称&lt;/th&gt;
&lt;th&gt;模式数值&lt;/th&gt;
&lt;th&gt;实际数值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;UNSPECIFIED&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;000000000000000000001111011000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXACTLY&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;000000000000000000001111011000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AT_MOST&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;000000000000000000001111011000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PS: 实际上关于上面的东西了解即可，在实际运用之中只需要记住有三种模式，用 MeasureSpec 的 getSize是获取数值， getMode是获取模式即可。&lt;/p&gt;
&lt;p&gt;注意：&lt;br&gt;
如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数。&lt;/p&gt;
&lt;h3 id=&#34;3确定view大小onsizechanged&#34;&gt;3.确定View大小(onSizeChanged)&lt;/h3&gt;
&lt;p&gt;这个函数在视图大小发生改变时调用。&lt;/p&gt;
&lt;p&gt;Q: 在测量完View并使用setMeasuredDimension函数之后View的大小基本上已经确定了，那么为什么还要再次确定View的大小呢？&lt;/p&gt;
&lt;p&gt;A: 这是因为View的大小不仅由View本身控制，而且受父控件的影响，所以我们在确定View大小的时候最好使用系统提供的onSizeChanged回调函数。&lt;/p&gt;
&lt;p&gt;onSizeChanged如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，它又四个参数，分别为 宽度，高度，上一次宽度，上一次高度。&lt;/p&gt;
&lt;p&gt;这个函数比较简单，我们只需关注 宽度(w), 高度(h) 即可，这两个参数就是View最终的大小。&lt;/p&gt;
&lt;h3 id=&#34;4确定子view布局位置onlayout&#34;&gt;4.确定子View布局位置(onLayout)&lt;/h3&gt;
&lt;p&gt;确定布局的函数是onLayout，它用于确定子View的位置，在自定义ViewGroup中会用到，他调用的是子View的layout函数。&lt;/p&gt;
&lt;p&gt;在自定义ViewGroup中，onLayout一般是循环取出子View，然后经过计算得出各个子View位置的坐标值，然后用以下函数设置子View位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;child.layout(l, t, r, b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四个参数分别为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;对应的函数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;View左侧距父View左侧的距离&lt;/td&gt;
&lt;td&gt;getLeft();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;View顶部距父View顶部的距离&lt;/td&gt;
&lt;td&gt;getTop();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;View右侧距父View左侧的距离&lt;/td&gt;
&lt;td&gt;getRight();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;View底部距父View顶部的距离&lt;/td&gt;
&lt;td&gt;getBottom();&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;具体可以参考 &lt;a href=&#34;http://www.gcssloop.com/customview/CoordinateSystem/&#34;&gt;坐标系&lt;/a&gt; 这篇文章。&lt;br&gt;
&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2gw1f1qzqwvkkbj308c0dwgm9.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PS：关于onLayout这个函数在讲解自定义ViewGroup的时候会详细讲解。&lt;/p&gt;
&lt;h3 id=&#34;5绘制内容ondraw&#34;&gt;5.绘制内容(onDraw)&lt;/h3&gt;
&lt;p&gt;onDraw是实际绘制的部分，也就是我们真正关心的部分，使用的是Canvas绘图。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于Canvas绘图是本章节的重点，会分几篇文章进行详细讲解，敬请期待OwO。&lt;/p&gt;
&lt;h3 id=&#34;6对外提供操作方法和监听回调&#34;&gt;6.对外提供操作方法和监听回调&lt;/h3&gt;
&lt;p&gt;自定义完View之后，一般会对外暴露一些接口，用于控制View的状态等，或者监听View的变化.&lt;/p&gt;
&lt;p&gt;本内容会在后续文章中以实例的方式进讲解。&lt;/p&gt;
&lt;h1 id=&#34;三重点知识梳理&#34;&gt;三.重点知识梳理&lt;/h1&gt;
&lt;p&gt;自定义View分类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS ：实际上ViewGroup是View的一个子类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;|类别	|继承自|	特点&lt;br&gt;
|View	|View SurfaceView 等	|不含子View&lt;br&gt;
|ViewGroup|	ViewGroup xxLayout等	|包含子View&lt;/p&gt;
&lt;p&gt;自定义View流程：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;构造函数&lt;/td&gt;
&lt;td&gt;View初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;onMeasure&lt;/td&gt;
&lt;td&gt;测量View大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;onSizeChanged&lt;/td&gt;
&lt;td&gt;确定View大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;onLayout&lt;/td&gt;
&lt;td&gt;确定子View布局(自定义View包含子View时有用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;onDraw&lt;/td&gt;
&lt;td&gt;实际绘制内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;提供接口&lt;/td&gt;
&lt;td&gt;控制View或监听View某些状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/reference/android/view/View.html&#34;&gt;View&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/reference/android/view/ViewGroup.html&#34;&gt;ViewGroup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/reference/android/view/View.MeasureSpec.html&#34;&gt;View.MeasureSpec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/a396901990/article/details/36475213&#34;&gt;onMeasure，MeasureSpec源码 流程 思路详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/angeldevil/p/3479431.html&#34;&gt;Android中自定义样式与View的构造函数中的第三个参数defStyle的意义 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/z103594643/article/details/6755017&#34;&gt;android view构造函数研究&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1102/1891.html&#34;&gt;Android View构造方法第三参数使用方法详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1102/1891.html&#34;&gt;Android 自定义View onMeasure方法的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wangkuiwu.github.io/2014/06/20/View-OnMeasure/&#34;&gt;Android API指南(二)自定义控件02之 onMeasure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/mengdd/p/3332882.html&#34;&gt;Android中View的绘制过程 onMeasure方法简述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.gcssloop.com/customview/CoordinateSystem/&#34;&gt;Android自定义View基础-坐标系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转自: &lt;a href=&#34;http://www.gcssloop.com/customview/CustomViewProcess/&#34;&gt;http://www.gcssloop.com/customview/CustomViewProcess/&lt;/a&gt;&lt;/p&gt;
">安卓自定义View进阶 - 分类和流程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/an-zhuo-zi-ding-yi-view-jin-jie-canvas-zhi-hui-zhi-tu-xing/"" data-c="
          &lt;p&gt;在上一篇自定义View分类与流程中我们了解自定义View相关的基本知识，不过，这些东西依旧还是理论，并不能拿来(zhuang)用(B), 这一次我们就了解一些能(zhaung)用(B)的东西。&lt;/p&gt;
&lt;p&gt;在本篇文章中，我们先了解Canvas的基本用法，最后用一个小示例来结束本次教程。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;一canvas简介&#34;&gt;一.Canvas简介&lt;/h1&gt;
&lt;p&gt;Canvas我们可以称之为画布，能够在上面绘制各种东西，是安卓平台2D图形绘制的基础，非常强大。&lt;/p&gt;
&lt;p&gt;一般来说，比较基础的东西有两大特点:&lt;br&gt;
1.可操作性强：由于这些是构成上层的基础，所以可操作性必然十分强大。&lt;br&gt;
2.比较难用：各种方法太过基础，想要完美的将这些操作组合起来有一定难度。&lt;/p&gt;
&lt;p&gt;不过不必担心，本系列文章不仅会介绍到Canvas的操作方法，还会简单介绍一些设计思路和技巧。&lt;/p&gt;
&lt;h1 id=&#34;二canvas的常用操作速查表&#34;&gt;二.Canvas的常用操作速查表&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;相关API&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;绘制颜色&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawColor, drawRGB, drawARGB&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用单一颜色填充整个画布&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绘制基本形状&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绘制图片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawBitmap, drawPicture&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;绘制位图和图片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绘制文本&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawText, drawPosText, drawTextOnPath&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绘制路径&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawPath&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;绘制路径，绘制贝塞尔曲线时也需要用到该函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;顶点操作&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawVertices, drawBitmapMesh&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;画布剪裁&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;clipPath, clipRect&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置画布的显示区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;画布快照&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;save, restore, saveLayerXxx, restoreToCount, getSaveCount&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;画布变换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;translate, scale, rotate, skew&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;依次为 位移、缩放、 旋转、错切&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Matrix(矩阵)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;getMatrix, setMatrix, concat&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;PS： Canvas常用方法在上面表格中已经全部列出了，当然还存在一些其他的方法未列出，具体可以参考官方文档 Canvas&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;三canvas详解&#34;&gt;三.Canvas详解&lt;/h1&gt;
&lt;p&gt;本篇内容主要讲解如何利用Canvas绘制基本图形。&lt;/p&gt;
&lt;p&gt;绘制颜色：&lt;/p&gt;
&lt;p&gt;绘制颜色是填充整个画布，常用于绘制底色。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;canvas.drawColor(Color.BLUE); //绘制蓝色
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2jw1f2742437w3j30u01hcjrq.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;关于颜色的更多资料请参考基础篇_颜色&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建画笔：&lt;/p&gt;
&lt;p&gt;要想绘制内容，首先需要先创建一个画笔，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1.创建一个画笔
private Paint mPaint = new Paint();

// 2.初始化画笔
private void initPaint() {
	mPaint.setColor(Color.BLACK);       //设置画笔颜色
	mPaint.setStyle(Paint.Style.FILL);  //设置画笔模式为填充
	mPaint.setStrokeWidth(10f);         //设置画笔宽度为10px
}

// 3.在构造函数中初始化
public SloopView(Context context, AttributeSet attrs) {
   super(context, attrs);
   initPaint();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在创建完画笔之后，就可以在Canvas中绘制各种内容了。&lt;/p&gt;
&lt;p&gt;绘制点：&lt;/p&gt;
&lt;p&gt;可以绘制一个点，也可以绘制一组点，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;canvas.drawPoint(200, 200, mPaint);     //在坐标(200,200)位置绘制一个点
canvas.drawPoints(new float[]{          //绘制一组点，坐标位置由float数组指定
      500,500,
      500,600,
      500,700
},mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于坐标原点默认在左上角，水平向右为x轴增大方向，竖直向下为y轴增大方向。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更多参考这里 基础篇_坐标系&lt;br&gt;
&lt;img src=&#34;http://ww1.sinaimg.cn/large/005Xtdi2jw1f2743rkifnj30u01hc74n.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;绘制直线：&lt;/p&gt;
&lt;p&gt;绘制直线需要两个点，初始点和结束点，同样绘制直线也可以绘制一条或者绘制一组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;canvas.drawLine(300,300,500,600,mPaint);    // 在坐标(300,300)(500,600)之间绘制一条直线
canvas.drawLines(new float[]{               // 绘制一组线 每四数字(两个点的坐标)确定一条线
    100,200,200,200,
    100,300,200,300
},mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2jw1f2745k83ybj30u01hcq3d.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;绘制矩形：&lt;/p&gt;
&lt;p&gt;确定确定一个矩形最少需要四个数据，就是对角线的两个点的坐标值，这里一般采用左上角和右下角的两个点的坐标。&lt;/p&gt;
&lt;p&gt;关于绘制矩形，Canvas提供了三种重载方法，第一种就是提供四个数值(矩形左上角和右下角两个点的坐标)来确定一个矩形进行绘制。 其余两种是先将矩形封装为Rect或RectF(实际上仍然是用两个坐标点来确定的矩形)，然后传递给Canvas绘制，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 第一种
canvas.drawRect(100,100,800,400,mPaint);

// 第二种
Rect rect = new Rect(100,100,800,400);
canvas.drawRect(rect,mPaint);

// 第三种
RectF rectF = new RectF(100,100,800,400);
canvas.drawRect(rectF,mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上三种方法所绘制出来的结果是完全一样的。&lt;br&gt;
&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2jw1f27478692dj30u01hc3yy.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
看到这里,相信很多观众会产生一个疑问，为什么会有Rect和RectF两种？两者有什么区别吗？&lt;/p&gt;
&lt;p&gt;答案当然是存在区别的，两者最大的区别就是精度不同，Rect是int(整形)的，而RectF是float(单精度浮点型)的。除了精度不同，两种提供的方法也稍微存在差别，在这里我们暂时无需关注，想了解更多参见官方文档 Rect 和 RectF&lt;/p&gt;
&lt;p&gt;绘制圆角矩形：&lt;/p&gt;
&lt;p&gt;绘制圆角矩形也提供了两种重载方式，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 第一种
RectF rectF = new RectF(100,100,800,400);
canvas.drawRoundRect(rectF,30,30,mPaint);

// 第二种
canvas.drawRoundRect(100,100,800,400,30,30,mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面两种方法绘制效果也是一样的，但鉴于第二种方法在API21的时候才添加上，所以我们一般使用的都是第一种。&lt;br&gt;
&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2jw1f2747s3c5zj30u01hcq3e.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面简单解析一下圆角矩形的几个必要的参数的意思。&lt;/p&gt;
&lt;p&gt;很明显可以看出，第二种方法前四个参数和第一种方法的RectF作用是一样的，都是为了确定一个矩形，最后一个参数Paint是画笔，无需多说，与矩形相比，圆角矩形多出来了两个参数rx 和 ry，这两个参数是干什么的呢？&lt;/p&gt;
&lt;p&gt;稍微分析一下，既然是圆角矩形，他的角肯定是圆弧(圆形的一部分)，我们一般用什么确定一个圆形呢？&lt;/p&gt;
&lt;p&gt;答案是圆心 和 半径，其中圆心用于确定位置，而半径用于确定大小。&lt;/p&gt;
&lt;p&gt;由于矩形位置已经确定，所以其边角位置也是确定的，那么确定位置的参数就可以省略，只需要用半径就能描述一个圆弧了。&lt;/p&gt;
&lt;p&gt;但是，半径只需要一个参数，但这里怎么会有两个呢？&lt;/p&gt;
&lt;p&gt;好吧，让你发现了，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图：&lt;br&gt;
&lt;img src=&#34;http://ww3.sinaimg.cn/large/005Xtdi2jw1f2748fjw2bj308c0dwmx8.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;红线标注的 rx 与 ry 就是两个半径，也就是相比绘制矩形多出来的那两个参数。&lt;/p&gt;
&lt;p&gt;我们了解到原理后，就可以为所欲为了，通过计算可知我们上次绘制的矩形宽度为700，高度为300，当你让 rx大于350(宽度的一半)， ry大于150(高度的一半) 时奇迹就出现了， 你会发现圆角矩形变成了一个椭圆， 他们画出来是这样的 ( 为了方便确认我更改了画笔颜色， 同时绘制出了矩形和圆角矩形 )：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 矩形
RectF rectF = new RectF(100,100,800,400);  

// 绘制背景矩形
mPaint.setColor(Color.GRAY);
canvas.drawRect(rectF,mPaint);

// 绘制圆角矩形
mPaint.setColor(Color.BLUE);
canvas.drawRoundRect(rectF,700,400,mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2jw1f2748ugy2pj30u01hcwf1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其中灰色部分是我们所选定的矩形，而里面的圆角矩形则变成了一个椭圆，实际上在rx为宽度的一半，ry为高度的一半时，刚好是一个椭圆，通过上面我们分析的原理推算一下就能得到，而当rx大于宽度的一半，ry大于高度的一半时，实际上是无法计算出圆弧的，所以drawRoundRect对大于该数值的参数进行了限制(修正)，凡是大于一半的参数均按照一半来处理。&lt;/p&gt;
&lt;p&gt;绘制椭圆：&lt;/p&gt;
&lt;p&gt;相对于绘制圆角矩形，绘制椭圆就简单的多了，因为他只需要一个矩形矩形作为参数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 第一种
RectF rectF = new RectF(100,100,800,400);
canvas.drawOval(rectF,mPaint);

// 第二种
canvas.drawOval(100,100,800,400,mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，以上两种方法效果完全一样，但一般使用第一种。&lt;br&gt;
&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2jw1f274afxbiyj30u01hczks.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
绘制椭圆实际上就是绘制一个矩形的内切图形，原理如下，就不多说了：&lt;br&gt;
&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2jw1f274bq1h4rj308c0dwjrl.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PS： 如果你传递进来的是一个长宽相等的矩形(即正方形)，那么绘制出来的实际上就是一个圆。&lt;/p&gt;
&lt;p&gt;绘制圆：&lt;/p&gt;
&lt;p&gt;绘制圆形也比较简单, 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;canvas.drawCircle(500,500,400,mPaint);  // 绘制一个圆心坐标在(500,500)，半径为400 的圆。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制圆形有四个参数，前两个是圆心坐标，第三个是半径，最后一个是画笔。&lt;br&gt;
&lt;img src=&#34;http://ww3.sinaimg.cn/large/005Xtdi2jw1f274c41kknj30u01hcdgf.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;绘制圆弧：&lt;br&gt;
绘制圆弧就比较神奇一点了，为了理解这个比较神奇的东西，我们先看一下它需要的几个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 第一种
public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint){}
    
// 第二种
public void drawArc(float left, float top, float right, float bottom, float startAngle,
            float sweepAngle, boolean useCenter, @NonNull Paint paint) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面可以看出，相比于绘制椭圆，绘制圆弧还多了三个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;startAngle  // 开始角度
sweepAngle  // 扫过角度
useCenter   // 是否使用中心
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过字面意思我们基本能猜测出来前两个参数(startAngle， sweepAngel)的作用，就是确定角度的起始位置和扫过角度， 不过第三个参数是干嘛的？试一下就知道了,上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RectF rectF = new RectF(100,100,800,400);
// 绘制背景矩形
mPaint.setColor(Color.GRAY);
canvas.drawRect(rectF,mPaint);

// 绘制圆弧
mPaint.setColor(Color.BLUE);
canvas.drawArc(rectF,0,90,false,mPaint);

//-------------------------------------

RectF rectF2 = new RectF(100,600,800,900);
// 绘制背景矩形
mPaint.setColor(Color.GRAY);
canvas.drawRect(rectF2,mPaint);

// 绘制圆弧
mPaint.setColor(Color.BLUE);
canvas.drawArc(rectF2,0,90,true,mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码实际上是绘制了一个起始角度为0度，扫过90度的圆弧，两者的区别就是是否使用了中心点，结果如下：&lt;br&gt;
&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2jw1f274d1smwej30u01hc3z4.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以发现使用了中心点之后绘制出来类似于一个扇形，而不使用中心点则是圆弧起始点和结束点之间的连线加上圆弧围成的图形。这样中心点这个参数的作用就很明显了，不必多说想必大家试一下就明白了。 另外可以关于角度可以参考一下这篇文章： 角度与弧度&lt;/p&gt;
&lt;p&gt;相比于使用椭圆，我们还是使用正圆比较多的，使用正圆展示一下效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RectF rectF = new RectF(100,100,600,600);
// 绘制背景矩形
mPaint.setColor(Color.GRAY);
canvas.drawRect(rectF,mPaint);

// 绘制圆弧
mPaint.setColor(Color.BLUE);
canvas.drawArc(rectF,0,90,false,mPaint);

//-------------------------------------

RectF rectF2 = new RectF(100,700,600,1200);
// 绘制背景矩形
mPaint.setColor(Color.GRAY);
canvas.drawRect(rectF2,mPaint);

// 绘制圆弧
mPaint.setColor(Color.BLUE);
canvas.drawArc(rectF2,0,90,true,mPaint);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2jw1f274e3surgj30u01hc3z4.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;简要介绍Paint&lt;/p&gt;
&lt;p&gt;看了上面这么多，相信有一部分人会产生一个疑问，如果我想绘制一个圆，只要边不要里面的颜色怎么办？&lt;/p&gt;
&lt;p&gt;很简单，绘制的基本形状由Canvas确定，但绘制出来的颜色,具体效果则由Paint确定。&lt;/p&gt;
&lt;p&gt;如果你注意到了的话，在一开始我们设置画笔样式的时候是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mPaint.setStyle(Paint.Style.FILL);  //设置画笔模式为填充
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了展示方便，容易看出效果，之前使用的模式一直为填充模式，实际上画笔有三种模式，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;STROKE                //描边
FILL                  //填充
FILL_AND_STROKE       //描边加填充
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了区分三者效果我们做如下实验：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Paint paint = new Paint();
paint.setColor(Color.BLUE);
paint.setStrokeWidth(40);     //为了实验效果明显，特地设置描边宽度非常大

// 描边
paint.setStyle(Paint.Style.STROKE);
canvas.drawCircle(200,200,100,paint);

// 填充
paint.setStyle(Paint.Style.FILL);
canvas.drawCircle(200,500,100,paint);

// 描边加填充
paint.setStyle(Paint.Style.FILL_AND_STROKE);
canvas.drawCircle(200, 800, 100, paint);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2jw1f274g6lxbpj30u01hcq3n.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一图胜千言，通过以上实验我们可以比较明显的看出三种模式的区别，如果只需要边缘不需要填充内容的话只需要设置模式为描边(STROKE)即可。&lt;/p&gt;
&lt;p&gt;其实关于Paint的内容也是有不少的，这些只是冰山一角，在后续内容中会详细的讲解Paint。&lt;/p&gt;
&lt;h1 id=&#34;小示例&#34;&gt;小示例&lt;/h1&gt;
&lt;p&gt;简要介绍画布的操作:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;画布操作详细内容会在下一篇文章中讲解, 不是本文重点，但以下示例中可能会用到，所以此处简要介绍一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;相关操作&lt;/th&gt;
&lt;th&gt;简要介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;save&lt;/td&gt;
&lt;td&gt;保存当前画布状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;restore&lt;/td&gt;
&lt;td&gt;回滚到上一次保存的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;translate&lt;/td&gt;
&lt;td&gt;相对于当前位置位移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rotate&lt;/td&gt;
&lt;td&gt;旋转&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;制作一个饼状图&lt;/p&gt;
&lt;p&gt;在展示百分比数据的时候经常会用到饼状图，像这样：&lt;br&gt;
&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2jw1f274gmnlk3j308c0dwglq.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;简单分析&lt;/p&gt;
&lt;p&gt;其实根据我们上面的知识已经能自己制作一个饼状图了。不过制作东西最重要的不是制作结果，而是制作思路。 相信我贴上代码大家一看就立刻明白了，非常简单的东西。不过嘛，咱们还是想了解一下制作思路：&lt;/p&gt;
&lt;p&gt;先分析饼状图的构成，非常明显，饼状图就是一个又一个的扇形构成的，每个扇形都有不同的颜色，对应的有名字，数据和百分比。&lt;/p&gt;
&lt;p&gt;经以上信息可以得出饼状图的最基本数据应包括：名字 数据值 百分比 对应的角度 颜色。&lt;/p&gt;
&lt;p&gt;用户关心的数据 ： 名字 数据值 百分比&lt;br&gt;
需要程序计算的数据： 百分比 对应的角度&lt;br&gt;
其中颜色这一项可以用户指定也可以用程序指定(我们这里采用程序指定)。&lt;/p&gt;
&lt;p&gt;封装数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PieData {
    // 用户关心数据
    private String name;        // 名字
    private float value;        // 数值
    private float percentage;   // 百分比
    
    // 非用户关心数据
    private int color = 0;      // 颜色
    private float angle = 0;    // 角度

    public PieData(@NonNull String name, @NonNull float value) {
        this.name = name;
        this.value = value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PS: 以上省略了get set方法&lt;/p&gt;
&lt;p&gt;自定义View：&lt;/p&gt;
&lt;p&gt;先按照自定义View流程梳理一遍(确定各个步骤应该做的事情)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;构造函数&lt;/td&gt;
&lt;td&gt;View初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;onMeasure&lt;/td&gt;
&lt;td&gt;测量View大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;onSizeChanged&lt;/td&gt;
&lt;td&gt;确定View大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;onLayout&lt;/td&gt;
&lt;td&gt;确定子View布局(自定义View包含子View时有用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;onDraw&lt;/td&gt;
&lt;td&gt;实际绘制内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;提供接口&lt;/td&gt;
&lt;td&gt;控制View或监听View某些状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PieView extends View {
    // 颜色表 (注意: 此处定义颜色使用的是ARGB，带Alpha通道的)
    private int[] mColors = {0xFFCCFF00, 0xFF6495ED, 0xFFE32636, 0xFF800000, 0xFF808000, 0xFFFF8C69, 0xFF808080,
            0xFFE6B800, 0xFF7CFC00};
    // 饼状图初始绘制角度
    private float mStartAngle = 0;
    // 数据
    private ArrayList&amp;lt;PieData&amp;gt; mData;
    // 宽高
    private int mWidth, mHeight;
    // 画笔
    private Paint mPaint = new Paint();

    public PieView(Context context) {
        this(context, null);
    }

    public PieView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint.setStyle(Paint.Style.FILL);
        mPaint.setAntiAlias(true);
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        mWidth = w;
        mHeight = h;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if (null == mData)
            return;
        float currentStartAngle = mStartAngle;                    // 当前起始角度
        canvas.translate(mWidth / 2, mHeight / 2);                // 将画布坐标原点移动到中心位置
        float r = (float) (Math.min(mWidth, mHeight) / 2 * 0.8);  // 饼状图半径
        RectF rect = new RectF(-r, -r, r, r);                     // 饼状图绘制区域

        for (int i = 0; i &amp;lt; mData.size(); i++) {
            PieData pie = mData.get(i);
            mPaint.setColor(pie.getColor());
            canvas.drawArc(rect, currentStartAngle, pie.getAngle(), true, mPaint);
            currentStartAngle += pie.getAngle();
        }

    }

    // 设置起始角度
    public void setStartAngle(int mStartAngle) {
        this.mStartAngle = mStartAngle;
        invalidate();   // 刷新
    }

    // 设置数据
    public void setData(ArrayList&amp;lt;PieData&amp;gt; mData) {
        this.mData = mData;
        initDate(mData);
        invalidate();   // 刷新
    }

    // 初始化数据
    private void initDate(ArrayList&amp;lt;PieData&amp;gt; mData) {
        if (null == mData || mData.size() == 0)   // 数据有问题 直接返回
            return;

        float sumValue = 0;
        for (int i = 0; i &amp;lt; mData.size(); i++) {
            PieData pie = mData.get(i);

            sumValue += pie.getValue();       //计算数值和

            int j = i % mColors.length;       //设置颜色
            pie.setColor(mColors[j]);
        }

        float sumAngle = 0;
        for (int i = 0; i &amp;lt; mData.size(); i++) {
            PieData pie = mData.get(i);

            float percentage = pie.getValue() / sumValue;   // 百分比
            float angle = percentage * 360;                 // 对应的角度

            pie.setPercentage(percentage);                  // 记录百分比
            pie.setAngle(angle);                            // 记录角度大小
            sumAngle += angle;

            Log.i(&amp;quot;angle&amp;quot;, &amp;quot;&amp;quot; + pie.getAngle());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PS: 在更改了数据需要重绘界面时要调用invalidate()这个函数重新绘制。&lt;/p&gt;
&lt;p&gt;效果图&lt;br&gt;
&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2jw1f274gz06voj30u01hc3za.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 这个饼状图并没有添加百分比等数据，仅作为示例使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：&lt;br&gt;
其实自定义View只要按照流程一步步的走，也是比较容易的。不过里面也有不少坑，这些坑还是自己踩过印象比较深，建议大家不要直接copy源码，自己手打体验一下。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/reference/android/view/View.html&#34;&gt;View&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/reference/android/graphics/Canvas.html&#34;&gt;Canvas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2012/1212/703.html&#34;&gt;Android Canvas绘图详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">安卓自定义View进阶-Canvas之绘制图形</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/an-zhuo-zi-ding-yi-view-ji-chu-yan-se/"" data-c="
          &lt;p&gt;简要介绍安卓中的颜色相关内容，包括颜色的定义，创建颜色的几种方式，以及颜色的混合模式等。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;一简单介绍颜色&#34;&gt;一.简单介绍颜色&lt;/h1&gt;
&lt;p&gt;安卓支持的颜色模式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;颜色模式&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ARGB8888&lt;/td&gt;
&lt;td&gt;四通道高精度(32位)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ARGB4444&lt;/td&gt;
&lt;td&gt;四通道低精度(16位)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RGB565&lt;/td&gt;
&lt;td&gt;屏幕默认模式(16位)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alpha8&lt;/td&gt;
&lt;td&gt;仅有透明通道(8位)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PS：其中字母表示通道类型，数值表示该类型用多少位二进制来描述。如ARGB8888则表示有四个通道(ARGB),每个对应的通道均用8位来描述。&lt;/p&gt;
&lt;p&gt;注意：我们常用的是ARGB8888和ARGB4444，而在所有的安卓设备屏幕上默认的模式都是RGB565,请留意这一点。&lt;/p&gt;
&lt;h3 id=&#34;以argb8888为例介绍颜色定义&#34;&gt;以ARGB8888为例介绍颜色定义:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;0(0x00)&lt;/th&gt;
&lt;th&gt;255(0xff)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A(Alpha)&lt;/td&gt;
&lt;td&gt;透明度&lt;/td&gt;
&lt;td&gt;透明&lt;/td&gt;
&lt;td&gt;不透明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R(Red)&lt;/td&gt;
&lt;td&gt;红色&lt;/td&gt;
&lt;td&gt;无色&lt;/td&gt;
&lt;td&gt;红色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G(Green)&lt;/td&gt;
&lt;td&gt;绿色&lt;/td&gt;
&lt;td&gt;无色&lt;/td&gt;
&lt;td&gt;绿色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B(Blue)&lt;/td&gt;
&lt;td&gt;蓝色&lt;/td&gt;
&lt;td&gt;无色&lt;/td&gt;
&lt;td&gt;蓝色&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中 A R G B 的取值范围均为0&lt;sub&gt;255(即16进制的0x00&lt;/sub&gt;0xff)&lt;/p&gt;
&lt;p&gt;A 从ox00到oxff表示从透明到不透明。&lt;/p&gt;
&lt;p&gt;RGB 从0x00到0xff表示颜色从浅到深。&lt;/p&gt;
&lt;p&gt;当RGB全取最小值(0或0x000000)时颜色为黑色，全取最大值(255或0xffffff)时颜色为白色&lt;/p&gt;
&lt;h1 id=&#34;二几种创建或使用颜色的方式&#34;&gt;二.几种创建或使用颜色的方式&lt;/h1&gt;
&lt;h3 id=&#34;1java中定义颜色&#34;&gt;1.java中定义颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int color = Color.GRAY;     //灰色
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于Color类提供的颜色仅为有限的几个，通常还是用ARGB值进行表示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int color = Color.argb(127, 255, 0, 0);   //半透明红色

int color = 0xaaff0000;                   //带有透明度的红色
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2在xml文件中定义颜色&#34;&gt;2.在xml文件中定义颜色&lt;/h3&gt;
&lt;p&gt;在/res/values/color.xml 文件中如下定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;resources&amp;gt;
    &amp;lt;color name=&amp;quot;red&amp;quot;&amp;gt;#ff0000&amp;lt;/color&amp;gt;
    &amp;lt;color name=&amp;quot;green&amp;quot;&amp;gt;#00ff00&amp;lt;/color&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详解： 在以上xml文件中定义了两个颜色，红色和蓝色，是没有alpha（透明）通道的。&lt;/p&gt;
&lt;p&gt;定义颜色以‘#’开头，后面跟十六进制的值，有如下几种定义方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;#f00            //低精度 - 不带透明通道红色
#af00           //低精度 - 带透明通道红色

#ff0000         //高精度 - 不带透明通道红色
#aaff0000       //高精度 - 带透明通道红色
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3在java文件中引用xml中定义的颜色&#34;&gt;3.在java文件中引用xml中定义的颜色：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int color = getResources().getColor(R.color.mycolor);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4在xml文件layout或style中引用或者创建颜色&#34;&gt;4.在xml文件(layout或style)中引用或者创建颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--在style文件中引用--&amp;gt;
&amp;lt;style name=&amp;quot;AppTheme&amp;quot; parent=&amp;quot;Theme.AppCompat.Light.DarkActionBar&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;colorPrimary&amp;quot;&amp;gt;@color/red&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;android:background=&amp;quot;@color/red&amp;quot;     //引用在/res/values/color.xml 中定义的颜色

android:background=&amp;quot;#ff0000&amp;quot;        //创建并使用颜色
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三取色工具&#34;&gt;三.取色工具&lt;/h1&gt;
&lt;p&gt;颜色都是用RGB值定义的，而我们一般是无法直观的知道自己需要颜色的值，需要借用取色工具直接从图片或者其他地方获取颜色的RGB值。&lt;/p&gt;
&lt;h3 id=&#34;1colorpixfor-win&#34;&gt;1.ColorPix(for Win)&lt;/h3&gt;
&lt;p&gt;简单的取色调色工具，可以从屏幕取色，非常小而精简。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.colorschemer.com/ColorPix.exe&#34; title=&#34;点击这里下载ColorPix&#34;&gt;http://www.colorschemer.com/ColorPix.exe&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2picpickfor-win&#34;&gt;2.Picpick(for Win)&lt;/h3&gt;
&lt;p&gt;功能更加强大的工具：PicPick。&lt;/p&gt;
&lt;p&gt;PicPick具备了截取全屏、活动窗口、指定区域、固定区域、手绘区域功能，支持滚动截屏，屏幕取色，支持双显示器，具备白板、屏幕标尺、直角座标或极座标显示与测量，具备强大的图像编辑和标注功能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://ngwin.com/picpick&#34;&gt;http://ngwin.com/picpick&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3sipfor-mac&#34;&gt;3.Sip(for Mac)&lt;/h3&gt;
&lt;p&gt;Sip作为Mac上的取色工具，也是十分优秀的，除了屏幕取色外还配备了不同类型的调色板，并且支持将颜色格式化为任何常用的格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/us/app/sip/id507257563?mt=12&#34;&gt;https://itunes.apple.com/us/app/sip/id507257563?mt=12&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;四颜色混合模式alpha通道相关&#34;&gt;四.颜色混合模式(Alpha通道相关)&lt;/h1&gt;
&lt;p&gt;过前面介绍我们知道颜色一般都是四个通道(ARGB)的，其中(RGB)控制的是颜色,而A(Alpha)控制的是透明度。&lt;/p&gt;
&lt;p&gt;因为我们的显示屏是没法透明的，因此最终显示在屏幕上的颜色里可以认为没有Alpha通道。Alpha通道主要在两个图像混合的时候生效。&lt;/p&gt;
&lt;p&gt;默认情况下，当一个颜色绘制到Canvas上时的混合模式是这样计算的：&lt;/p&gt;
&lt;p&gt;(RGB通道) 最终颜色 = 绘制的颜色 + (1 - 绘制颜色的透明度) × Canvas上的原有颜色。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1.这里我们一般把每个通道的取值从0(ox00)到255(0xff)映射到0到1的浮点数表示。&lt;/p&gt;
&lt;p&gt;2.这里等式右边的“绘制的颜色”、“Canvas上的原有颜色” 都是经过预乘了自己的Alpha通道的值。如绘制颜色：0x88ffffff，那么参与运算时的每个颜色通道的值不是1.0，而是(1.0 * 0.5333 = 0.5333)。 (其中0.5333 = 0x88/0xff)&lt;/p&gt;
&lt;p&gt;使用这种方式的混合，就会造成后绘制的内容以半透明的方式叠在上面的视觉效果。&lt;/p&gt;
&lt;p&gt;其实还可以有不同的混合模式供我们选择，用Paint.setXfermode，指定不同的PorterDuff.Mode。&lt;/p&gt;
&lt;p&gt;下表是各个PorterDuff模式的混合计算公式：（D指原本在Canvas上的内容dst，S指绘制输入的内容src，a指alpha通道，c指RGB各个通道）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;混合模式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;计算公式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ADD&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Saturate(S + D)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CLEAR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[0, 0]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DARKEN&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa + Da - SaDa, Sc(1 - Da) + Dc*(1 - Sa) + min(Sc, Dc)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Da, Dc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DST_ATOP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa, Sa * Dc + Sc * (1 - Da)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DST_IN&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa * Da, Sa * Dc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DST_OUT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Da * (1 - Sa), Dc * (1 - Sa)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DST_OVER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa + (1 - Sa)Da, Rc = Dc + (1 - Da)Sc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LIGHTEN&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa + Da - SaDa, Sc(1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MULTIPLY&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa * Da, Sc * Dc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCREEN&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa + Da - Sa * Da, Sc + Dc - Sc * Dc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa, Sc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRC_ATOP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Da, Sc * Da + (1 - Sa) * Dc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRC_IN&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa * Da, Sc * Da]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRC_OUT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa * (1 - Da), Sc * (1 - Da)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRC_OVER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa + (1 - Sa)Da, Rc = Sc + (1 - Sa)Dc]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XOR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[Sa + Da - 2 * Sa * Da, Sc * (1 - Da) + (1 - Sa) * Dc]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;用示例图来查看使用不同模式时的混合效果如下（src表示输入的图，dst表示原Canvas上的内容）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://ww4.sinaimg.cn/large/005Xtdi2gw1f1wa0f0mzjj30hh0fsjt8.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;五参考资料&#34;&gt;五.参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/zhucai/p/android-graphics-animation.html&#34;&gt;安卓图形动画&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
"> 安卓自定义View基础 - 颜色</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/an-zhuo-zi-ding-yi-view-ji-chu-jiao-du-hu-du/"" data-c="
          &lt;p&gt;安卓中角度(angle)与弧度(radian)的有关问题。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;一前言&#34;&gt;一.前言&lt;/h1&gt;
&lt;h3 id=&#34;1为什么讲这个&#34;&gt;1.为什么讲这个？&lt;/h3&gt;
&lt;p&gt;在我们自定义View，尤其是制作一些复杂炫酷的效果的时候，实际上是将一些简单的东西通过数学上精密的计算组合到一起形成的效果。&lt;/p&gt;
&lt;p&gt;这其中可能会涉及到画布的相关操作(旋转)，以及一些正余弦函数的计算等，这些内容就会用到一些角度、弧度相关的知识。&lt;/p&gt;
&lt;h3 id=&#34;2为什么对角的描述存在角度与弧度两种单位&#34;&gt;2.为什么对角的描述存在角度与弧度两种单位？&lt;/h3&gt;
&lt;p&gt;简单来说就是为了方便，为了精确描述一个角的大小引入了角度与弧度的概念。&lt;/p&gt;
&lt;p&gt;由于两者进制是不同的(角度是60进制，弧度是10进制),在合适的地方使用合适的单位来描述会更加方便。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如： 角度是60进位制，遇到30°6′这样的角，应该转化为10进制的30.1°。但弧度就不需要，因为弧度本身就是十进制的实数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;二角度与弧度的定义&#34;&gt;二.角度与弧度的定义&lt;/h1&gt;
&lt;p&gt;角度和弧度一样都是描述角的一种度量单位，下面是它们的定义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;角度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条射线从圆心向圆周射出，形成一个夹角和夹角正对的一段弧。当这段弧长正好等于圆周长的360分之一时，两条射线的夹角的大小为1度.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;弧度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条射线从圆心向圆周射出，形成一个夹角和夹角正对的一段弧。当这段弧长正好等于圆的半径时，两条射线的夹角大小为1弧度.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;如图&#34;&gt;如图:&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/005Xtdi2jw1f1s0f975hmj308c0dwmxh.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://ww3.sinaimg.cn/large/005Xtdi2jw1f1s0g3rcg2j308c0dw3yw.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;三角度和弧度的换算关系&#34;&gt;三.角度和弧度的换算关系&lt;/h1&gt;
&lt;p&gt;根据角度和弧度的的定义和圆的相关知识非常容易就能得出两者的换算公式：&lt;/p&gt;
&lt;p&gt;先设圆的周长为C. 半径为r&lt;/p&gt;
&lt;p&gt;C = 2πr;&lt;/p&gt;
&lt;p&gt;一周对应的角度为360度(角度)，对应的弧度为2π弧度。&lt;/p&gt;
&lt;p&gt;故: 180度 = π弧度.&lt;/p&gt;
&lt;p&gt;可得:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;公式&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;弧度 = 角度xπ/180&lt;/td&gt;
&lt;td&gt;2π ＝ 360 x π / 180&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;角度 = 弧度x180/π&lt;/td&gt;
&lt;td&gt;360 ＝ 2π x 180 / π&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;维基百科的公式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rad 是弧度， deg 是角度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/005Xtdi2jw1f4hui2jaecj305m03lwee.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;四一些细节问题&#34;&gt;四.一些细节问题&lt;/h1&gt;
&lt;p&gt;由于默认屏幕坐标系和常见数学坐标系的小差别(坐标系问题点这里)，所以在角上必然也会存在一些区别，例如：&lt;/p&gt;
&lt;p&gt;在常见的数学坐标系中角度增大方向为逆时针，&lt;/p&gt;
&lt;p&gt;在默认的屏幕坐标系中角度增大方向为顺时针。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/005Xtdi2jw1f1s2wnsewfj308c0dwt94.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">安卓自定义View基础 - 角度弧度</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/an-zhuo-zi-ding-yi-view-ji-chu-zuo-biao-xi/"" data-c="
          &lt;h1 id=&#34;一屏幕坐标系和数学坐标系的区别&#34;&gt;一.屏幕坐标系和数学坐标系的区别&lt;/h1&gt;
&lt;p&gt;由于移动设备一般定义屏幕左上角为坐标原点，向右为x轴增大方向，向下为y轴增大方向， 所以在手机屏幕上的坐标系与数学中常见的坐标系是稍微有点差别的，详情如下：&lt;/p&gt;
&lt;!--more--&gt;
&lt;blockquote&gt;
&lt;p&gt;（PS：其中的∠a 是对应的，注意y轴方向！）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2jw1f1qygzfvhoj308c0dwglr.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://ww1.sinaimg.cn/large/005Xtdi2jw1f1qyhbqvihj308c0dwjrh.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;实际屏幕上的默认坐标系如下&#34;&gt;实际屏幕上的默认坐标系如下：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 假设其中棕色部分为手机屏幕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/005Xtdi2jw1f1qyhjy7h8j308c0dwq32.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;二view的坐标系&#34;&gt;二.View的坐标系&lt;/h1&gt;
&lt;h3 id=&#34;注意view的坐标系统是相对于父控件而言的&#34;&gt;注意：View的坐标系统是相对于父控件而言的.&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getTop();       //获取子View左上角距父View顶部的距离
getLeft();      //获取子View左上角距父View左侧的距离
getBottom();    //获取子View右下角距父View顶部的距离
getRight();     //获取子View右下角距父View左侧的距离
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如下图所示&#34;&gt;如下图所示：&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/005Xtdi2gw1f1qzqwvkkbj308c0dwgm9.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;三motionevent中-get-和-getraw-的区别&#34;&gt;三.MotionEvent中 get 和 getRaw 的区别&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;event.getX();       //触摸点相对于其所在组件坐标系的坐标
event.getY();

event.getRawX();    //触摸点相对于屏幕默认坐标系的坐标
event.getRawY();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如下图所示-2&#34;&gt;如下图所示：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;PS:其中相同颜色的内容是对应的，其中为了显示方便，蓝色箭头向左稍微偏移了一点.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/005Xtdi2jw1f1r2bdlqhbj308c0dwwew.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;四核心要点&#34;&gt;四.核心要点&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;序号&lt;/th&gt;
&lt;th&gt;要点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;在数学中常见的坐标系与屏幕默认坐标系的差别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td&gt;View的坐标系是相对于父控件而言的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td&gt;MotionEvent中get和getRaw的区别&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;五参考文章&#34;&gt;五.参考文章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/wangjinyu501/article/details/21827341&#34; title=&#34;Android 屏幕（View）坐标系统&#34;&gt;Android 屏幕（View）坐标系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转自 : &lt;a href=&#34;http://www.gcssloop.com/customview/CoordinateSystem/&#34;&gt;http://www.gcssloop.com/customview/CoordinateSystem/&lt;/a&gt;&lt;/p&gt;
">安卓自定义View基础 - 坐标系</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/gei-chu-xue-zhe-de-rxjava20-jiao-cheng-er/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;上一节教程讲解了最基本的RxJava2的使用, 在本节中, 我们将学习RxJava强大的线程控制.&lt;/p&gt;
&lt;h3 id=&#34;正题&#34;&gt;正题&lt;/h3&gt;
&lt;p&gt;还是以之前的例子, 两根水管:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119182526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;正常情况下, 上游和下游是工作在同一个线程中的, 也就是说上游在哪个线程发事件, 下游就在哪个线程接收事件.&lt;/p&gt;
&lt;p&gt;怎么去理解呢, 以Android为例, 一个Activity的所有动作默认都是在主线程中运行的, 比如我们在onCreate中打出当前线程的名字:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Log.d(TAG, Thread.currentThread().getName());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果便是:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    D/TAG: main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回到RxJava中, 当我们在主线程中去创建一个上游Observable来发送事件, 则这个上游默认就在主线程发送事件.&lt;/p&gt;
&lt;p&gt;当我们在主线程去创建一个下游Observer来接收事件, 则这个下游默认就在主线程中接收事件, 来看段代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Override                                                                                      
    protected void onCreate(Bundle savedInstanceState) {                                            
        super.onCreate(savedInstanceState);                                                         
        setContentView(R.layout.activity_main);                                                     
                                                                              
        Observable&amp;lt;Integer&amp;gt; observable = Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() {   
            @Override                                                                               
            public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception {            
                Log.d(TAG, &amp;quot;Observable thread is : &amp;quot; + Thread.currentThread().getName());           
                Log.d(TAG, &amp;quot;emit 1&amp;quot;);                                                               
                emitter.onNext(1);                                                                  
            }                                                                                       
        });                                                                                         
                                                                                                    
        Consumer&amp;lt;Integer&amp;gt; consumer = new Consumer&amp;lt;Integer&amp;gt;() {                                      
            @Override                                                                               
            public void accept(Integer integer) throws Exception {                                  
                Log.d(TAG, &amp;quot;Observer thread is :&amp;quot; + Thread.currentThread().getName());              
                Log.d(TAG, &amp;quot;onNext: &amp;quot; + integer);                                                   
            }                                                                                       
        };                                                                                          
                                                                                                    
        observable.subscribe(consumer);                                                             
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在主线程中分别创建上游和下游, 然后将他们连接在一起, 同时分别打印出它们所在的线程, 运行结果为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;D/TAG: Observable thread is : main
D/TAG: emit 1                     
D/TAG: Observer thread is :main   
D/TAG: onNext: 1            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就验证了刚才所说, 上下游默认是在同一个线程工作.&lt;/p&gt;
&lt;p&gt;这样肯定是满足不了我们的需求的, 我们更多想要的是这么一种情况, 在子线程中做耗时的操作, 然后回到主线程中来操作UI, 用图片来描述就是下面这个图片:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119183654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在这个图中, 我们用黄色水管表示子线程, 深蓝色水管表示主线程.&lt;/p&gt;
&lt;p&gt;要达到这个目的, 我们需要先改变上游发送事件的线程, 让它去子线程中发送事件, 然后再改变下游的线程, 让它去主线程接收事件. 通过RxJava内置的线程调度器可以很轻松的做到这一点. 接下来看一段代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override                                                                                       
protected void onCreate(Bundle savedInstanceState) {                                            
    super.onCreate(savedInstanceState);                                                         
    setContentView(R.layout.activity_main);                                                     
                                                                                                
    Observable&amp;lt;Integer&amp;gt; observable = Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() {   
        @Override                                                                               
        public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception {            
            Log.d(TAG, &amp;quot;Observable thread is : &amp;quot; + Thread.currentThread().getName());           
            Log.d(TAG, &amp;quot;emit 1&amp;quot;);                                                               
            emitter.onNext(1);                                                                  
        }                                                                                       
    });                                                                                         
                                                                                                
    Consumer&amp;lt;Integer&amp;gt; consumer = new Consumer&amp;lt;Integer&amp;gt;() {                                      
        @Override                                                                               
        public void accept(Integer integer) throws Exception {                                  
            Log.d(TAG, &amp;quot;Observer thread is :&amp;quot; + Thread.currentThread().getName());              
            Log.d(TAG, &amp;quot;onNext: &amp;quot; + integer);                                                   
        }                                                                                       
    };                                                                                          
                                                                                                
    observable.subscribeOn(Schedulers.newThread())                                              
            .observeOn(AndroidSchedulers.mainThread())                                          
            .subscribe(consumer);                                                               
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是刚才的例子, 只不过我们太添加了一点东西, 先来看看运行结果:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;D/TAG: Observable thread is : RxNewThreadScheduler-2  
D/TAG: emit 1                                         
D/TAG: Observer thread is :main                       
D/TAG: onNext: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到, 上游发送事件的线程的确改变了, 是在一个叫  RxNewThreadScheduler-2的线程中发送的事件, 而下游仍然在主线程中接收事件, 这说明我们的目的达成了, 接下来看看是如何做到的.&lt;/p&gt;
&lt;p&gt;和上一段代码相比,这段代码只不过是增加了两行代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;.subscribeOn(Schedulers.newThread())                                              
.observeOn(AndroidSchedulers.mainThread())   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作为一个初学者的入门教程, 并不会贴出一大堆源码来分析, 因此只需要让大家记住几个要点, 已达到如何正确的去使用这个目的才是我们的目标.&lt;/p&gt;
&lt;p&gt;简单的来说, subscribeOn() 指定的是上游发送事件的线程, observeOn() 指定的是下游接收事件的线程.&lt;/p&gt;
&lt;p&gt;多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有第一次的有效, 其余的会被忽略.&lt;/p&gt;
&lt;p&gt;多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次.&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;observable.subscribeOn(Schedulers.newThread())     
         .subscribeOn(Schedulers.io())              
         .observeOn(AndroidSchedulers.mainThread()) 
         .observeOn(Schedulers.io())                
         .subscribe(consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码中指定了两次上游发送事件的线程, 分别是newThread和IO线程, 下游也指定了两次线程,分别是main和IO线程. 运行结果为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;D/TAG: Observable thread is : RxNewThreadScheduler-3
D/TAG: emit 1                                       
D/TAG: Observer thread is :RxCachedThreadScheduler-1
D/TAG: onNext: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到, 上游虽然指定了两次线程, 但只有第一次指定的有效, 依然是在RxNewThreadScheduler 线程中, 而下游则跑到了RxCachedThreadScheduler 中, 这个CacheThread其实就是IO线程池中的一个.&lt;/p&gt;
&lt;p&gt;为了更清晰的看到下游的线程切换过程, 我们加点log:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;observable.subscribeOn(Schedulers.newThread())
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnNext(new Consumer&amp;lt;Integer&amp;gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {
                        Log.d(TAG, &amp;quot;After observeOn(mainThread), current thread is: &amp;quot; + Thread.currentThread().getName());
                    }
                })
                .observeOn(Schedulers.io())
                .doOnNext(new Consumer&amp;lt;Integer&amp;gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {
                        Log.d(TAG, &amp;quot;After observeOn(io), current thread is : &amp;quot; + Thread.currentThread().getName());
                    }
                })
                .subscribe(consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在下游线程切换之后, 把当前的线程打印出来, 运行结果:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;D/TAG: Observable thread is : RxNewThreadScheduler-1                                             
D/TAG: emit 1                                                                                    
D/TAG: After observeOn(mainThread), current thread is: main                                      
D/TAG: After observeOn(io), current thread is : RxCachedThreadScheduler-2                        
D/TAG: Observer thread is :RxCachedThreadScheduler-2                                             
D/TAG: onNext: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到, 每调用一次observeOn() 线程便会切换一次, 因此如果我们有类似的需求时, 便可知道如何处理了.&lt;/p&gt;
&lt;p&gt;在RxJava中, 已经内置了很多线程选项供我们选择, 例如有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作&lt;/li&gt;
&lt;li&gt;Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作&lt;/li&gt;
&lt;li&gt;Schedulers.newThread() 代表一个常规的新线程&lt;/li&gt;
&lt;li&gt;AndroidSchedulers.mainThread() 代表Android的主线程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些内置的Scheduler已经足够满足我们开发的需求, 因此我们应该使用内置的这些选项, 在RxJava内部使用的是线程池来维护这些线程, 所有效率也比较高.&lt;/p&gt;
&lt;h3 id=&#34;实践&#34;&gt;实践&lt;/h3&gt;
&lt;p&gt;对于我们Android开发人员来说, 经常会将一些耗时的操作放在后台, 比如网络请求或者读写文件,操作数据库等等,等到操作完成之后回到主线程去更新UI, 有了上面的这些基础, 那么现在我们就可以轻松的去做到这样一些操作.&lt;/p&gt;
&lt;p&gt;下面来举几个常用的场景.&lt;/p&gt;
&lt;h4 id=&#34;网络请求&#34;&gt;网络请求&lt;/h4&gt;
&lt;p&gt;Android中有名的网络请求库就那么几个, Retrofit能够从中脱颖而出很大原因就是因为它支持RxJava的方式来调用, 下面简单讲解一下它的基本用法.&lt;/p&gt;
&lt;p&gt;要使用Retrofit,先添加Gradle配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    //retrofit
    compile &#39;com.squareup.retrofit2:retrofit:2.1.0&#39;
    //Gson converter
    compile &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39;
    //RxJava2 Adapter
    compile &#39;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&#39;
    //okhttp
    compile &#39;com.squareup.okhttp3:okhttp:3.4.1&#39;
    compile &#39;com.squareup.okhttp3:logging-interceptor:3.4.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;随后定义Api接口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Api {
    @GET
    Observable&amp;lt;LoginResponse&amp;gt; login(@Body LoginRequest request);

    @GET
    Observable&amp;lt;RegisterResponse&amp;gt; register(@Body RegisterRequest request);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着创建一个Retrofit客户端:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static Retrofit create() {
            OkHttpClient.Builder builder = new OkHttpClient().newBuilder();
            builder.readTimeout(10, TimeUnit.SECONDS);
            builder.connectTimeout(9, TimeUnit.SECONDS);

            if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
                interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
                builder.addInterceptor(interceptor);
            }

            return new Retrofit.Builder().baseUrl(ENDPOINT)
                    .client(builder.build())
                    .addConverterFactory(GsonConverterFactory.create())
                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                    .build();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发起请求就很简单了:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Api api = retrofit.create(Api.class);
        api.login(request)
             .subscribeOn(Schedulers.io())               //在IO线程进行网络请求
             .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求结果
            .subscribe(new Observer&amp;lt;LoginResponse&amp;gt;() {
                @Override
                public void onSubscribe(Disposable d) {}

                @Override
                public void onNext(LoginResponse value) {}

                @Override
                public void onError(Throwable e) {
                    Toast.makeText(mContext, &amp;quot;登录失败&amp;quot;, Toast.LENGTH_SHORT).show();
                }

                @Override
                public void onComplete() {
                    Toast.makeText(mContext, &amp;quot;登录成功&amp;quot;, Toast.LENGTH_SHORT).show();
                }
            });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看似很完美, 但我们忽略了一点, 如果在请求的过程中Activity已经退出了, 这个时候如果回到主线程去更新UI, 那么APP肯定就崩溃了, 怎么办呢, 上一节我们说到了Disposable , 说它是个开关, 调用它的dispose()方法时就会切断水管, 使得下游收不到事件, 既然收不到事件, 那么也就不会再去更新UI了. 因此我们可以在Activity中将这个Disposable 保存起来, 当Activity退出时, 切断它即可.&lt;/p&gt;
&lt;p&gt;那如果有多个Disposable 该怎么办呢, RxJava中已经内置了一个容器CompositeDisposable, 每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可切断所有的水管.&lt;/p&gt;
&lt;h4 id=&#34;读写数据库&#34;&gt;读写数据库&lt;/h4&gt;
&lt;p&gt;上面说了网络请求的例子, 接下来再看看读写数据库, 读写数据库也算一个耗时的操作, 因此我们也最好放在IO线程里去进行, 这个例子就比较简单, 直接上代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Observable&amp;lt;List&amp;lt;Record&amp;gt;&amp;gt; readAllRecords() {
        return Observable.create(new ObservableOnSubscribe&amp;lt;List&amp;lt;Record&amp;gt;&amp;gt;() {
            @Override
            public void subscribe(ObservableEmitter&amp;lt;List&amp;lt;Record&amp;gt;&amp;gt; emitter) throws Exception {
                Cursor cursor = null;
                try {
                    cursor = getReadableDatabase().rawQuery(&amp;quot;select * from &amp;quot; + TABLE_NAME, new String[]{});
                    List&amp;lt;Record&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
                    while (cursor.moveToNext()) {
                        result.add(Db.Record.read(cursor));
                    }
                    emitter.onNext(result);
                    emitter.onComplete();
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
    }
&lt;/code&gt;&lt;/pre&gt;
">给初学者的RxJava2.0教程(二)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/gei-chu-xue-zhe-de-rxjava20-jiao-cheng-yi/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;上个月RxJava2正式版发布了，但目前国内的资料还比较少，以前使用过RxJava1只需要看看更新文档就知道怎么使用了，但还有一些以前没用过RxJava的朋友可能就不知道怎么办了，不知道该看RxJava1还是直接跳到RxJava2。所以写下这个教程， 帮助那些没有用过RxJava的朋友入门。&lt;/p&gt;
&lt;p&gt;我先回答这个问题：学习RxJava2需要先学习RxJava1吗？&lt;/p&gt;
&lt;p&gt;这个问题就像论坛经常问学Java前需要先学习C语言吗，这里就不引战了！（PHP是世界上最好的语言！！）&lt;/p&gt;
&lt;p&gt;答案明显不是，如果你以前学过RxJava1，那么对于RxJava2只需要看看更新了哪些东西就行了，其最核心的思想并没有变化，如果你没学过RxJava1，没有关系，直接学习RxJava2。所以作为一个RxJava2的教程，本文中所有的名词都属于RxJava2中，并不涉及RxJava1。&lt;/p&gt;
&lt;p&gt;要在Android中使用RxJava2, 先添加Gradle配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    compile &#39;io.reactivex.rxjava2:rxjava:2.0.1&#39;
    compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;正题&#34;&gt;正题&lt;/h3&gt;
&lt;p&gt;在开始学习之前，先来介绍点原理性的东西。&lt;/p&gt;
&lt;p&gt;网上也有很多介绍RxJava原理的文章，通常这些文章都从观察者模式开始，先讲观察者，被观察者，订阅关系巴拉巴拉一大堆，说实话，当我第一次看到这些文章的时候已经被这些名词给绕晕了，用了很长的时间才理清楚它们之间的关系。可能是我太蠢了，境界不够，领会不到那么多高大上的名词.&lt;/p&gt;
&lt;p&gt;今天我用两根水管代替观察者和被观察者, 试图用通俗易懂的话把它们的关系解释清楚, 在这里我将从事件流这个角度来说明RxJava的基本工作原理。&lt;/p&gt;
&lt;p&gt;先假设有两根水管：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面一根水管为事件产生的水管，叫它上游吧，下面一根水管为事件接收的水管叫它下游吧。&lt;/p&gt;
&lt;p&gt;两根水管通过一定的方式连接起来，使得上游每产生一个事件，下游就能收到该事件。注意这里和官网的事件图是反过来的, 这里的事件发送的顺序是先1,后2,后3这样的顺序, 事件接收的顺序也是先1,后2,后3的顺序, 我觉得这样更符合我们普通人的思维, 简单明了.&lt;/p&gt;
&lt;p&gt;这里的上游和下游就分别对应着RxJava中的Observable和Observer，它们之间的连接就对应着subscribe()，因此这个关系用RxJava来表示就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        //创建一个上游 Observable：
        Observable&amp;lt;Integer&amp;gt; observable = Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() {
            @Override
            public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onComplete();
            }
        });
        //创建一个下游 Observer
        Observer&amp;lt;Integer&amp;gt; observer = new Observer&amp;lt;Integer&amp;gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &amp;quot;subscribe&amp;quot;);
            }

            @Override
            public void onNext(Integer value) {
                Log.d(TAG, &amp;quot;&amp;quot; + value);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &amp;quot;error&amp;quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &amp;quot;complete&amp;quot;);
            }
        };
        //建立连接
        observable.subscribe(observer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个运行的结果就是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;12-02 03:37:17.818 4166-4166/zlc.season.rxjava2demo D/TAG: subscribe
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 1
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 2
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: 3
12-02 03:37:17.819 4166-4166/zlc.season.rxjava2demo D/TAG: complete
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;注意: 只有当上游和下游建立连接之后, 上游才会开始发送事件. 也就是调用了subscribe() 方法之后才开始发送事件.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把这段代码连起来写就成了RxJava引以为傲的链式操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() {
            @Override
            public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onComplete();
            }
        }).subscribe(new Observer&amp;lt;Integer&amp;gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &amp;quot;subscribe&amp;quot;);
            }

            @Override
            public void onNext(Integer value) {
                Log.d(TAG, &amp;quot;&amp;quot; + value);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &amp;quot;error&amp;quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &amp;quot;complete&amp;quot;);
            }
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来解释一下其中两个陌生的玩意：ObservableEmitter和Disposable.&lt;/p&gt;
&lt;p&gt;ObservableEmitter： Emitter是发射器的意思，那就很好猜了，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。&lt;/p&gt;
&lt;p&gt;但是，请注意，并不意味着你可以随意乱七八糟发射事件，需要满足一定的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上游可以发送无限个onNext, 下游也可以接收无限个onNext.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送-, 而下游收到onComplete事件之后将不再继续接收事件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上游可以不发送onComplete或onError.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然&lt;/p&gt;
&lt;p&gt;注: 关于onComplete和onError唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, **并不一定会导致程序崩溃. ** 比如发送多个onComplete是可以正常运行的, 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError, 则收到第二个onError事件会导致程序会崩溃.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上几个规则用示意图表示如下:&lt;/p&gt;
&lt;p&gt;只发送onNext事件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发送onComplete事件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184606.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发送onError事件&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20200119184623.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;介绍了ObservableEmitter, 接下来介绍Disposable, 这个单词的字面意思是一次性用品,用完即可丢弃的. 那么在RxJava中怎么去理解它呢, 对应于上面的水管的例子, 我们可以把它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来看个例子, 我们让上游依次发送1,2,3,complete,4,在下游收到第二个事件之后, 切断水管, 看看运行结果:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() {
            @Override
            public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception {
                Log.d(TAG, &amp;quot;emit 1&amp;quot;);
                emitter.onNext(1);
                Log.d(TAG, &amp;quot;emit 2&amp;quot;);
                emitter.onNext(2);
                Log.d(TAG, &amp;quot;emit 3&amp;quot;);
                emitter.onNext(3);
                Log.d(TAG, &amp;quot;emit complete&amp;quot;);
                emitter.onComplete();
                Log.d(TAG, &amp;quot;emit 4&amp;quot;);
                emitter.onNext(4);
            }
        }).subscribe(new Observer&amp;lt;Integer&amp;gt;() {
            private Disposable mDisposable;
            private int i;

            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &amp;quot;subscribe&amp;quot;);
                mDisposable = d;
            }

            @Override
            public void onNext(Integer value) {
                Log.d(TAG, &amp;quot;onNext: &amp;quot; + value);
                i++;
                if (i == 2) {
                    Log.d(TAG, &amp;quot;dispose&amp;quot;);
                    mDisposable.dispose();
                    Log.d(TAG, &amp;quot;isDisposed : &amp;quot; + mDisposable.isDisposed());
                }
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &amp;quot;error&amp;quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &amp;quot;complete&amp;quot;);
            }
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: subscribe
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 1
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: onNext: 1
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 2
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: onNext: 2
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: dispose
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: isDisposed : true
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 3
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit complete
12-02 06:54:07.728 7404-7404/zlc.season.rxjava2demo D/TAG: emit 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从运行结果我们看到, 在收到onNext 2这个事件后, 切断了水管, 但是上游仍然发送了3, complete, 4这几个事件, 而且上游并没有因为发送了onComplete而停止. 同时可以看到下游的onSubscribe()方法是最先调用的.&lt;/p&gt;
&lt;p&gt;Disposable的用处不止这些, 后面讲解到了线程的调度之后, 我们会发现它的重要性. 随着后续深入的讲解, 我们会在更多的地方发现它的身影.&lt;/p&gt;
&lt;p&gt;另外, subscribe()有多个重载的方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public final Disposable subscribe() {}
    public final Disposable subscribe(Consumer&amp;lt;? super T&amp;gt; onNext) {}
    public final Disposable subscribe(Consumer&amp;lt;? super T&amp;gt; onNext, Consumer&amp;lt;? super Throwable&amp;gt; onError) {} 
    public final Disposable subscribe(Consumer&amp;lt;? super T&amp;gt; onNext, Consumer&amp;lt;? super Throwable&amp;gt; onError, Action onComplete) {}
    public final Disposable subscribe(Consumer&amp;lt;? super T&amp;gt; onNext, Consumer&amp;lt;? super Throwable&amp;gt; onError, Action onComplete, Consumer&amp;lt;? super Disposable&amp;gt; onSubscribe) {}
    public final void subscribe(Observer&amp;lt;? super T&amp;gt; observer) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一个带有Observer参数的我们已经使用过了,这里对其他几个方法进行说明.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带任何参数的subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 老子可不管你发什么.&lt;/li&gt;
&lt;li&gt;带有一个Consumer参数的方法表示下游只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() {
            @Override
            public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception {
                Log.d(TAG, &amp;quot;emit 1&amp;quot;);
                emitter.onNext(1);
                Log.d(TAG, &amp;quot;emit 2&amp;quot;);
                emitter.onNext(2);
                Log.d(TAG, &amp;quot;emit 3&amp;quot;);
                emitter.onNext(3);
                Log.d(TAG, &amp;quot;emit complete&amp;quot;);
                emitter.onComplete();
                Log.d(TAG, &amp;quot;emit 4&amp;quot;);
                emitter.onNext(4);
            }
        }).subscribe(new Consumer&amp;lt;Integer&amp;gt;() {
            @Override
            public void accept(Integer integer) throws Exception {
                Log.d(TAG, &amp;quot;onNext: &amp;quot; + integer);
            }
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;其他几个方法同理, 这里就不一一解释了.&lt;/li&gt;
&lt;/ul&gt;
">给初学者的RxJava2.0教程(一)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/you-hua-gridea-wang-zhan-jia-zai-su-du/"" data-c="
          &lt;p&gt;我觉得一开始的加载速度实在是太慢了，一直在转圈圈。&lt;br&gt;
打开网站，按F12，查看network选项卡，锁定了几个js脚本比较缓慢，一个sidebar图片比较缓慢。&lt;br&gt;
so,开始替换。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1替换jscss&#34;&gt;1.替换js,css&lt;/h2&gt;
&lt;p&gt;搜索找到最快的js CDN托管。&lt;a href=&#34;https://cdnjs.com/&#34;&gt;cdnjs地址&lt;/a&gt;&lt;br&gt;
找到Gridea的theme文件夹，我使用的SIMPLE，主要修改以下几处&lt;br&gt;
your\path\Gridea\themes\simple\templates_blocks\head.ejs&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ejs&#34;&gt;\\替换gittalk
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.5.0/gitalk.min.css&amp;quot; /&amp;gt;
\\替换vue，highlight，aos
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;your\path\Gridea\themes\simple\templates_blocks\scripts.ejs&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ejs&#34;&gt;\\替换aos
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
\\替换gittalk
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.5.0/gitalk.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实我这边没有开评论，也就无所谓了，如果你开了评论系统的话，最好还是替换以下&lt;/p&gt;
&lt;p&gt;##2.替换sidebar图片&lt;br&gt;
从加载上来看，sidebar图片过大，我这边使用了tinypng进行了压缩处理&lt;a href=&#34;https://tinypng.com/&#34;&gt;tinypng地址&lt;/a&gt;。从800K减小到了200K,能小一点是一点。其实最好换成纯色背景，这样会更快。&lt;/p&gt;
">优化Gridea网站加载速度</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/kai-shi-jian-zhi-ji-hua/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;我计划分以下几步&lt;/p&gt;
&lt;p&gt;一、社群&lt;/p&gt;
&lt;p&gt;1.创建QQ群：京东优惠券购物群&lt;br&gt;
2.创建微信群：京东优惠券购物群&lt;br&gt;
3.创建公众号：京东优惠券购物&lt;/p&gt;
&lt;p&gt;二、小程序&lt;/p&gt;
&lt;p&gt;求生之路图鉴，接入广告&lt;/p&gt;
&lt;p&gt;三、app&lt;/p&gt;
&lt;p&gt;mp3铃声剪辑，接入广告&lt;/p&gt;
">兼职计划</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/v2ray-websocket-shi-xian-wai-wang-fang-wen/"" data-c="
          &lt;p&gt;使用 V2Ray 的 WebSocket 传输协议 + Cloudflare 可以访问无法ping通的ip.简单说就是使用 V2Ray 的 WebSocket + TLS 传输协议，使用Cloudflare 中转。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;准备工作&#34;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;去&lt;a href=&#34;https://my.freenom.com&#34;&gt;freenom&lt;/a&gt;注册一个免费域名.&lt;/p&gt;
&lt;p&gt;去&lt;a href=&#34;https://dash.cloudflare.com&#34;&gt;cloudflare&lt;/a&gt;注册一个账户&lt;/p&gt;
&lt;h3 id=&#34;开始工作&#34;&gt;开始工作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先去cloudflare的DNS配置页配置如下&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607101504.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;加密选项配置如下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607101620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;去免费域名处,将第一步的DNS解析填入&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607101750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190607104552.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3.完成以后,就可以去你的IDC服务商后台,使用webshell安装V2ray.配置成websocket+ssl模式.域名填写为准备工作的免费域名.自己搞太麻烦了,我这边用的是一键脚本.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bash &amp;lt;(curl -s -L https://233v2.com/v2ray.sh)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一步会自动配置v2ray参数,并生成ssl证书,如果自己搞的话,还需要在nginx里面配置,自己创建证书.(当然也可以用cloudflare的,免费15年,一劳永逸)&lt;/p&gt;
&lt;p&gt;4.再到cloudflare网站去,将dns选项中的灰色云朵,点黄即可.状态为DNS and HTTP proxy(CDN)&lt;/p&gt;
&lt;h3 id=&#34;备注&#34;&gt;备注&lt;/h3&gt;
&lt;p&gt;无限域名模式.万一上面的操作完成以后,还是有问题.可以在cloudflare使用如下配置.&lt;/p&gt;
&lt;p&gt;WebSocket 协议，80 端口，Cloudflare 的 Crypto 选项卡 SSL 为 Flexible&lt;/p&gt;
">V2Ray WebSocket实现外网访问</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-aira2-he-webui/"" data-c="
          &lt;p&gt;新买的服务器安装下载服务器&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h3 id=&#34;基础软件的安装&#34;&gt;基础软件的安装&lt;/h3&gt;
&lt;p&gt;在下载Aria2之前先安装一些基础必备的软件：git、screen、nodejs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt-get install git screen nodejs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有些软件已经安装过了就不用再安装&lt;/p&gt;
&lt;h3 id=&#34;在命令行中安装aria2&#34;&gt;在命令行中安装aria2&lt;/h3&gt;
&lt;p&gt;在Ubuntu 18.04操作系统命令行中运行以下命令：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt-get install aria2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是安装aria2后的一些基本常识：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mkdir /etc/aria2　#新建文件夹 

sudo touch /etc/aria2/aria2.session　#新建session文件

sudo chmod 777 /etc/aria2/aria2.session　#设置aria2.session可写 

sudo vi /etc/aria2/aria2.conf　#创建配置文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;aria2conf文件配置&#34;&gt;aria2.conf文件配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;dir=/home/ye/download

disable-ipv6=true

#打开rpc的目的是为了给web管理端用

enable-rpc=true

rpc-allow-origin-all=true

rpc-listen-all=true

#rpc-listen-port=6800

#断点续传

continue=true

input-file=/etc/aria2/aria2.session

save-session=/etc/aria2/aria2.session

#最大同时下载任务数

max-concurrent-downloads=20

save-session-interval=120

# Http/FTP 相关

connect-timeout=120

#lowest-speed-limit=10K

#同服务器连接数

max-connection-per-server=10

#max-file-not-found=2

#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要

min-split-size=10M

#单文件最大线程数, 路由建议值: 5

split=10

check-certificate=false

#http-no-cache=true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;下载aria2webui&#34;&gt;下载Aria2WebUI&lt;/h3&gt;
&lt;p&gt;首先切换到用户目录下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cd /home/ye&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样也是一行命令：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone https://github.com/ziahamza/webui-aria2.git&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载完之后会在当前目录下创建一个webui-aria2目录。&lt;/p&gt;
&lt;h3 id=&#34;设置aria2监听rpc启动webui&#34;&gt;设置Aria2监听rpc，启动WebUI&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;screen -S aria2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建一个名为aria2的会话&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意那个S是大写！S是大写！S是大写！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在新的会话中输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-undefined&#34;&gt;aria2c --conf-path=/etc/aria2/aria2.conf --enable-rpc --rpc-listen-all --rpc-secret xxxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：参数–rpc-secret 后面的字符串是自己自定义的token密码，要记住！要记住！要记住！&lt;/p&gt;
&lt;p&gt;执行后会显示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-undefined&#34;&gt;root@ubuntu:~# aria2c --conf-path=/etc/aria2/aria2.conf --enable-rpc --rpc-listen-all --rpc-secret xxxxxxx

08/01 15:42:28 [NOTICE] IPv4 RPC: listening on TCP port 6800

08/01 15:42:28 [NOTICE] IPv6 RPC: listening on TCP port 6800root@ubuntu:~# aria2c --enable-rpc --rpc-listen-all --rpc-secret asdfghjkl

08/01 15:42:28 [NOTICE] IPv4 RPC: listening on TCP port 6800

08/01 15:42:28 [NOTICE] IPv6 RPC: listening on TCP port 6800
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;记住port后面的端口号“6800”&lt;/p&gt;
&lt;p&gt;然后依次按下键盘的ctrl、A、D 这三个键，回到前一个会话，输入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-undefined&#34;&gt;screen -S webui
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一个名为webui的会话&lt;/p&gt;
&lt;p&gt;在新的会话中，先跳转到上面说的webui-aria2目录中，再输入启动命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /home/ye/webui-aria2
node node-server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-undefined&#34;&gt;root@ubuntu:~/webui-aria2# node node-server.js
WebUI Aria2 Server is running on http://localhost:8888
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出现&lt;code&gt;WebUI Aria2 Server is running on http://localhost:8888&lt;/code&gt;说明WebUI已经启动成功，访问 http://YourIP:8888 即可进入Web界面&lt;/p&gt;
&lt;p&gt;还是依次按下键盘的ctrl、A、D 这三个键，回到前一个会话，如果是用ssh客户端（如Putty）登陆的会话，这个时候就可以关闭这个会话了。&lt;/p&gt;
&lt;h3 id=&#34;进入webui界面通过rpc接口连接aria2&#34;&gt;进入WebUI界面，通过rpc接口连接Aria2&lt;/h3&gt;
&lt;p&gt;如果你是在有公网ip的vps上搭建的，访问“公网ip:8888/”就行了。&lt;/p&gt;
&lt;p&gt;进入WebUI界面后可能会提示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-undefined&#34;&gt;糟糕！ 连接到 Aria2 RPC 服务器时认证失败，将在10秒后重试。
您可能需要确认您的身份验证信息，请前往 设置 &amp;gt; 连接设置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候在设置&amp;gt;连接设置里设置一下RPC服务&lt;/p&gt;
&lt;p&gt;主机后面填写Aria2服务所在的主机的ip，端口就是第四步中启动Aria2 监听RPC的端口6800，密码令牌就是参数**–rpc-secret 后面的字符串，**第四步中让你记住的那个。这三个填完点最下面的“保存连接配置”即可。只要配置填对了就能连接到Aria2了&lt;/p&gt;
&lt;p&gt;教程到此结束了,其余的设置可参考下面的链接,里面有具体的用法和具体含义&lt;/p&gt;
&lt;h3 id=&#34;参考链接&#34;&gt;参考链接:&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.sunriseydy.top/technology/server-blog/server/zaiubuntushangyongaria2hearia2webuishixianyuanchengduoxianchengxiazai/&#34;&gt;ubuntu上安装aria2及webui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ywnz.com/linuxjc/2686.html&#34;&gt;在Ubuntu 18.04系统下安装配置和使用aria2&lt;/a&gt;&lt;/p&gt;
">服务器搭建aira2和webui</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-ftp/"" data-c="
          &lt;p&gt;新买的服务器安装ftp服务器&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;1、使用命令安装&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt install vsftpd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、为FTP添加用户&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo useradd -m ye&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、为ye用户设置密码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo passwd ye&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4、在/home/ye/目录中创建一个download目录用于作为ftp的根目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cd /home/ye&lt;/p&gt;
&lt;p&gt;mkdir download&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5、使用 sudo vim /etc/vsftpd.conf编辑配置文件，用于配置目录信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;local_root=/home/sunftp/ftpdir
allow_writeable_chroot=YES
chroot_local_user=YES
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、其他选择默认，保存退出，然后启动&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo service vsftpd start&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;备注:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/liwb94/article/details/80090082&#34;&gt;vsftpd参数参考&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第五步中的配置: 如果不进行参数配置也是可以的.用户的根目录为/home/ye.即当前登录用户的根目录.对于我们来说够用了,不用配置太多&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">服务器搭建ftp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/fu-wu-qi-da-jian-http-fu-wu/"" data-c="
          &lt;p&gt;新买的服务器安装http服务器&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;首先安装Apache&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt-get install apache2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Apache2的默认访问端口为80，当端口被占用时需要更改其访问端口&lt;/p&gt;
&lt;p&gt;进入apache2的安装目录  /etc/apache2/，修改器ports.conf文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# If you just change the port or add more ports here, you will likely also
# have to change the VirtualHost statement in
# /etc/apache2/sites-enabled/000-default.conf

#Listen 80
Listen 8001

&amp;lt;IfModule ssl_module&amp;gt;
        Listen 443
&amp;lt;/IfModule&amp;gt;

&amp;lt;IfModule mod_gnutls.c&amp;gt;
        Listen 443
&amp;lt;/IfModule&amp;gt;

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入 目录 /etc/apache2/sites-available， 修改000-default.conf文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#&amp;lt;VirtualHost *:80&amp;gt;
&amp;lt;VirtualHost *:8001&amp;gt;
        # The ServerName directive sets the request scheme, hostname and port that
        # the server uses to identify itself. This is used when creating
        # redirection URLs. In the context of virtual hosts, the ServerName
        # specifies what hostname must appear in the request&#39;s Host: header to
        # match this virtual host. For the default virtual host (this file) this
        # value is not decisive as it is used as a last resort host regardless.
        # However, you must set it for any further virtual host explicitly.
        #ServerName www.example.com

        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/html

        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
        # error, crit, alert, emerg.
        # It is also possible to configure the loglevel for particular
        # modules, e.g.
        #LogLevel info ssl:warn

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        # For most configuration files from conf-available/, which are
        # enabled or disabled at a global level, it is possible to
        # include a line for only one particular virtual host. For example the
        # following line enables the CGI configuration for this host only
        # after it has been globally disabled with &amp;quot;a2disconf&amp;quot;.
        #Include conf-available/serve-cgi-bin.conf
&amp;lt;/VirtualHost&amp;gt;

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后重启apache服务器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo /etc/init.d/apache2 restart&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;apache服务器的默认目录在/var/www/html，如果想利用http服务器下载文件，需要删除其index.html文件，然后把文件放在该目录即可.&lt;/p&gt;
">服务器搭建http服务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/fu-wu-qi-duan-da-jian-ss/"" data-c="
          &lt;p&gt;新买的服务器安装ss&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h2 id=&#34;安装ss&#34;&gt;安装ss&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt install python3-pip&lt;/p&gt;
&lt;p&gt;pip3 install shadowsocks&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;
&lt;p&gt;2.1直接启动&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ssserver -p 8388 -k password -m rc4-md5 -d start&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.2配置文件启动&lt;/p&gt;
&lt;p&gt;新建/etc/shadowsocks.json文件并写入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;server&amp;quot;:&amp;quot;xxxxxx&amp;quot;,
    &amp;quot;server_port&amp;quot;:xxxx,
    &amp;quot;local_address&amp;quot;:&amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;local_port&amp;quot;:1080,
    &amp;quot;password&amp;quot;:&amp;quot;xxxxx&amp;quot;,
    &amp;quot;timeout&amp;quot;:300,
    &amp;quot;method&amp;quot;:&amp;quot;rc4-md5&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用命令启动&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ssserver -c /etc/shadowsocks.json -d start&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;开机自启动&#34;&gt;开机自启动&lt;/h2&gt;
&lt;p&gt;新建 /etc/ss.conf并写入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[program:shadowsocks]
command=ssserver -c /etc/shadowsocks.json
autostart=true
autorestart=true
user=root
log_stderr=true
logfile=/var/log/shadowsocks.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开/etc/rc.local并添加一行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;service ss start&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;
&lt;p&gt;启动ss出现undefined symbol: EVP_CIPHER_CTX_cleanup错误。&lt;/p&gt;
&lt;p&gt;修改方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用vim打开文件：vim /PYTHON_PATH/dist-packages/shadowsocks/crypto/openssl.py (该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)&lt;/li&gt;
&lt;li&gt;跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup）&lt;/li&gt;
&lt;li&gt;进入编辑模式&lt;/li&gt;
&lt;li&gt;将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)&lt;br&gt;
改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)&lt;/li&gt;
&lt;li&gt;再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)&lt;br&gt;
改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)&lt;/li&gt;
&lt;li&gt;保存并退出&lt;/li&gt;
&lt;li&gt;启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录&lt;/li&gt;
&lt;li&gt;问题解决&lt;/li&gt;
&lt;/ol&gt;
">服务器端搭建ss</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/l4d2-fang-d-zhi-nan/"" data-c="
          &lt;p&gt;最近一年来,求生之路2自建的服务器一直处于被DDOS的状态,没有办法玩.&lt;/p&gt;
&lt;p&gt;可能触及到了某些人的利益,想围城.但是我自己的服务器,我又不出售,就被D了,真是太不道德了.&lt;/p&gt;
&lt;p&gt;各种爬贴,总结了以下知识点.&lt;/p&gt;
&lt;!-- more--&gt;
&lt;h3 id=&#34;d的原理&#34;&gt;D的原理:&lt;/h3&gt;
&lt;p&gt;从steam上可以索引到亚洲的服务器,找到你的私服真实ip.然后进行针对性的DDOS.&lt;/p&gt;
&lt;p&gt;那么我们怎么防范呢.其实很简单,只需要隐藏自己的私服ip就可以.&lt;/p&gt;
&lt;p&gt;有以下两种方式,我们以前采用的是方式1,但是后来又被D了,目前正在使用方式2.&lt;/p&gt;
&lt;h3 id=&#34;方式1&#34;&gt;方式1&lt;/h3&gt;
&lt;p&gt;在server.cfg里面,添加sv_tags &amp;quot;hidden&amp;quot;.这个指的是不把当前服务器加到steam大厅,那么steam索引不到该ip就不会被发现.&lt;/p&gt;
&lt;p&gt;但是后来还是被D了,怎么回事呢.原因如下:hidden可以通过匹配进，说到底其实hidden还是会连接steam服务器的，有人点快速加入的时候会被steam服务器分配到hidden的服务器，我们以前就加过hidden,要么是被steam分配过,要么就是我们群里有内鬼,ip暴露了.&lt;/p&gt;
&lt;h3 id=&#34;方式2&#34;&gt;方式2&lt;/h3&gt;
&lt;p&gt;启动时添加-nomaster参数.&lt;/p&gt;
&lt;p&gt;./srcds_run -game left4dead2  +exec server.cfg -console -insecure +hostport 27015 +map c2m1_highway  +ip 0.0.0.0 tcp -nomaster -tickrate 60&lt;br&gt;
-nomaster(这一句是防止ddos用)&lt;/p&gt;
&lt;p&gt;这句话就是真正的不被steam索引&lt;/p&gt;
&lt;p&gt;以上两种方式,玩游戏的时候均需要使用connect xxx使用ip进.&lt;/p&gt;
">L4D2防D指南</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/wu-yue-ri-ji/"" data-c="
          &lt;p&gt;又是新的一个月,五一假期连上一带一路会议,美滋滋的在家歇了8天,嘿嘿嘿&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;2019-05-03&#34;&gt;2019-05-03&lt;/h3&gt;
&lt;p&gt;放假在家装灯,可以省去200块钱安装费,真的是费劲.不过装完感觉挺漂亮的,good job!贴两张图片.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190528103427.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190528103506.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2019-05-16&#34;&gt;2019-05-16&lt;/h3&gt;
&lt;p&gt;昨天进行了真人CS活动和烤肉活动.真人CS打的是真疼啊.教练专门说了不让近距离设计+不准打头.可到了实战,大家冲锋起来根本顾不上了.啪啪啪,贼激烈.附上图和视频链接.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190528103533.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://youtu.be/dUbx93h0Fg0&#34;&gt;视频1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://youtu.be/zoSLeRBxDT0&#34;&gt;视频2&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2019-05-18&#34;&gt;2019-05-18&lt;/h3&gt;
&lt;p&gt;今天在家刷了权游第四季,刷完了,这个剧看着真不错,各种伏笔,各种意外发生.可以称为跌宕起伏,曲转通幽.令人厌恶的乔弗里被小指头加荆棘女王毒死了.然后让小恶魔背了锅.小恶魔杀死了自己的雪依,杀死了自己的泰温,不知道下一集怎么发展了,真的是达成了小指头的设想,一切都是乱糟糟的,混乱是上升的阶梯.感觉这个人和全球高武的方平一样,要是写书的话,才想一个主角一样,自己实力并不强大,但是可以算计各种人,然后制造混乱,自己从中获利.2333&lt;/p&gt;
">五月日记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/screen-ming-ling-su-cha/"" data-c="
          &lt;p&gt;系统管理员经常需要SSH 或者telent 远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。&lt;/p&gt;
&lt;!-- more--&gt;
&lt;p&gt;GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。&lt;/p&gt;
&lt;p&gt;screen -S yourname -&amp;gt; 新建一个叫yourname的session&lt;br&gt;
screen -ls -&amp;gt; 列出当前所有的session&lt;br&gt;
screen -r yourname -&amp;gt; 回到yourname这个session&lt;br&gt;
screen -d yourname -&amp;gt; 远程detach某个session&lt;br&gt;
screen -d -r yourname -&amp;gt; 结束当前session并回到yourname这个session&lt;/p&gt;
&lt;p&gt;附录:&lt;/p&gt;
&lt;p&gt;问题描述:&lt;/p&gt;
&lt;p&gt;userA首先登录系统，使用screen开启了一个session，然后detach这个窗口。&lt;/p&gt;
&lt;p&gt;userB然后登录系统，通过su - userA 变成userA，然后使用screen -r 恢复之前detached窗口，这时系统报如下错误:&lt;/p&gt;
&lt;p&gt;Cannot open your terminal &#39;/dev/pts/1&#39; - please check.&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;p&gt;userB在 su - userA以后，执行如下命令即可:&lt;/p&gt;
&lt;p&gt;script /dev/null&lt;/p&gt;
&lt;p&gt;参考链接:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_704836f401010osn.html&#34;&gt;解决screen Cannot open your terminal &#39;/dev/pts/1&#39;问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/lpfuture/p/5786843.html&#34;&gt;linux screen工具&lt;/a&gt;&lt;/p&gt;
">screen命令速查</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/picgo-ce-shi/"" data-c="
          &lt;p&gt;前几天鼓捣图床,一直想找一个上传方便,并且备份容易的.主要是被七牛云的给搞怕了,不然还是会和现在一样,一大堆的无图博客.&lt;/p&gt;
&lt;p&gt;找了半天,发现一款程序员的个人作品,&lt;a href=&#34;https://github.com/Molunerfinn/PicGo&#34;&gt;picgo&lt;/a&gt;,支持使用github作为图床.emmm,nice!!!&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;一开始我的图片仓库,为了隐私,设置为了private性质,导致上传的图片,过一会儿访问就404了.当时也不知道为什么,一度放弃了picgo.&lt;/p&gt;
&lt;p&gt;后来又看了一篇文章,上面说道:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对应储存图片的repo必须是public，如果是pravite，那么图片地址会带有一个随时刷新token，这样虽然repo他人不可见，但是也没法作为图床用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;hiahiahia,原来如此.github启动,private--&amp;gt;public完成.&lt;/p&gt;
&lt;p&gt;做个测试来看一看.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yeziblogpic/blogpic/master/20190408134529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">picgo测试</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/4-yue-ri-ji/"" data-c="
          &lt;p&gt;折腾了很多种评论系统,准备把日记放在评论里面写,比较方便一些,不然hexo里面没有类似说说的功能,每发一个说说就要发一篇文章,看起来博客就比较乱了.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;后来我放弃了,一来是比较复杂,指不定哪天评论就死了,二来备份麻烦,所以我准备还是一个月一篇文章作为日志写吧.这样一篇MD就够了.不影响博客整洁.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2019-04-01&#34;&gt;2019-04-01&lt;/h3&gt;
&lt;p&gt;这两天在V站上看到博客帖,然后爬了帖子回复上的网站,又萌生了写博客的想法.&lt;/p&gt;
&lt;p&gt;花了一天时间,又把github的博客整了起来.以前的内容全部删除了,以后想到什么写什么,也不当做技术博客维护了(毕竟自己没啥产出hiahiahia)&lt;/p&gt;
&lt;p&gt;需要思考一下,博客图床的问题,七牛云的事情不想多说了,浪费了两天才搞完.&lt;/p&gt;
&lt;p&gt;原本想使用picgo,但是用下来发现,效果并不好,把github当图床,只能用一小会儿,过一会儿就失效了.估计是picgo有bug吧.这个还需要好好看一下,毕竟迁移成本的问题.比不上WP之类的动态博客.&lt;/p&gt;
&lt;p&gt;以后工作笔记用vnote+github私库,博客划水用hexo.&lt;/p&gt;
&lt;h3 id=&#34;2019-04-07&#34;&gt;2019-04-07&lt;/h3&gt;
&lt;p&gt;清明节假期过去一半了,这两天睡到自然醒,还是感觉好累啊.&lt;/p&gt;
&lt;p&gt;刷了两集权力的游戏,实在是刷不动了.&lt;/p&gt;
&lt;p&gt;然后又去刷纯黑的游戏视频,他玩游戏真的是太厉害了,根本不给敌人开枪的机会,敌人就没有了.背板狂魔.&lt;/p&gt;
&lt;p&gt;耍了几把王者,7连胜又5连败,没啥说的了.&lt;/p&gt;
&lt;p&gt;感觉放假好无聊啊,没有抢到回家的车票就只能在宿舍窝三天了,哎&lt;/p&gt;
&lt;h3 id=&#34;2019-04-08&#34;&gt;2019-04-08&lt;/h3&gt;
&lt;p&gt;心心念念我的博客图床,今天又看了很多文章,终于搞定了,还是使用picgo+github.稳如老狗.小小的开心一下.继续整工作的事情吧.&lt;/p&gt;
&lt;h3 id=&#34;2019-04-21&#34;&gt;2019-04-21&lt;/h3&gt;
&lt;p&gt;周末两天又过去了.感觉好累啊.&lt;/p&gt;
&lt;p&gt;周六看了权游第三季,看完了血色婚礼,怎么说呢,人不能无信,既然自己已经立下了誓言,就要守信.然后晚上去聚餐了,吃的铁锅炖大鱼,花了450,贵死了,肉疼半天.大表哥可着贵的点.吃在他身,痛在我心.&lt;/p&gt;
&lt;p&gt;周末,还是啥也没干,躺在床上看完了全球高武这部小说,以后就要开始追更生涯了.这个小说前面写的挺好的,后面写崩了.越看越难受.不知道作者啥时候能写完.&lt;/p&gt;
">4月日记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqzhanghao.github.io/post/about/"" data-c="
          &lt;p&gt;安卓程序员&lt;/p&gt;
&lt;p&gt;喜欢学习新知识，喜欢折腾新玩意儿&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>